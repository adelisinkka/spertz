<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPERTZ</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Montserrat:wght@300;400;500&family=Cormorant+Garamond:wght@400;600;700&family=DM+Serif+Display&family=Quicksand:wght@400;500;600&family=Orbitron:wght@400;600;700&family=Space+Grotesk:wght@400;500;600&family=Poppins:wght@300;400;500;600&family=Playfair+Display:wght@500;700&family=Josefin+Sans:wght@300;400;600&family=Manrope:wght@300;400;600&family=Nunito:wght@300;400;600&family=IBM+Plex+Sans:wght@300;400;500;600&family=Merriweather:wght@300;400;700&family=Cabin:wght@400;600&family=Caveat:wght@400;600&family=Patrick+Hand&display=swap');

    * {
      box-sizing: border-box;
    }

    :root {
      --font-body: 'Montserrat', sans-serif;
      --font-display: 'Cinzel', serif;
      --font-accent: 'Cinzel', serif;

      --bg-1: #0d0f1c;
      --bg-2: #15182a;
      --bg-3: #0d0f1c;
      --text: #e8e8e8;
      --text-soft: #d9d9d9;
      --text-mutNed: #d5d5d5;
      --text-faint: #888;
      --heading: #f0f0f0;
      --accent: #c6a664;
      --accent-2: #9bc1ff;
      --accent-3: #a4c8ff;
      --accent-soft: color-mix(in srgb, var(--accent) 16%, transparent);
      --accent-border: color-mix(in srgb, var(--accent) 35%, transparent);
      --accent-glow: color-mix(in srgb, var(--accent) 35%, transparent);
      --accent-2-border: color-mix(in srgb, var(--accent-2) 35%, transparent);

      --border-strong: rgba(255, 255, 255, 0.2);
      --border: rgba(255, 255, 255, 0.12);
      --border-soft: rgba(255, 255, 255, 0.1);
      --border-softer: rgba(255, 255, 255, 0.06);

      --surface: rgba(255, 255, 255, 0.04);
      --surface-2: rgba(255, 255, 255, 0.05);
      --surface-3: rgba(255, 255, 255, 0.03);
      --surface-dark: rgba(0, 0, 0, 0.18);

      --nav-bg: rgba(255, 255, 255, 0.05);
      --nav-hover: rgba(255, 255, 255, 0.08);
      --menu-bg: rgba(15, 18, 35, 0.95);
      --table-head-bg: rgba(15, 18, 35, 0.9);

      --highlight: rgba(155, 193, 255, 0.06);
      --highlight-strong: rgba(155, 193, 255, 0.12);
      --shadow: rgba(255, 255, 255, 0.04);
      --focus: rgba(155, 193, 255, 0.45);

      --pill-border: rgba(255, 255, 255, 0.14);
      --pill-shadow: rgba(155, 193, 255, 0.06);
      --code-bg: rgba(0, 0, 0, 0.25);
      --code-border: rgba(255, 255, 255, 0.1);

      --star-color: #ffffff;
      --star-opacity: 0.08;
    }

    body[data-theme="fantasy"] {
      --font-body: 'Cormorant Garamond', serif;
      --font-display: 'DM Serif Display', serif;
      --font-accent: 'DM Serif Display', serif;
      --bg-1: #1a0f12;
      --bg-2: #2b1a20;
      --bg-3: #120a0d;
      --text: #f4ede4;
      --text-soft: #e7dbce;
      --text-muted: #dccfc2;
      --text-faint: #b7a89a;
      --heading: #fff5ea;
      --accent: #d6a862;
      --accent-2: #c08cff;
      --accent-3: #e0b4ff;
      --nav-bg: rgba(255, 240, 220, 0.06);
      --menu-bg: rgba(38, 22, 30, 0.95);
      --table-head-bg: rgba(38, 22, 30, 0.9);
      --highlight: rgba(192, 140, 255, 0.08);
      --shadow: rgba(255, 240, 220, 0.06);
      --star-opacity: 0.05;
    }

    body[data-theme="dreamy"] {
      --font-body: 'Quicksand', sans-serif;
      --font-display: 'DM Serif Display', serif;
      --font-accent: 'Quicksand', sans-serif;
      --bg-1: #0b1022;
      --bg-2: #1a2a4a;
      --bg-3: #0f1426;
      --text: #f0f4ff;
      --text-soft: #dde6ff;
      --text-muted: #cdd7f5;
      --text-faint: #9fb0d6;
      --heading: #f7f9ff;
      --accent: #9ad4ff;
      --accent-2: #c7a7ff;
      --accent-3: #b6dcff;
      --nav-bg: rgba(230, 238, 255, 0.08);
      --menu-bg: rgba(20, 28, 54, 0.95);
      --table-head-bg: rgba(20, 28, 54, 0.9);
      --highlight: rgba(199, 167, 255, 0.1);
      --shadow: rgba(203, 220, 255, 0.08);
      --star-opacity: 0.12;
    }

    body[data-theme="futuristic"] {
      --font-body: 'Space Grotesk', sans-serif;
      --font-display: 'Orbitron', sans-serif;
      --font-accent: 'Orbitron', sans-serif;
      --bg-1: #04060c;
      --bg-2: #0c1020;
      --bg-3: #03050a;
      --text: #e6f7ff;
      --text-soft: #cdefff;
      --text-muted: #b6dbe8;
      --text-faint: #7aa1b0;
      --heading: #f5fbff;
      --accent: #48f1ff;
      --accent-2: #7affc4;
      --accent-3: #88f7ff;
      --nav-bg: rgba(72, 241, 255, 0.08);
      --menu-bg: rgba(6, 12, 28, 0.97);
      --table-head-bg: rgba(6, 12, 28, 0.9);
      --highlight: rgba(122, 255, 196, 0.12);
      --shadow: rgba(72, 241, 255, 0.08);
      --star-opacity: 0.06;
    }

    body[data-theme="simple"] {
      --font-body: 'Poppins', sans-serif;
      --font-display: 'Poppins', sans-serif;
      --font-accent: 'Poppins', sans-serif;
      --bg-1: #f7f7f7;
      --bg-2: #f0f0f0;
      --bg-3: #ffffff;
      --text: #1c1c1c;
      --text-soft: #2f2f2f;
      --text-muted: #444;
      --text-faint: #6a6a6a;
      --heading: #0f0f0f;
      --accent: #2a6fdb;
      --accent-2: #ef7a44;
      --accent-3: #2a6fdb;
      --border-strong: rgba(0, 0, 0, 0.15);
      --border: rgba(0, 0, 0, 0.12);
      --border-soft: rgba(0, 0, 0, 0.08);
      --border-softer: rgba(0, 0, 0, 0.06);
      --surface: rgba(0, 0, 0, 0.03);
      --surface-2: rgba(0, 0, 0, 0.04);
      --surface-3: rgba(0, 0, 0, 0.02);
      --surface-dark: rgba(0, 0, 0, 0.06);
      --nav-bg: rgba(0, 0, 0, 0.04);
      --menu-bg: rgba(245, 245, 245, 0.98);
      --table-head-bg: rgba(245, 245, 245, 0.98);
      --highlight: rgba(42, 111, 219, 0.08);
      --shadow: rgba(0, 0, 0, 0.04);
      --focus: rgba(42, 111, 219, 0.35);
      --star-opacity: 0;
    }

    body[data-theme="sunlit"] {
      --font-body: 'Manrope', sans-serif;
      --font-display: 'Playfair Display', serif;
      --font-accent: 'Playfair Display', serif;
      --bg-1: #fff7e8;
      --bg-2: #ffe9c7;
      --bg-3: #fffdf6;
      --text: #2a231d;
      --text-soft: #3b3127;
      --text-muted: #564536;
      --text-faint: #7a6452;
      --heading: #201910;
      --accent: #d9822b;
      --accent-2: #3a7bd5;
      --accent-3: #f2a154;
      --border-strong: rgba(42, 35, 29, 0.18);
      --border: rgba(42, 35, 29, 0.12);
      --border-soft: rgba(42, 35, 29, 0.08);
      --border-softer: rgba(42, 35, 29, 0.06);
      --surface: rgba(42, 35, 29, 0.04);
      --surface-2: rgba(42, 35, 29, 0.05);
      --surface-3: rgba(42, 35, 29, 0.03);
      --surface-dark: rgba(42, 35, 29, 0.08);
      --nav-bg: rgba(217, 130, 43, 0.1);
      --menu-bg: rgba(255, 247, 232, 0.98);
      --table-head-bg: rgba(255, 247, 232, 0.98);
      --highlight: rgba(58, 123, 213, 0.1);
      --shadow: rgba(42, 35, 29, 0.06);
      --focus: rgba(58, 123, 213, 0.35);
      --star-opacity: 0;
    }

    body[data-theme="linen"] {
      --font-body: 'Merriweather', serif;
      --font-display: 'Cinzel', serif;
      --font-accent: 'Cinzel', serif;
      --bg-1: #f6f1e7;
      --bg-2: #efe7db;
      --bg-3: #fbf8f2;
      --text: #2b2420;
      --text-soft: #3e3530;
      --text-muted: #5d5047;
      --text-faint: #7c6d61;
      --heading: #231c17;
      --accent: #b86b4b;
      --accent-2: #557a95;
      --accent-3: #d4a087;
      --border-strong: rgba(43, 36, 32, 0.18);
      --border: rgba(43, 36, 32, 0.12);
      --border-soft: rgba(43, 36, 32, 0.08);
      --border-softer: rgba(43, 36, 32, 0.06);
      --surface: rgba(43, 36, 32, 0.04);
      --surface-2: rgba(43, 36, 32, 0.05);
      --surface-3: rgba(43, 36, 32, 0.03);
      --surface-dark: rgba(43, 36, 32, 0.08);
      --nav-bg: rgba(184, 107, 75, 0.1);
      --menu-bg: rgba(251, 248, 242, 0.98);
      --table-head-bg: rgba(251, 248, 242, 0.98);
      --highlight: rgba(85, 122, 149, 0.12);
      --shadow: rgba(43, 36, 32, 0.06);
      --focus: rgba(85, 122, 149, 0.35);
      --star-opacity: 0;
    }

    body[data-theme="handwritten"] {
      --font-body: 'Patrick Hand', cursive;
      --font-display: 'Caveat', cursive;
      --font-accent: 'Caveat', cursive;
      --bg-1: #fef9f4;
      --bg-2: #f7e9df;
      --bg-3: #fffdf9;
      --text: #2a2421;
      --text-soft: #3b322d;
      --text-muted: #574a43;
      --text-faint: #7a6a61;
      --heading: #201a17;
      --accent: #c46b8a;
      --accent-2: #7a9e7e;
      --accent-3: #de9cb2;
      --border-strong: rgba(42, 36, 33, 0.18);
      --border: rgba(42, 36, 33, 0.12);
      --border-soft: rgba(42, 36, 33, 0.08);
      --border-softer: rgba(42, 36, 33, 0.06);
      --surface: rgba(42, 36, 33, 0.04);
      --surface-2: rgba(42, 36, 33, 0.05);
      --surface-3: rgba(42, 36, 33, 0.03);
      --surface-dark: rgba(42, 36, 33, 0.08);
      --nav-bg: rgba(196, 107, 138, 0.1);
      --menu-bg: rgba(255, 249, 244, 0.98);
      --table-head-bg: rgba(255, 249, 244, 0.98);
      --highlight: rgba(122, 158, 126, 0.12);
      --shadow: rgba(42, 36, 33, 0.06);
      --focus: rgba(196, 107, 138, 0.35);
      --star-opacity: 0;
    }

    body[data-theme="adventure"] {
      --font-body: 'Cabin', sans-serif;
      --font-display: 'Playfair Display', serif;
      --font-accent: 'Playfair Display', serif;
      --bg-1: #0f1c1a;
      --bg-2: #19312a;
      --bg-3: #0c1412;
      --text: #eef4ef;
      --text-soft: #d5e3dc;
      --text-muted: #c0d0c7;
      --text-faint: #8aa39a;
      --heading: #f6fff9;
      --accent: #8dcf8d;
      --accent-2: #f0c36a;
      --accent-3: #a8e0a5;
      --nav-bg: rgba(141, 207, 141, 0.08);
      --menu-bg: rgba(16, 28, 24, 0.97);
      --table-head-bg: rgba(16, 28, 24, 0.9);
      --highlight: rgba(240, 195, 106, 0.12);
      --shadow: rgba(141, 207, 141, 0.08);
      --star-opacity: 0.04;
    }

    body[data-theme="star"] {
      --font-body: 'Manrope', sans-serif;
      --font-display: 'Josefin Sans', sans-serif;
      --font-accent: 'Josefin Sans', sans-serif;
      --bg-1: #050716;
      --bg-2: #11163b;
      --bg-3: #03040f;
      --text: #eef0ff;
      --text-soft: #d7dcff;
      --text-muted: #c2c9f2;
      --text-faint: #8b92c4;
      --heading: #ffffff;
      --accent: #ffe08a;
      --accent-2: #8cb6ff;
      --accent-3: #ffd9a3;
      --nav-bg: rgba(140, 182, 255, 0.08);
      --menu-bg: rgba(9, 12, 30, 0.97);
      --table-head-bg: rgba(9, 12, 30, 0.92);
      --highlight: rgba(255, 224, 138, 0.12);
      --shadow: rgba(140, 182, 255, 0.08);
      --star-opacity: 0.14;
    }

    body[data-theme="pinky"] {
      --font-body: 'Nunito', sans-serif;
      --font-display: 'DM Serif Display', serif;
      --font-accent: 'Nunito', sans-serif;
      --bg-1: #2a0f1c;
      --bg-2: #3b1527;
      --bg-3: #1b0912;
      --text: #ffeef5;
      --text-soft: #f8d8e7;
      --text-muted: #e7c2d3;
      --text-faint: #c392a6;
      --heading: #fff4fa;
      --accent: #ff8ec6;
      --accent-2: #ffb7da;
      --accent-3: #ffc6e4;
      --nav-bg: rgba(255, 183, 218, 0.1);
      --menu-bg: rgba(45, 15, 30, 0.97);
      --table-head-bg: rgba(45, 15, 30, 0.9);
      --highlight: rgba(255, 142, 198, 0.12);
      --shadow: rgba(255, 183, 218, 0.08);
      --star-opacity: 0.08;
    }

    body[data-theme="icy"] {
      --font-body: 'IBM Plex Sans', sans-serif;
      --font-display: 'Playfair Display', serif;
      --font-accent: 'IBM Plex Sans', sans-serif;
      --bg-1: #0b1218;
      --bg-2: #132433;
      --bg-3: #0b1218;
      --text: #eef9ff;
      --text-soft: #d9f0ff;
      --text-muted: #c2dfee;
      --text-faint: #89a8bc;
      --heading: #f7fcff;
      --accent: #8fd4ff;
      --accent-2: #b1f2ff;
      --accent-3: #bfe7ff;
      --nav-bg: rgba(143, 212, 255, 0.1);
      --menu-bg: rgba(10, 20, 30, 0.96);
      --table-head-bg: rgba(10, 20, 30, 0.9);
      --highlight: rgba(177, 242, 255, 0.14);
      --shadow: rgba(143, 212, 255, 0.08);
      --star-opacity: 0.1;
    }

    body[data-theme="classic"] {
      --font-body: 'Merriweather', serif;
      --font-display: 'Playfair Display', serif;
      --font-accent: 'Playfair Display', serif;
      --bg-1: #1b1410;
      --bg-2: #2a2019;
      --bg-3: #120d0a;
      --text: #f3e9dd;
      --text-soft: #e3d3c1;
      --text-muted: #d3c3b2;
      --text-faint: #b09f8e;
      --heading: #fff5e8;
      --accent: #d4a373;
      --accent-2: #c28a5b;
      --accent-3: #e1b68a;
      --nav-bg: rgba(212, 163, 115, 0.08);
      --menu-bg: rgba(30, 22, 18, 0.96);
      --table-head-bg: rgba(30, 22, 18, 0.92);
      --highlight: rgba(212, 163, 115, 0.12);
      --shadow: rgba(212, 163, 115, 0.08);
      --star-opacity: 0.04;
    }

    body {
      margin: 0;
      font-family: var(--font-body);
      background: radial-gradient(circle at 20% 30%, var(--bg-1), var(--bg-2) 60%, var(--bg-3) 100%);
      color: var(--text);
      overflow-x: hidden;
      -webkit-text-size-adjust: 100%;
    }

    img,
    canvas,
    svg,
    video {
      max-width: 100%;
      height: auto;
    }

    header {
      text-align: center;
      padding: 60px 20px 40px;
      font-family: var(--font-display);
      color: var(--heading);
    }

    header h1 {
      font-size: 2.8em;
      letter-spacing: 2px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    nav {
      display: flex;
      justify-content: center;
      position: sticky;
      top: 0;
      z-index: 200;
      border-top: 1px solid var(--border-strong);
      border-bottom: 1px solid var(--border-strong);
      background: var(--nav-bg);
      backdrop-filter: blur(8px);
      overflow: visible;
    }

    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      width: 100%;
      padding: 14px 18px;
      border: none;
      background: transparent;
      color: var(--heading);
      font-family: var(--font-body);
      font-size: 1em;
      cursor: pointer;
      border-bottom: 1px solid var(--border-soft);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .nav-toggle span {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .nav-items {
      display: flex;
      width: 100%;
      justify-content: center;
    }

    .nav-item {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      border-right: 1px solid var(--border-soft);
    }

    .nav-item:last-child {
      border-right: none;
    }

    .nav-link {
      flex: 1;
      padding: 18px 0;
      text-align: center;
      text-decoration: none;
      color: var(--text-soft);
      font-weight: 500;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
    }

    .nav-drop {
      width: 44px;
      height: 100%;
      border: none;
      background: transparent;
      color: var(--text-soft);
      cursor: pointer;
      border-left: 1px solid var(--border-soft);
      transition: all 0.3s ease;
      font-size: 0.9em;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .nav-link:hover,
    .nav-link.active,
    .nav-drop:hover {
      background: linear-gradient(90deg, var(--nav-hover), var(--surface-3));
      color: var(--heading);
      text-shadow: 0 0 8px var(--accent-3);
    }

    .nav-menu {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 210;
      background: var(--menu-bg);
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(10px);
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transform: translateY(-6px);
      transition: max-height 0.3s ease, opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
      z-index: 50;
    }

    .nav-menu a {
      display: block;
      padding: 12px 16px;
      text-decoration: none;
      color: var(--text-soft);
      border-top: 1px solid var(--border-softer);
      text-align: left;
      transition: all 0.2s ease;
    }

    .nav-menu a:hover {
      background: var(--highlight);
      color: var(--heading);
    }

    .nav-item:hover .nav-menu,
    .nav-item:focus-within .nav-menu,
    .nav-item.open .nav-menu {
      max-height: 420px;
      overflow-y: auto;
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .content {
      padding: 60px clamp(16px, 6vw, 48px);
      line-height: 1.8;
      text-align: center;
      max-width: 980px;
      margin: auto;
      width: min(100%, 980px);
    }

    .content h2 {
      font-family: var(--font-display);
      color: var(--accent);
      font-size: 2em;
      margin-bottom: 20px;
    }

    .content p {
      color: var(--text-muted);
      font-size: 1.1em;
    }

    footer {
      text-align: center;
      padding: 40px 0;
      color: var(--text-faint);
      font-size: 0.9em;
      border-top: 1px solid var(--border-soft);
      margin-top: 60px;
    }

    .stars::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(var(--star-color) 1px, transparent 1px),
        radial-gradient(var(--star-color) 1px, transparent 1px);
      background-size: 3px 3px, 2px 2px;
      opacity: var(--star-opacity);
      z-index: -1;
      animation: twinkle 20s linear infinite, twinkle2 40s linear infinite;
    }

    .style-picker {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--surface-2);
      font-family: var(--font-body);
      font-size: 0.95em;
    }

    .style-picker label {
      color: var(--text-soft);
      letter-spacing: 0.3px;
    }

    .style-picker select {
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--surface-3);
      color: var(--text);
      padding: 6px 12px;
      font-family: var(--font-body);
      cursor: pointer;
    }

    @keyframes twinkle {
      from { background-position: 0 0, 0 0; }
      to { background-position: -50px -50px, 0 0; }
    }

    @keyframes twinkle2 {
      from { background-position: 0 0, 0 0; }
      to { background-position: 0 0, -100px -100px; }
    }

    /* === PHONETICS ARCHIVE UI === */
    .phonetics-archive {
      margin-top: 30px;
      display: grid;
      gap: 24px;
      width: 100%;
    }

    .info-card {
      text-align: left;
      padding: 22px 22px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--surface);
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px var(--shadow);
    }

    .info-card h3 {
      margin: 0 0 14px;
      font-family: var(--font-display);
      letter-spacing: 0.6px;
      color: var(--accent);
      font-size: 1.35em;
    }

    .subsection h4 {
      margin: 18px 0 10px;
      font-weight: 500;
      letter-spacing: 0.4px;
      color: var(--accent-2);
      font-size: 1.05em;
    }

    .mini-note {
      margin: 0 0 14px;
      opacity: 0.9;
      color: var(--text-muted);
    }

    .table-wrap {
      width: 100%;
      overflow-x: auto;
      border-radius: 12px;
      -webkit-overflow-scrolling: touch;
    }

    .archive-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 640px;
    }

    .archive-table th,
    .archive-table td {
      padding: 12px 12px;
      border-bottom: 1px solid var(--border-softer);
      vertical-align: top;
    }

    .archive-table thead th {
      position: sticky;
      top: 0;
      background: var(--table-head-bg);
      backdrop-filter: blur(8px);
      color: var(--heading);
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .archive-table td {
      color: var(--text-soft);
    }

    .archive-table tbody tr:hover {
      background: var(--highlight);
    }

    .consonant-card .archive-table {
      table-layout: fixed;
    }

    .consonant-card .archive-table th:nth-child(1),
    .consonant-card .archive-table td:nth-child(1) {
      width: 56px;
      text-align: center;
    }

    .consonant-card .archive-table th:nth-child(2),
    .consonant-card .archive-table td:nth-child(2) {
      width: 110px;
    }

    .consonant-card .archive-table th:nth-child(3),
    .consonant-card .archive-table td:nth-child(3) {
      width: 90px;
    }

    .vowel-card .archive-table {
      table-layout: fixed;
    }

    .vowel-card .archive-table th:nth-child(1),
    .vowel-card .archive-table td:nth-child(1) {
      width: 56px;
      text-align: center;
    }

    .vowel-card .archive-table th:nth-child(2),
    .vowel-card .archive-table td:nth-child(2) {
      width: 110px;
    }

    .vowel-card .archive-table th:nth-child(3),
    .vowel-card .archive-table td:nth-child(3) {
      width: 90px;
    }

    .syllable-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 9px 12px;
      border-radius: 999px;
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text);
      letter-spacing: 0.3px;
      font-size: 0.95em;
      box-shadow: 0 0 14px var(--pill-shadow);
    }

    /* Accordion */
    .accordion {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }

    .accordion-btn {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      padding: 14px 14px;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      letter-spacing: 0.25px;
      transition: all 0.25s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .accordion-btn:hover {
      background: var(--highlight);
      box-shadow: 0 0 18px var(--highlight-strong);
    }

    .acc-icon {
      font-size: 1.2em;
      opacity: 0.9;
    }

    .accordion-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s ease;
      border-radius: 12px;
      padding: 0 12px;
    }

    .accordion-panel p {
      margin: 12px 0 14px;
      color: var(--text-muted);
    }

    /* Story cards (collapsible) */
    .story-card .story-toggle {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      letter-spacing: 0.25px;
      transition: all 0.25s ease;
      margin-top: 12px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .story-card .story-toggle:hover {
      background: var(--highlight);
      box-shadow: 0 0 18px var(--highlight-strong);
    }

    .story-card .story-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s ease;
      border-radius: 12px;
      padding: 0 12px;
      margin-top: 10px;
    }

    /* === GRAMMAR ARCHIVE UI === */
.grammar-archive {
  margin-top: 30px;
  display: grid;
  gap: 24px;
  width: 100%;
}

.grammar-card {
  text-align: left;
  padding: 22px 22px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: var(--surface);
  backdrop-filter: blur(10px);
  box-shadow: 0 0 25px var(--shadow);
}

.grammar-card h3 {
  margin: 0 0 14px;
  font-family: var(--font-display);
  letter-spacing: 0.6px;
  color: var(--accent);
  font-size: 1.35em;
}

.grammar-card p {
  margin: 0 0 12px;
  color: var(--text-muted);
  font-size: 1.05em;
  line-height: 1.85;
}

.grammar-divider {
  margin: 16px 0;
  height: 1px;
  width: 100%;
  background: var(--border-softer);
}

.grammar-highlight {
  border: 1px solid color-mix(in srgb, var(--accent-2) 22%, transparent);
  background: color-mix(in srgb, var(--accent-2) 12%, transparent);
  border-radius: 12px;
  padding: 14px 14px;
  margin-top: 12px;
}

.grammar-highlight-title {
  margin: 0 0 10px;
  color: var(--accent-2);
  font-weight: 500;
  letter-spacing: 0.3px;
}

.grammar-list {
  margin: 0;
  padding-left: 18px;
  color: var(--text-soft);
}

.grammar-list li {
  margin: 8px 0;
  line-height: 1.7;
}

.example-box {
  margin-top: 12px;
  border-radius: 12px;
  border: 1px dashed var(--border);
  background: var(--surface-dark);
  padding: 14px 14px;
  color: var(--text-muted);
}

.example-box b {
  color: var(--heading);
}

.tag-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.tag-pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid var(--pill-border);
  background: var(--surface-2);
  color: var(--text);
  letter-spacing: 0.3px;
  font-size: 0.95em;
  box-shadow: 0 0 14px var(--pill-shadow);
}

/* === CASE SYSTEM TABLE === */
.case-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
  min-width: 680px;
}

.case-table th,
.case-table td {
  padding: 12px 12px;
  border-bottom: 1px solid var(--border-softer);
  vertical-align: top;
}

.case-table thead th {
  position: sticky;
  top: 0;
  background: var(--table-head-bg);
  backdrop-filter: blur(8px);
  color: var(--heading);
  font-weight: 500;
  letter-spacing: 0.3px;
}

.case-table tbody tr:hover {
  background: var(--accent-soft);
}

.badge {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-radius: 999px;
  border: 1px solid var(--pill-border);
  background: var(--surface-2);
  color: var(--text);
  letter-spacing: 0.2px;
  font-size: 0.95em;
  box-shadow: 0 0 14px var(--accent-soft);
}

.badge code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.95em;
  padding: 2px 6px;
  border-radius: 8px;
  background: var(--code-bg);
  border: 1px solid var(--code-border);
}

.rule-note {
  margin-top: 12px;
  border-radius: 12px;
  border: 1px solid var(--accent-border);
  background: var(--accent-soft);
  padding: 14px 14px;
  color: var(--text-muted);
}

.rule-note b {
  color: var(--heading);
}

/* === NOUN MARKERS UI === */
.marker-grid {
  display: grid;
  gap: 12px;
  margin-top: 14px;
}

.marker-row {
  border-radius: 12px;
  border: 1px solid var(--border);
  background: var(--surface-3);
  padding: 14px 14px;
}

.marker-row h4 {
  margin: 0 0 8px;
  font-weight: 500;
  letter-spacing: 0.35px;
  color: var(--accent-2);
  font-size: 1.05em;
}

.marker-row p {
  margin: 0;
  color: var(--text-muted);
}

.inline-code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.95em;
  padding: 2px 6px;
  border-radius: 8px;
  background: var(--code-bg);
  border: 1px solid var(--code-border);
  color: var(--heading);
}

.honorific-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}

.honorific-pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid var(--pill-border);
  background: var(--surface-2);
  color: var(--text);
  letter-spacing: 0.2px;
  font-size: 0.95em;
  box-shadow: 0 0 14px var(--pill-shadow);
}

.honorific-pill code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  background: var(--code-bg);
  border: 1px solid var(--code-border);
  padding: 2px 6px;
  border-radius: 8px;
  color: var(--heading);
}

/* === Verb suffix order: show sequence clearly === */
.suffix-order {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  padding: 6px 0;
}

.suffix-step {
  position: relative;
  padding: 10px 14px 10px 46px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: var(--surface-2);
  color: var(--text);
  letter-spacing: 0.25px;
  box-shadow: 0 0 14px var(--pill-shadow);
  line-height: 1.2;
  white-space: nowrap;
}

/* Number badge */
.suffix-step::before {
  content: attr(data-step);
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 26px;
  height: 26px;
  border-radius: 999px;
  display: grid;
  place-items: center;
  font-weight: 600;
  color: var(--heading);
  border: 1px solid var(--accent-2-border);
  background: var(--highlight-strong);
  text-shadow: 0 0 10px rgba(155, 193, 255, 0.25);
}

/* Arrow hint (optional but helps) */
.suffix-step::after {
  content: "→";
  margin-left: 10px;
  opacity: 0.55;
}

/* Last step: no arrow */
.suffix-step.last::after {
  content: "";
}

/* Mobile-friendly wrapping */
@media (max-width: 650px) {
  .suffix-step {
    white-space: normal;
    border-radius: 16px;
    padding: 12px 14px 12px 46px;
  }
}

/* === Numbers converter mini UI === */
.num-converter {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
  margin-top: 10px;
}

.num-field label {
  display: block;
  font-size: 0.95em;
  color: var(--accent-2);
  margin-bottom: 6px;
  letter-spacing: 0.2px;
}

.num-field {
  min-width: 0;
}

.num-field input,
.num-field select,
.num-field textarea {
  width: 100%;
  padding: 12px 12px;
  border-radius: 12px;
  border: 1px solid var(--pill-border);
  background: var(--surface-2);
  color: var(--text);
  outline: none;
  box-sizing: border-box;
}

    .num-field input:focus,
    .num-field select:focus {
      border-color: var(--focus);
      box-shadow: 0 0 18px rgba(155,193,255,0.14);
    }

    /* === QUIZ UI === */
    .quiz-controls {
      display: grid;
      gap: 14px;
      margin-top: 14px;
    }

    .quiz-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .quiz-card {
      text-align: left;
      padding: 18px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: var(--surface);
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px var(--shadow);
    }

    .quiz-card h4 {
      margin: 0 0 10px;
      color: var(--accent);
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .quiz-options {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }

    .quiz-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface-3);
    }

    .quiz-input {
      width: 100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text);
      outline: none;
    }

    .quiz-input:focus {
      border-color: var(--focus);
      box-shadow: 0 0 18px rgba(155,193,255,0.14);
    }

    .quiz-result {
      margin-top: 12px;
      font-weight: 500;
      color: var(--accent-2);
    }

    .quiz-answer {
      margin-top: 8px;
      font-size: 0.95em;
      color: var(--text-muted);
    }

    /* === PERSONALITY TEST === */
    .personality-wrap {
      display: grid;
      gap: 16px;
    }

    .personality-card {
      padding: 18px;
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      background: var(--surface);
    }

    .likert-row {
      display: grid;
      gap: 8px;
      margin-top: 10px;
      grid-template-columns: repeat(7, minmax(0, 1fr));
    }

    .likert-option {
      display: grid;
      gap: 6px;
      align-items: center;
      justify-items: center;
      padding: 8px 6px;
      border-radius: 10px;
      border: 1px solid var(--border-softer);
      background: var(--surface-2);
      font-size: 0.85em;
      color: var(--text-soft);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .likert-option input {
      accent-color: var(--accent-2);
    }

    .likert-option:hover,
    .likert-option:has(input:checked) {
      border-color: var(--accent-2-border);
      background: var(--highlight);
      color: var(--heading);
    }

    .result-block {
      display: grid;
      gap: 10px;
      margin-top: 12px;
      padding: 14px;
      border-radius: 12px;
      background: var(--surface-2);
      border: 1px solid var(--border-soft);
    }

    .result-bar {
      position: relative;
      height: 12px;
      border-radius: 999px;
      background: var(--surface-dark);
      overflow: hidden;
    }

    .result-bar > span {
      position: absolute;
      top: 0;
      bottom: 0;
      background: linear-gradient(90deg, var(--accent-2), var(--accent));
    }

    .result-row {
      display: grid;
      gap: 8px;
    }

    .result-row-header {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.95em;
      color: var(--text-soft);
    }

    .result-pills {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .result-pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--surface-3);
      font-size: 0.85em;
      color: var(--text-soft);
    }

    /* === ANIMAL QUIZ === */
    .animal-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    /* === SPERTZ COOK === */
    .cook-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .cook-list {
      display: grid;
      gap: 8px;
    }

    .cook-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border-soft);
      background: var(--surface-2);
      color: var(--text-soft);
      cursor: pointer;
    }

    .cook-item input {
      accent-color: var(--accent-2);
    }

    .cook-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .cook-book {
      max-height: 260px;
      overflow: auto;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 10px;
      background: var(--surface-2);
    }

    .car-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .car-list {
      display: grid;
      gap: 8px;
      margin-top: 10px;
    }

    .car-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text-soft);
      cursor: pointer;
    }

    .car-item input {
      accent-color: var(--accent-2);
    }

    .car-results {
      display: grid;
      gap: 12px;
      margin-top: 10px;
    }

    .car-score {
      display: grid;
      gap: 8px;
    }

    .car-score-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .car-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: var(--surface-dark);
      overflow: hidden;
    }

    .car-bar span {
      display: block;
      height: 100%;
      background: var(--accent-2);
    }

    .car-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.8em;
      background: rgba(0, 0, 0, 0.06);
      color: var(--text-soft);
    }

    .quest-card {
      display: grid;
      gap: 10px;
    }

    .quest-choices {
      display: grid;
      gap: 10px;
    }

    .quest-choice {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text);
      cursor: pointer;
      text-align: left;
      width: 100%;
    }

    .quest-choice span {
      color: var(--text-soft);
      font-size: 0.95em;
    }

    .quest-meter {
      display: grid;
      gap: 8px;
    }

    .quest-meter-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .quest-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: var(--surface-dark);
      overflow: hidden;
    }

    .quest-bar span {
      display: block;
      height: 100%;
      background: var(--accent);
    }

    .cook-hints {
      max-height: 220px;
      overflow: auto;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 10px;
      background: var(--surface-2);
    }

    .cook-hint-item {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px dashed var(--border-soft);
      background: rgba(255, 255, 255, 0.35);
    }

    .cook-hint-item + .cook-hint-item {
      margin-top: 8px;
    }

    .cook-book-entry {
      border-radius: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border-soft);
      color: #3c2f2a;
    }

    .cook-book-entry b {
      color: #2b1f1b;
    }

    .cook-book-entry span {
      color: #4a3a34;
    }

    .cook-advanced {
      color: #3b2a1a;
    }

    .cook-advanced b {
      color: #2a1a10;
    }

    .cook-book-entry + .cook-book-entry {
      margin-top: 10px;
    }

    .cook-price-1 {
      background: #f3f0ee;
      border-color: #e6ded8;
    }

    .cook-price-2 {
      background: #efeae4;
      border-color: #e1d5cb;
    }

    .cook-price-3 {
      background: #e9efe9;
      border-color: #d3e1d3;
    }

    .cook-price-4 {
      background: #e7eef6;
      border-color: #cbd9ea;
    }

    .cook-price-5 {
      background: #f3e9f2;
      border-color: #e4cfe1;
    }

    .cook-advanced {
      background: linear-gradient(135deg, #fff2d8, #f9e3ff);
      border-color: #e8c57b;
      box-shadow: 0 8px 18px rgba(200, 150, 80, 0.18);
      position: relative;
    }

    .cook-advanced::after {
      content: "ADVANCED";
      position: absolute;
      top: 8px;
      right: 10px;
      font-size: 0.7em;
      letter-spacing: 0.08em;
      color: #9a5c21;
      font-weight: 700;
    }

    .cook-price-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 0.8em;
      background: rgba(0, 0, 0, 0.06);
      color: var(--text-soft);
      margin-left: 6px;
    }

    .cook-coins {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: var(--surface-3);
      color: var(--text-soft);
      font-size: 0.9em;
    }

    /* === SHARE CHARACTER === */
    .share-code {
      width: 100%;
      min-height: 90px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text);
      outline: none;
      resize: vertical;
    }

    .share-code:focus {
      border-color: var(--focus);
      box-shadow: 0 0 18px rgba(155,193,255,0.14);
    }

    /* === PORTRAIT MAKER === */
    .portrait-wrap {
      display: grid;
      gap: 18px;
      margin-top: 10px;
    }

    .portrait-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .portrait-tab {
      border: 1px solid var(--pill-border);
      background: var(--surface-2);
      color: var(--text);
      border-radius: 999px;
      padding: 8px 16px;
      cursor: pointer;
      font-family: "Nunito", "Baloo 2", "Segoe UI", sans-serif;
      font-size: 0.95em;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    .portrait-tab:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(68, 48, 40, 0.12);
    }

    .portrait-tab.active {
      background: var(--surface-1);
      border-color: var(--accent-2);
      color: var(--accent-2);
      font-weight: 700;
    }

    .portrait-stage {
      display: grid;
      gap: 16px;
    }

    .portrait-view {
      display: none;
    }

    .portrait-view.active {
      display: block;
    }

    .portrait-canvas {
      width: 512px;
      height: 512px;
      border-radius: 16px;
      border: 1px solid var(--pill-border);
      background: #ffffff;
      box-shadow: 0 0 24px rgba(155,193,255,0.12);
      image-rendering: pixelated;
    }

    .portrait-illustrated {
      width: 512px;
      height: 512px;
      border-radius: 16px;
      border: 1px solid var(--pill-border);
      background: #ffffff;
      box-shadow: 0 0 24px rgba(155,193,255,0.12);
      position: relative;
      overflow: hidden;
    }

    .portrait-illustrated img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .portrait-illustrated canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    .portrait-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .portrait-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

@media (max-width: 700px) {
  .num-converter {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 980px) {
  header {
    padding: 40px 18px 28px;
  }

  header h1 {
    font-size: 2.2em;
    letter-spacing: 1px;
  }

  .style-picker {
    flex-wrap: wrap;
    justify-content: center;
  }

  nav {
    flex-direction: column;
    align-items: stretch;
    backdrop-filter: none;
  }

  .nav-toggle {
    display: flex;
  }

  .nav-items {
    display: none;
    flex-direction: column;
  }

  nav.nav-open .nav-items {
    display: flex;
  }

  .nav-item {
    border-right: none;
    border-bottom: 1px solid var(--border-soft);
  }

  .nav-link {
    text-align: left;
    padding: 16px 18px;
  }

  .nav-drop {
    width: 52px;
  }

  .nav-menu {
    position: static;
    border-top: none;
    border-bottom: 1px solid var(--border-soft);
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
  }

  .nav-item:hover .nav-menu {
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
    pointer-events: none;
  }

  .nav-item.open .nav-menu {
    max-height: 420px;
    overflow-y: auto;
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .content {
    padding: 36px clamp(16px, 6vw, 32px);
    text-align: left;
    max-width: 100%;
  }

  .info-card,
  .grammar-card,
  .quiz-card,
  .rule-note,
  .example-box {
    padding: 18px;
    width: 100%;
  }

  .archive-table,
  .case-table {
    min-width: 520px;
  }

  .portrait-canvas {
    width: min(92vw, 512px);
    height: auto;
    margin: 0 auto;
    display: block;
    aspect-ratio: 1 / 1;
  }

  .portrait-illustrated {
    width: min(92vw, 512px);
    height: auto;
    margin: 0 auto;
    aspect-ratio: 1 / 1;
  }

  .portrait-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 640px) {
  header h1 {
    font-size: 2em;
  }

  .content p,
  .grammar-card p {
    font-size: 1em;
  }

  .pill,
  .tag-pill,
  .honorific-pill,
  .badge {
    font-size: 0.9em;
  }
}

  </style>
</head>
<body class="stars">
  <header>
    <h1>ARCHIVES OF SPERTZ</h1>
    <div class="style-picker">
      <label for="themeSelect">Style</label>
      <select id="themeSelect">
        <option value="default" selected>Default</option>
        <option value="fantasy">Fantasy</option>
        <option value="dreamy">Dreamy</option>
        <option value="futuristic">Futuristic</option>
        <option value="simple">Simple</option>
        <option value="sunlit">Sunlit</option>
        <option value="linen">Linen</option>
        <option value="handwritten">Handwritten</option>
        <option value="adventure">Adventure</option>
        <option value="star">Star</option>
        <option value="pinky">Pinky</option>
        <option value="icy">Icy</option>
        <option value="classic">Classic</option>
      </select>
    </div>
  </header>

  <nav>
    <button class="nav-toggle" type="button" aria-expanded="false" aria-controls="mainNav">
      <span>Menu</span>
      <span aria-hidden="true">☰</span>
    </button>
    <div class="nav-items" id="mainNav">
    <div class="nav-item">
      <a href="#phonetics" class="nav-link active">Phonetics</a>
      <button class="nav-drop" type="button" aria-haspopup="true" aria-expanded="false">▾</button>
      <div class="nav-menu" aria-label="Phonetics subsections">
        <a href="#phonetics-vowels">Vowel Inventory and Spelling</a>
        <a href="#phonetics-consonants">Consonant Inventory</a>
        <a href="#phonetics-syllable">Syllable Structure</a>
        <a href="#phonetics-rules">Phonological & Spelling Rules</a>
        <a href="#phonetics-ipa">IPA Converter</a>
        <a href="#phonetics-splitter">Syllable Splitter</a>
      </div>
    </div>
    <div class="nav-item">
      <a href="#grammar" class="nav-link">Grammar</a>
      <button class="nav-drop" type="button" aria-haspopup="true" aria-expanded="false">▾</button>
      <div class="nav-menu" aria-label="Grammar subsections">
        <a href="#grammar-typology">Morphological Typology</a>
        <a href="#grammar-inflection">Inflection Formation</a>
        <a href="#grammar-parts">Parts of Speech</a>
        <a href="#grammar-case">Case System</a>
        <a href="#grammar-gender">Gender / Noun Classes</a>
        <a href="#grammar-marking">Additional Marking on Nouns</a>
        <a href="#grammar-person">Person/Number Inflection</a>
        <a href="#grammar-tense">Tense (Inflectional Morphemes)</a>
        <a href="#grammar-verb-lab">Verb Conjugation Lab</a>
        <a href="#grammar-pronouns">Personal Pronouns</a>
        <a href="#grammar-other-pronouns">Other Pronouns</a>
        <a href="#grammar-numbers">Numbers (fiu)</a>
        <a href="#grammar-adjectives">Adjectives</a>
        <a href="#grammar-articles">Articles</a>
        <a href="#grammar-word-order">Sentence Word Order</a>
        <a href="#grammar-yesno">Yes–No Questions</a>
        <a href="#grammar-conjunctions">Conjunctions</a>
        <a href="#grammar-subclauses">Subclauses</a>
      </div>
    </div>
    <div class="nav-item">
      <a href="#quiz" class="nav-link">Quiz</a>
      <button class="nav-drop" type="button" aria-haspopup="true" aria-expanded="false">▾</button>
      <div class="nav-menu" aria-label="Quiz subsections">
        <a href="#quiz">Language Quiz</a>
        <a href="#quiz-animal">Animal Match Quiz</a>
        <a href="#quiz-superpower">Superpower Day</a>
        <a href="#personality">Personality Test</a>
      </div>
    </div>
    <div class="nav-item">
      <a href="#create" class="nav-link">Create</a>
      <button class="nav-drop" type="button" aria-haspopup="true" aria-expanded="false">▾</button>
      <div class="nav-menu" aria-label="Create subsections">
        <a href="#create-archive">Name</a>
        <a href="#create-birthday">Birthday</a>
        <a href="#create-portrait">Portrait Maker</a>
        <a href="#create-share">Share Your Character</a>
        <a href="#create-cook">SPERTZ Cook</a>
        <a href="#create-car">Car Innovation</a>
        <a href="#create-quest">Kopahor Quest</a>
      </div>
    </div>
    <div class="nav-item">
      <a href="#resources" class="nav-link">Extra Resources</a>
      <button class="nav-drop" type="button" aria-haspopup="true" aria-expanded="false">▾</button>
      <div class="nav-menu" aria-label="Resources subsections">
        <a href="#resources-lexicon">Spertz Lexicon (Verbs)</a>
        <a href="#resources-months">Why the Months Have Those Names</a>
        <a href="#resources-bases">Why the West Counts in Base-8 and the South in Base-16</a>
        <a href="#resources-spertz">Why the Language Is Called Spertz</a>
        <a href="#resources-kopahor">A Small Story: The History of Kopahor</a>
        <a href="#resources-faith">A Small Story: The Returning Gods</a>
        <a href="#resources-powers">A Small Story: Superpowers Blend In</a>
        <a href="#resources-league">A Small Story: The Spertz League</a>
        <a href="#resources-life">A Small Story: Everyday Life in the Spertz League</a>
      </div>
    </div>
    </div>
  </nav>

  <div class="content" id="phonetics">
    <h2>Phonetics</h2>
        <div class="phonetics-archive">

      <div class="info-card vowel-card">
        <h3 id="phonetics-vowels">Vowel Inventory and Spelling</h3>

        <div class="subsection">
          <h4>Monophthongs</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>1</td><td>i</td><td>[i]</td><td>“ee” as in <i>see</i></td></tr>
                <tr><td>2</td><td>ei</td><td>[e]</td><td>“ay” as in <i>say</i></td></tr>
                <tr><td>3</td><td>e</td><td>[ɛ]</td><td>“e” as in <i>bed</i></td></tr>
                <tr><td>4</td><td>ae</td><td>[æ]</td><td>“a” as in <i>cat</i></td></tr>
                <tr><td>5</td><td>u</td><td>[u]</td><td>“oo” as in <i>food</i></td></tr>
                <tr><td>6</td><td>oe</td><td>[ʊ]</td><td>“oo” as in <i>foot</i></td></tr>
                <tr><td>7</td><td>o</td><td>[o]</td><td>“o” as in <i>go</i></td></tr>
                <tr><td>8</td><td>a</td><td>[ɑ]</td><td>“a” as in <i>father</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Diphthongs</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>9</td><td>ai</td><td>[ɑi]</td><td>“eye” glide</td></tr>
                <tr><td>10</td><td>iu</td><td>[ju]</td><td>“yoo” as in <i>music</i></td></tr>
                <tr><td>11</td><td>au</td><td>[ɑu]</td><td>“ow” as in <i>cow</i></td></tr>
                <tr><td>12</td><td>ua</td><td>[wɑ]</td><td>“wa” as in <i>water</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Contrastive Length</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>13</td><td>yi</td><td>[iː]</td><td>Long “ee”</td></tr>
                <tr><td>14</td><td>ye</td><td>[ɛː]</td><td>Long “e” as in <i>bed</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Mini Linguistics Lesson</h4>
          <div class="rule-note">
            <p style="margin:0 0 8px;">
              A <b>monophthong</b> is a single, steady vowel sound. A <b>diphthong</b> is a vowel that glides from one vowel quality to another inside one syllable.
            </p>
            <p style="margin:0 0 8px;">
              <b>Contrastive length</b> means vowel duration can change meaning, so short and long vowels are phonemically different.
            </p>
            <p style="margin:0;">
              Word origin: <b>mono-</b> means “one” and <b>di-</b> means “two” in Greek. <b>phthong</b> comes from Greek <i>phthóngos</i>, meaning “sound” or “voice.”
            </p>
          </div>
        </div>
      </div>

      <div class="info-card consonant-card">
        <h3 id="phonetics-consonants">Consonant Inventory</h3>

        <div class="subsection">
          <h4>Stops</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>1</td><td>p</td><td>[p]</td><td>“p” as in <i>spin</i></td></tr>
                <tr><td>2</td><td>b</td><td>[b]</td><td>“b” as in <i>bat</i></td></tr>
                <tr><td>3</td><td>t</td><td>[t]</td><td>“t” as in <i>stop</i></td></tr>
                <tr><td>4</td><td>d</td><td>[d]</td><td>“d” as in <i>dog</i></td></tr>
                <tr><td>5</td><td>k</td><td>[k]</td><td>“k” as in <i>skin</i></td></tr>
                <tr><td>6</td><td>g</td><td>[g]</td><td>“g” as in <i>go</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Affricate</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>7</td><td>ch</td><td>[ʧ]</td><td>“ch” as in <i>chat</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Fricatives</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>8</td><td>f</td><td>[f]</td><td>“f” as in <i>fan</i></td></tr>
                <tr><td>9</td><td>v</td><td>[v]</td><td>“v” as in <i>van</i></td></tr>
                <tr><td>10</td><td>s</td><td>[s]</td><td>“s” as in <i>see</i></td></tr>
                <tr><td>11</td><td>z</td><td>[z]</td><td>“z” as in <i>zoo</i></td></tr>
                <tr><td>12</td><td>sh</td><td>[ʃ]</td><td>“sh” as in <i>shoe</i></td></tr>
                <tr><td>13</td><td>h</td><td>[h]</td><td>“h” as in <i>hat</i></td></tr>
                <tr><td>14</td><td>x</td><td>[ks]</td><td>“x” as in <i>box</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Nasals</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>15</td><td>m</td><td>[m]</td><td>“m” as in <i>man</i></td></tr>
                <tr><td>16</td><td>n</td><td>[n]</td><td>“n” as in <i>net</i></td></tr>
                <tr><td>17</td><td>ng</td><td>[ŋ]</td><td>“ng” as in <i>sing</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Liquids</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>18</td><td>r</td><td>[ɹ]</td><td>English “r” as in <i>red</i></td></tr>
                <tr><td>19</td><td>l</td><td>[l]</td><td>“l” as in <i>lip</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Glides</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>20</td><td>w</td><td>[w]</td><td>“w” as in <i>we</i></td></tr>
                <tr><td>21</td><td>y</td><td>[j]</td><td>“y” as in <i>yes</i></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Click</h4>
          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Spelling</th>
                  <th>IPA</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>22</td><td>||</td><td>[ǁ]</td><td>Alveolar lateral click</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Mini Linguistics Lesson</h4>
          <div class="rule-note">
            <p style="margin:0 0 8px;">
              Consonants are commonly described by <b>manner of articulation</b> (how airflow is shaped) and <b>place of articulation</b> (where in the mouth or throat it happens).
            </p>
            <p style="margin:0 0 8px;">
              <b>Manner:</b> Stops fully block then release air (p, t, k). Fricatives create turbulent friction (f, s, sh). Affricates combine a stop plus fricative release (ch). Nasals send air through the nose (m, n, ng). Liquids and glides are more open, vowel-like consonants (r, l, w, y).
            </p>
            <p style="margin:0 0 8px;">
              <b>Place:</b> Bilabial at the lips (p, b, m). Labiodental with lip + teeth (f, v). Alveolar at the ridge behind the teeth (t, d, n, s, z, l). Postalveolar just behind that ridge (sh, ch). Velar at the soft palate (k, g, ng). Glottal at the vocal folds (h). The click symbol here is <b>alveolar lateral</b>, made with tongue contact near the alveolar region and side release.
            </p>
            <p style="margin:0;">
              Note: <b>x</b> is written as [ks], so it functions as a consonant cluster in pronunciation rather than one simple consonant sound.
            </p>
          </div>
        </div>
      </div>

      <div class="info-card">
        <h3 id="phonetics-syllable">Syllable Structure</h3>
          <p class="mini-note">C = consonant, V = vowel</p>

          <div class="syllable-grid">
            <span class="pill">V</span>
            <span class="pill">CV</span>
            <span class="pill">VC</span>
            <span class="pill">CCV</span>
            <span class="pill">CVC</span>
            <span class="pill">VCC</span>
            <span class="pill">CCCV</span>
            <span class="pill">CCVC</span>
            <span class="pill">CVCC</span>
            <span class="pill">VCCC</span>
            <span class="pill">CCCVC</span>
            <span class="pill">CCVCC</span>
            <span class="pill">CVCCC</span>
          </div>

          <div class="rule-note" style="margin-top: 12px;">
            <p style="margin:0;">
              <b>Consonant order rules:</b>
            </p>
            <p style="margin: 8px 0 0;">
              <b>Onset (before the vowel):</b> Stops → Affricates/Fricatives → Nasals → Liquids<br>
              <b>Coda (after the vowel):</b> Liquids → Nasals → Affricates/Fricatives → Stops
            </p>
            <p style="margin: 8px 0 0;">
              <b>No two consonants of the same class</b> may appear next to each other within a cluster.
            </p>
            <p style="margin: 8px 0 0;">
              Consonant classes:
              Stops (p b t d k g), Affricate (ch), Fricatives (f v s z sh h),
              Nasals (m n ng), Liquids (r l).
            </p>
            <p style="margin: 8px 0 0;">
              <b>Additional rule:</b> <b>ng</b> is not allowed in onset position; it can appear only in coda position.
            </p>
            <p style="margin: 8px 0 0;">
              This order follows a common sonority-style shape. <b>Sonority</b> is how loud/open a speech sound is relative to others in a syllable. In onsets, sounds move from tighter constriction toward more open consonants as they approach the vowel; in codas, they move away from the vowel in reverse. This tends to be easier to pronounce, easier to hear, and more stable over time in natural languages.
            </p>
          </div>
        </div>

        <div class="info-card">
          <h3 id="phonetics-rules">Phonological & Spelling Rules</h3>

          <div class="accordion">

            <button class="accordion-btn" type="button">
              <span>Rule 1: [iV] sequencing</span>
              <span class="acc-icon">+</span>
            </button>
            <div class="accordion-panel">
              <p>
                Sequences of <b>[iV]</b> are treated as <b>two separate syllables</b>,
                except for <b>[iu]</b>, which is a diphthong and therefore <b>one syllable</b>.
              </p>
            </div>

            <button class="accordion-btn" type="button">
              <span>Rule 2: [ks] spelling</span>
              <span class="acc-icon">+</span>
            </button>
            <div class="accordion-panel">
              <p>
                <b>[ks]</b> is represented by <b>&lt;x&gt;</b> when it’s at the <b>beginning</b>
                of a word with a <b>positive/liking meaning</b>. Otherwise, <b>[ks]</b> is spelled
                <b>&lt;ks&gt;</b>.
              </p>
            </div>

            <button class="accordion-btn" type="button">
              <span>Rule 3: &lt;c&gt; pronunciation</span>
              <span class="acc-icon">+</span>
            </button>
            <div class="accordion-panel">
              <p>
                <b>&lt;c&gt;</b> before the vowel <b>[i]</b> is pronounced <b>[s]</b>.
                Everywhere else, it is pronounced <b>[k]</b>.
              </p>
            </div>

            <button class="accordion-btn" type="button">
              <span>Rule 4: “y” behavior</span>
              <span class="acc-icon">+</span>
            </button>
            <div class="accordion-panel">
              <p>
                When <b>y</b> appears as part of fixed vowel spellings (e.g., <b>yi</b>, <b>ye</b>),
                it belongs to the vowel. Otherwise, <b>y</b> represents the glide <b>[j]</b>.
              </p>
            </div>

          </div>
        </div>

        <div class="info-card">
          <h3 id="phonetics-ipa">IPA Converter (Try it)</h3>

          <div class="rule-note" style="margin-bottom: 12px;">
            <p style="margin:0;">
              Stress is placed on the penultimate vowel in Spertz. Penultimate vowel means the vowel in the second-to-last syllable of a word. Many languages also favor penultimate stress, such as Polish (in most words), Swahili, and Quechua varieties.
            </p>
          </div>

          <div class="num-converter">
            <div class="num-field">
              <label for="ipaInput">Word (Spertz spelling)</label>
              <input id="ipaInput" type="text" placeholder="e.g., krei" />
            </div>

            <div class="num-field">
              <label for="ipaOutput">IPA output</label>
              <div id="ipaOutput"
                  style="padding: 12px 12px; border-radius: 12px; border: 1px solid var(--pill-border);
                          background: var(--surface-2); color: var(--text); min-height: 20px;
                          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
                —
              </div>
            </div>
          </div>

          <div class="rule-note" style="margin-top: 14px;">
            <p style="margin:0;">
              <b>Status:</b>
              <span id="ipaStatus">Waiting for input…</span>
            </p>
          </div>
        </div>

        <div class="info-card">
          <h3 id="phonetics-splitter">Syllable Splitter</h3>

          <p class="mini-note">
            Type a Spertz word to split into syllables with dots.
          </p>

          <div class="num-converter">
            <div class="num-field">
              <label for="splitInput">Word (Spertz spelling)</label>
              <input id="splitInput" type="text" placeholder="e.g., krei" />
            </div>

            <div class="num-field">
              <label for="splitOutput">Syllable split</label>
              <div id="splitOutput"
                  style="padding: 12px 12px; border-radius: 12px; border: 1px solid var(--pill-border);
                          background: var(--surface-2); color: var(--text); min-height: 20px;
                          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
                —
              </div>
            </div>
          </div>

          <div class="rule-note" style="margin-top: 14px;">
            <p style="margin:0;">
              <b>Status:</b>
              <span id="splitStatus">Waiting for input…</span>
            </p>
          </div>
        </div>

      </div>
  </div>

  <div class="content" id="grammar">
    <h2>Grammar</h2>

    <div class="grammar-archive">

      <div class="grammar-card">
        <h3 id="grammar-typology">Morphological Typology</h3>
        <p>
          Spertz is primarily agglutinative. Words are typically built from a root followed by a sequence of suffixes and/or prefixes, where each affix expresses one distinct grammatical function. Affix boundaries remain clear and segmentable, and grammatical information is generally added in a linear, step-by-step manner (root + affix1 + affix2 + affix3 …). Most morphemes carry a single meaning or role rather than combining multiple functions into one form.
        </p>
        <div class="rule-note" style="margin-top: 12px;">
          <p style="margin:0 0 8px;">
            <b>Agglutinative</b> means words are built by stacking clear affixes, and each affix usually has one job.
          </p>
          <p style="margin:0;">
            Other common morphological types: <b>isolating</b> (very little affixation, grammar mostly by separate words), <b>fusional</b> (one affix can encode several meanings at once), and <b>polysynthetic</b> (many morphemes can combine into one very information-dense word).
          </p>
        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-inflection">Inflection Formation</h3>
        <p>
          Inflection is formed primarily through suffixation, with grammatical information most commonly added at the end of a root. Prefixation is also used as a secondary strategy for certain categories, placing specific grammatical markers before the root. These affixes remain clearly segmentable and typically carry a single grammatical function each.
        </p>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-parts">Parts of Speech (Nouns, Verbs, Adjectives)</h3>
        <p>
          Spertz has distinct and strictly separated lexical categories: nouns, verbs, and adjectives. Related words across different categories often share the same underlying root, but are differentiated by small category-specific suffixes. These suffix differences are not fully regular or predictable.
        </p>

        <div class="grammar-divider"></div>

        <div class="grammar-highlight">
          <p class="grammar-highlight-title">Category endings are constrained phonologically:</p>

          <ul class="grammar-list">
            <li><b>Verbs (with no conjugation)</b> must end in a vowel. No restrictions with conjugation.</li>
            <li><b>Nouns</b> must end in a consonant.</li>
            <li><b>Adjectives</b> must end in a vowel.</li>
          </ul>

          <div class="tag-grid">
            <span class="tag-pill">Verbs → vowel</span>
            <span class="tag-pill">Nouns → consonant</span>
            <span class="tag-pill">Adjectives → vowel</span>
          </div>
        </div>

        <div class="grammar-divider"></div>

        <div class="grammar-highlight">
          <p class="grammar-highlight-title">Adjective agreement (final-letter matching):</p>

          <p>
            When an adjective modifies a noun, the adjective takes the final consonant letter of the noun (if genitive, disregard the e and use the last consonant letter of the noun). If the noun’s final letter is already the adjective’s second-to-last letter, then the adjective instead drops its final vowel rather than adding an extra letter.
          </p>

          <div class="example-box">
            <p>
              <b>Example:</b> noun XXXM, adjective XXMA → modifying form XXM (final vowel removed).
            </p>
          </div>
        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-case">Case System</h3>

        <p>
          Spertz uses a case system primarily marked by suffixes, but case marking is mostly a written-language disambiguation tool. In everyday speech, these affixes can be optionally omitted as long as the meaning remains clear.
        </p>

        <div class="table-wrap">
          <table class="case-table">
            <thead>
              <tr>
                  <th>Case</th>
                  <th>Function</th>
                  <th>Marking Strategy</th>
                  <th>Marker</th>
              </tr>
            </thead>
            <tbody>
                <tr>
                  <td><b>Nominative</b></td>
                  <td>Subject</td>
                  <td>Unmarked (no additional morphology)</td>
                  <td><span class="badge">∅ (none)</span></td>
                </tr>

                <tr>
                  <td><b>Accusative</b></td>
                  <td>Direct Object</td>
                  <td>The direct object is marked on the verb as the second suffix (after subject agreement) in a verb.</td>
                  <td><span class="badge"><code>-ta</code></span></td>
                </tr>

                <tr>
                  <td><b>Genitive</b></td>
                  <td>Possessive</td>
                  <td>The genitive is formed by attaching a noun suffix:</td>
                  <td><span class="badge"><code>-e</code> (pronounced [ɛ])</span></td>
                </tr>

                <tr>
                  <td><b>Dative</b></td>
                  <td>Indirect Object / Recipient</td>
                  <td>
                    The recipient (“to/for someone”) is expressed with a verbal prefix.
                    It is written with a dash and treated as a separate syllable. The recipient must be stated immediately after the verb.
                  </td>
                  <td><span class="badge"><code>k-</code></span></td>
                </tr>

                <tr>
                  <td><b>Ablative / Source</b></td>
                  <td>“from where”</td>
                  <td>
                    Source/origin is expressed as a separate phrase after the verb, linked by a preposition (not agglutinated onto the verb).
                  </td>
                  <td><span class="badge">separate phrase</span></td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="rule-note">
            <p>
              If both dative and source are present, the order is:
            </p>
            <p>
              <b>Recipient first, Source second.</b><br>
              If there is no dative, the source phrase comes first after the verb.
            </p>
          </div>
      </div>

      <div class="grammar-card">
          <h3 id="grammar-gender">Gender / Noun Classes</h3>
          <p>
            Nouns in Spertz do not have grammatical gender or noun classes. However, third-person pronouns are distinguished by gender/class.
          </p>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-marking">Additional Marking on Nouns</h3>

        <p>
          In addition to case, nouns may carry several other grammatical and pragmatic markers.
        </p>

        <div class="marker-grid">

          <div class="marker-row">
            <h4>Plurality</h4>
            <p>
              Plural nouns are formed by adding a dedicated suffix:
              <span class="inline-code">-an</span>: the plural suffix.
            </p>
          </div>

          <div class="marker-row">
            <h4>Honorifics</h4>
            <p>
              Honorifics exist and are expressed as ranked titles added after a pronoun:
            </p>

            <div class="honorific-grid">
              <span class="honorific-pill"><code>sa</code> polite / general respectful address</span>
              <span class="honorific-pill"><code>fa</code> noble young master</span>
              <span class="honorific-pill"><code>ra</code> noble young lady</span>
              <span class="honorific-pill"><code>x</code> royal family member</span>
            </div>
          </div>

          <div class="marker-row">
            <h4>Topic marking</h4>
            <p>
              Topic is expressed by an independent word placed before the noun. It does not attach to the noun morphologically.
            </p>

            <div class="rule-note" style="margin-top: 12px;">
              <p>
                Topic marker: <span class="inline-code">zo</span> (pronounced [zo])
              </p>
            </div>
          </div>

          <div class="marker-row">
            <h4>Possession</h4>
            <p>
              Possession is marked with the genitive noun suffix <span class="inline-code">-e</span> (pronounced [ɛ]).
            </p>
          </div>

          <div class="marker-row">
            <h4>Diminutive / Augmentative</h4>

            <p>
              Diminutive and augmentative meaning is expressed with noun-final suffixes:
            </p>

            <div class="tag-grid" style="margin-top: 10px;">
              <span class="tag-pill">Diminutive: <span class="inline-code">-ias</span></span>
              <span class="tag-pill">Augmentative: <span class="inline-code">-og</span></span>
            </div>

            <div class="rule-note">
              <p>
                When attached after a pronoun, if the preceding letter is a vowel, the forms become
                <span class="inline-code">-lias</span> and <span class="inline-code">-rog</span> respectively (to avoid vowel collision).
              </p>

              <div class="example-box">
                <p>
                  <b>Example:</b> Sieralias = “she-pronoun + honorific + diminutive tone” addressing a noble young lady in a cute/affectionate way.
                </p>
              </div>
            </div>
        </div>
      </div>

      </div>
      <div class="grammar-card">
        <h3 id="grammar-person">Person/Number Inflection on Verbs</h3>

        <p>
          Verbs can inflect for person and number, but this system is used primarily in writing to reduce ambiguity. In everyday spoken usage, these agreement endings may be omitted if the meaning remains clear. Agreement is expressed through suffixes marking the subject.
        </p>

        <div class="subsection">
          <h4>Present Tense Subject Agreement (Written)</h4>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Person/Number</th>
                  <th>Suffix</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>1st person singular</td><td><span class="pill">-t</span></td></tr>
                <tr><td>1st person plural</td><td><span class="pill">-wen</span></td></tr>
                <tr><td>2nd person singular</td><td><span class="pill">-ya</span></td></tr>
                <tr><td>2nd person plural</td><td><span class="pill">-yen</span></td></tr>
                <tr><td>3rd person singular</td><td><span class="pill">-se</span></td></tr>
                <tr><td>3rd person plural</td><td><span class="pill">-ten</span></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Direct Object Marking</h4>

          <p class="mini-note">
            In written verb morphology, a direct object marker -ta is always present when a direct object is present, regardless of whether the object is human or non-human. If the direct object is a person, an additional suffix is added after -ta:
          </p>

          <div class="syllable-grid">
            <span class="pill">-sa for a human direct object</span>
            <span class="pill">-x for a royal direct object</span>
          </div>

          <div class="rule-note">
            <p>
              <b>Overall structure:</b><br>
              verb + subject suffix + ta + (sa/x if human)
            </p>
          </div>

          <div class="example-box">
            <p>
              <b>Example (subject = “I”, verb = krei “to do/make”, direct object = a person):</b><br>
              Wio kreittasa.<br>
              (= krei + -t + -ta + -sa)
            </p>
            <p style="margin-top: 12px;">
              <b>Royal direct object:</b><br>
              Wio kreittax.<br>
              (= krei + -t + -ta + -x)
            </p>
          </div>

        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-tense">Tense (Inflectional Morphemes)</h3>

        <p>
          Verbs mark tense morphologically in writing.
        </p>

        <div class="subsection">
          <h4>Tense</h4>

          <div class="syllable-grid">
            <span class="pill">Future tense: i- (prefix, written with a dash)</span>
            <span class="pill">Past tense: -et (suffix, written without a dash)</span>
          </div>
        </div>

        <div class="subsection">
          <h4>Aspect</h4>

          <p class="mini-note">
            Aspect is marked with dedicated suffixes. Spertz distinguishes four aspects:
          </p>

          <div class="syllable-grid">
            <span class="pill">Progressive (ongoing): -ok</span>
            <span class="pill">Perfect/Completed: -im</span>
            <span class="pill">Habitual: -ul</span>
            <span class="pill">Iterative/Repetitive: -en</span>
          </div>
        </div>

        <div class="subsection">
          <h4>Mood</h4>

          <p class="mini-note">
            Mood is expressed by suffixes in writing:
          </p>

          <div class="syllable-grid">
            <span class="pill">Declarative / Indicative: -or</span>
            <span class="pill">Optative + Subjunctive: -el</span>
          </div>
        </div>

        <div class="subsection">
          <h4>Negation</h4>

          <p class="mini-note">
            Negation is expressed with an independent negation word placed before the verb:
          </p>

          <div class="rule-note">
            <p>
              <b>Negation word:</b> mi
            </p>
          </div>

      <div class="subsection">
        <h4>Evidentiality</h4>

        <p>
          Evidentiality is encoded through the mood system:
        </p>

        <div class="syllable-grid">
          <span class="pill">Direct/witnessed information: Declarative mood</span>
          <span class="pill">Hearsay / inferred / guessed information: Subjunctive (optative-subjunctive) mood</span>
        </div>
      </div>

      <div class="subsection">
        <h4>Transitivity / Reflexive</h4>

        <p>
          Transitivity follows the existing direct object marking system.
        </p>

        <div class="rule-note">
          <p>
            Reflexive meaning is marked by changing the direct object marker:
          </p>
          <div class="syllable-grid" style="margin-top: 10px;">
            <span class="pill">ta → te (reflexive)</span>
          </div>
        </div>
      </div>

      <div class="subsection">
        <h4>Static vs. Dynamic</h4>

        <p>
          Static is the default (unmarked).
          Dynamic is marked by adding a final suffix:
        </p>

        <div class="syllable-grid">
          <span class="pill">Dynamic: -og (added at the very end)</span>
        </div>

        <div class="rule-note">
          <p>
            -og is historically a single intensifying morpheme that extended into both nominal augmentative and verbal dynamic usage.
          </p>
        </div>
      </div>

      <div class="subsection">
        <h4>Full Verb Suffix Order</h4>

        <p>
          The general order of verbal morphology is:
        </p>

        <div class="rule-note">
          <div class="suffix-order">
            <span class="suffix-step" data-step="1">Subject agreement</span>
            <span class="suffix-step" data-step="2">Direct object marker (ta / te)</span>
            <span class="suffix-step" data-step="3">If the direct object is human: sa / x</span>
            <span class="suffix-step" data-step="4">Tense</span>
            <span class="suffix-step" data-step="5">Aspect</span>
            <span class="suffix-step" data-step="6">Mood</span>
            <span class="suffix-step last" data-step="7">Dynamic marker (og)</span>
          </div>
        </div>

        <div class="subsection">
          <h4>Optional Emotional Marking</h4>

          <p class="mini-note">
            In writing, any negative emotional coloring can optionally be marked by adding a final dash at the end of the verb form. This does not change pronunciation and is not mandatory.
          </p>
        </div>

        <div class="example-box">
          <p>
            <b>Example:</b><br>
            Wio i-kreittaenelog-<br>
            Meaning: (With sad emotion) In the future, I might be making something (not clarified what, but not human) many times.
          </p>

          <div class="grammar-divider"></div>

          <p>
            krei = “to make”<br>
            -t = 1st person singular subject agreement<br>
            → kreit<br>
            -ta = direct object marker<br>
            → kreitta<br>
            i- = future tense prefix (with dash)<br>
            → i-kreittasa<br>
            -en = iterative/repetitive aspect<br>
            → i-kreittasaen<br>
            -el = optative/subjunctive mood<br>
            → i-kreittasaenel<br>
            -og = dynamic marker<br>
            → i-kreittasaenelog<br>
            final dash “-” = optional negative emotion marker<br>
            → i-kreittasaenelog-
          </p>
        </div>
      </div>
      </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-verb-lab">Verb Conjugation Lab (Try it)</h3>

        <p class="mini-note">
          Select a verb and morphological options. The system will generate the written verb form, IPA (stress = penultimate vowel), and a rough English gloss.
        </p>

        <div class="info-card" style="margin-top: 14px;">
          <div class="num-converter">
            <div class="num-field">
              <label for="verbSelect">Verb (Spertz)</label>
              <select id="verbSelect"></select>
            </div>

            <div class="num-field">
              <label for="verbMeaning">Meaning (English)</label>
              <div id="verbMeaning"
                  style="padding: 12px 12px; border-radius: 12px; border: 1px solid var(--pill-border);
                          background: var(--surface-2); color: var(--text);">
                —
              </div>
            </div>
          </div>

          <div class="grammar-divider"></div>

          <div class="num-converter">
            <div class="num-field">
              <label for="subjAgree">Subject agreement</label>
              <select id="subjAgree">
                <option value="omit" selected>(omit / unknown)</option>
                <option value="1sg">1st person singular: -t</option>
                <option value="1pl">1st person plural: -wen</option>
                <option value="2sg">2nd person singular: -ya</option>
                <option value="2pl">2nd person plural: -yen</option>
                <option value="3sg">3rd person singular: -se</option>
                <option value="3pl">3rd person plural: -ten</option>
              </select>
            </div>

            <div class="num-field">
              <label for="objMarker">Direct object marker</label>
              <select id="objMarker">
                <option value="none" selected>(none)</option>
                <option value="ta">ta (direct object)</option>
                <option value="te">te (reflexive)</option>
              </select>
            </div>
          </div>

          <div class="num-converter">
            <div class="num-field">
              <label for="humanObj">If the direct object is human</label>
              <select id="humanObj">
                <option value="none" selected>(none)</option>
                <option value="sa">sa (human direct object)</option>
                <option value="x">x (royal direct object)</option>
              </select>
            </div>

            <div class="num-field">
              <label for="tenseSel">Tense</label>
              <select id="tenseSel">
                <option value="none" selected>(none)</option>
                <option value="future">Future: i- (prefix)</option>
                <option value="past">Past: -et (suffix)</option>
              </select>
            </div>
          </div>

          <div class="num-converter">
            <div class="num-field">
              <label for="aspectSel">Aspect</label>
              <select id="aspectSel">
                <option value="none" selected>(none)</option>
                <option value="ok">Progressive: -ok</option>
                <option value="im">Perfect/Completed: -im</option>
                <option value="ul">Habitual: -ul</option>
                <option value="en">Iterative/Repetitive: -en</option>
              </select>
            </div>

            <div class="num-field">
              <label for="moodSel">Mood</label>
              <select id="moodSel">
                <option value="none" selected>(none)</option>
                <option value="or">Declarative / Indicative: -or</option>
                <option value="el">Optative + Subjunctive: -el</option>
              </select>
            </div>
          </div>

          <div class="num-converter">
            <div class="num-field">
              <label for="dynSel">Dynamic marker</label>
              <select id="dynSel">
                <option value="none" selected>(none)</option>
                <option value="og">Dynamic: -og</option>
              </select>
            </div>

            <div class="num-field">
              <label for="previewOut">Generated form</label>
              <div id="previewOut"
                  style="padding: 12px 12px; border-radius: 12px; border: 1px solid var(--pill-border);
                          background: var(--surface-2); color: var(--text); min-height: 20px;
                          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
                —
              </div>
            </div>
          </div>

          <div class="rule-note" style="margin-top: 14px;">
            <p style="margin:0;">
              <b>IPA:</b>
              <span id="ipaOutVerb"
                    style="display:block; margin-top: 8px;
                          font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
                —
              </span>
            </p>
          </div>

          <div class="rule-note" style="margin-top: 12px;">
            <p style="margin:0;">
              <b>Rough English gloss:</b>
              <span id="glossOut" style="display:block; margin-top: 8px;">
                —
              </span>
            </p>
          </div>

          <div class="rule-note" style="margin-top: 12px;">
            <p style="margin:0;">
              <b>Status:</b> <span id="verbLabStatus">Ready.</span>
            </p>
          </div>
        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-pronouns">Personal Pronouns</h3>

        <p>
          Personal pronouns distinguish person (1st/2nd/3rd) and number (singular/plural). Third-person pronouns additionally have multiple forms (used for gender/class distinctions), which can trigger written verb agreement.
        </p>

        <div class="subsection">
          <h4>Pronoun Table</h4>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Person</th>
                  <th>Singular</th>
                  <th>Plural</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>1st person</b></td>
                  <td>Wio</td>
                  <td>Wol</td>
                </tr>
                <tr>
                  <td><b>2nd person</b></td>
                  <td>Nye</td>
                  <td>Nyeya</td>
                </tr>
                <tr>
                  <td><b>3rd person</b></td>
                  <td>Sperte / Sie / Tatie</td>
                  <td>Spiten / Tatien</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Notes</h4>

          <div class="rule-note">
            <p>
              Nouns themselves do not carry grammatical gender/class, but third-person pronouns do, and these distinctions mainly matter in written verb agreement.
            </p>
          </div>

          <div class="rule-note">
            <p>
              Honorific titles may be added after a pronoun (e.g., sa, fa, ra, x) depending on social rank.
            </p>
          </div>
        </div>

        <div class="subsection">
          <h4>Third-person pronoun classes (notes)</h4>

          <p class="mini-note">
            Third-person pronouns encode animacy and gender/class distinctions:
          </p>

          <div class="syllable-grid">
            <span class="pill"><b>Sperte:</b> any living male referent (including animals)</span>
            <span class="pill"><b>Sie:</b> any living female referent (including animals)</span>
            <span class="pill"><b>Tatie:</b> living with no/unknown gender, or non-living referents</span>
            <span class="pill"><b>Spite</b> (used later in discourse): non-binary people or referents with fluid/variable gender identity (e.g., androgynous or transitional)</span>
          </div>
        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-other-pronouns">Other Pronouns (Non-personal Pronouns)</h3>

        <div class="subsection">
          <h4>Interrogatives</h4>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Form</th>
                  <th>Meaning</th>
                </tr>
              </thead>
              <tbody>
                <tr><td><b>beyikaol</b></td><td>“why”</td></tr>
                <tr><td><b>damir</b></td><td>“how long”</td></tr>
                <tr><td><b>ekul</b></td><td>“which”</td></tr>
                <tr><td><b>furol / yekar</b></td><td>“how”</td></tr>
                <tr><td><b>kynar</b></td><td>“who”</td></tr>
                <tr><td><b>luntek</b></td><td>“when”</td></tr>
                <tr><td><b>orfek</b></td><td>“which kind / what type”</td></tr>
                <tr><td><b>rinekas</b></td><td>“Is this possible?”</td></tr>
                <tr><td><b>trinek</b></td><td>“how many / how much (amount)”</td></tr>
                <tr><td><b>utrez</b></td><td>“or”</td></tr>
                <tr><td><b>wasmen</b></td><td>“what”</td></tr>
                <tr><td><b>zequk</b></td><td>“is it (…)? / is that so?”</td></tr>
                <tr><td><b>zoreil</b></td><td>“where”</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Correlative System (this/that/some/no/every)</h4>

          <p class="mini-note">
            In addition to interrogatives, Spertz forms non-personal pronouns using a regular correlative pattern built on shared semantic roots:
          </p>

          <div class="rule-note">
            <p><b>Prefixes</b></p>
            <div class="syllable-grid" style="margin-top: 10px;">
              <span class="pill">ti- = “this”</span>
              <span class="pill">ta- = “that”</span>
              <span class="pill">so- = “some-”</span>
              <span class="pill">mi- = “no- / none”</span>
              <span class="pill">ve- = “every- / all”</span>
            </div>
          </div>

          <div class="rule-note">
            <p><b>Roots</b></p>
            <div class="syllable-grid" style="margin-top: 10px;">
              <span class="pill">-nar = person</span>
              <span class="pill">-men = thing</span>
              <span class="pill">-reil = place</span>
              <span class="pill">-tek = time</span>
              <span class="pill">-rol = way/manner</span>
              <span class="pill">-kaol = reason</span>
              <span class="pill">-fek = kind/type</span>
              <span class="pill">-nek = quantity/amount</span>
              <span class="pill">-mir = duration/length of time</span>
            </div>
          </div>

          <div class="subsection">
            <h4>Forms</h4>

            <div class="table-wrap">
              <table class="archive-table">
                <thead>
                  <tr>
                    <th>Category</th>
                    <th>ti- (this)</th>
                    <th>ta- (that)</th>
                    <th>so- (some)</th>
                    <th>mi- (no/none)</th>
                    <th>ve- (every/all)</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><b>Person</b></td>
                    <td>tinar (this person)</td>
                    <td>tanar (that person)</td>
                    <td>sonar (someone)</td>
                    <td>minar (no one)</td>
                    <td>venar (everyone)</td>
                  </tr>
                  <tr>
                    <td><b>Thing</b></td>
                    <td>timen (this thing)</td>
                    <td>tamen (that thing)</td>
                    <td>somen (something)</td>
                    <td>mimen (nothing)</td>
                    <td>vemen (everything)</td>
                  </tr>
                  <tr>
                    <td><b>Place</b></td>
                    <td>tireil (here/this place)</td>
                    <td>tareil (there/that place)</td>
                    <td>soreil (somewhere)</td>
                    <td>mireil (nowhere)</td>
                    <td>vereil (everywhere)</td>
                  </tr>
                  <tr>
                    <td><b>Time</b></td>
                    <td>titek (now/this time)</td>
                    <td>tatek (then/that time)</td>
                    <td>sotek (sometime)</td>
                    <td>mitek (never)</td>
                    <td>vetek (always)</td>
                  </tr>
                  <tr>
                    <td><b>Way</b></td>
                    <td>tirol (this way/thus)</td>
                    <td>tarol (that way)</td>
                    <td>sorol (somehow)</td>
                    <td>mirol (no way)</td>
                    <td>verol (every way)</td>
                  </tr>
                  <tr>
                    <td><b>Reason</b></td>
                    <td>tikaol (this reason)</td>
                    <td>takaol (that reason)</td>
                    <td>sokaol (for some reason)</td>
                    <td>mikaol (for no reason)</td>
                    <td>vekaol (for every reason)</td>
                  </tr>
                  <tr>
                    <td><b>Kind/type</b></td>
                    <td>tifek (this kind)</td>
                    <td>tafek (that kind)</td>
                    <td>sofek (some kind)</td>
                    <td>mifek (no kind)</td>
                    <td>vefek (every kind)</td>
                  </tr>
                  <tr>
                    <td><b>Quantity/amount</b></td>
                    <td>tinek (this many/this much)</td>
                    <td>tanek (that many/that much)</td>
                    <td>sonek (some amount)</td>
                    <td>minek (none)</td>
                    <td>venek (every amount)</td>
                  </tr>
                  <tr>
                    <td><b>Duration</b></td>
                    <td>timir (this long)</td>
                    <td>tamir (that long)</td>
                    <td>somir (some length of time)</td>
                    <td>mimir (no time at all)</td>
                    <td>vemir (all the time)</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

        </div>

        <div class="subsection">
          <h4>Negation</h4>

          <div class="rule-note">
            <p>
              Negation is expressed with the particle <b>mi</b>, placed before verbs or nouns. The mechanism is identical across categories (no separate negative pronoun forms are required).
            </p>
          </div>
        </div>

      </div>

      <div class="grammar-card">
        <h3 id="grammar-numbers">Numbers</h3>

        <div class="subsection">
          <h4>Core digit roots</h4>
          <p class="mini-note">
            Spertz has basic digit roots for counting, and number words are formed by concatenation. Numbers do not take any nominal suffixes.
          </p>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Digit</th>
                  <th>Word</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>0</td><td><b>zu</b></td></tr>
                <tr><td>1</td><td><b>ta</b></td></tr>
                <tr><td>2</td><td><b>re</b></td></tr>
                <tr><td>3</td><td><b>ki</b></td></tr>
                <tr><td>4</td><td><b>vo</b></td></tr>
                <tr><td>5</td><td><b>me</b></td></tr>
                <tr><td>6</td><td><b>dal</b></td></tr>
                <tr><td>7</td><td><b>zai</b></td></tr>
                <tr><td>8</td><td><b>fiu</b></td></tr>
                <tr><td>9</td><td><b>no</b></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="subsection">
          <h4>Standard (International) System: Base-10</h4>

          <p class="mini-note">
            Base-10 is commonly used for international communication and standard writing.
          </p>

          <div class="rule-note">
            <p><b>Formation examples:</b></p>
            <p style="margin: 8px 0 0;">
              10 = tazu (1+0)<br>
              20 = retazu (2×(1+0))<br>
              100 = rezu (10²)<br>
              123 = tarezu-retazu-ki (100 + 20 + 3)<br>
              3045 = kikizu-votazu-me (3000 + 40 + 5)
            </p>
            <p style="margin: 10px 0 0;">
              Numbers are written as chained components, and hyphens may be used for clarity in long forms.
            </p>
          </div>
        </div>

        <div class="subsection">
          <h4>Western System: Base-8</h4>
          <p class="mini-note">
            In the western region, base-8 counting is common. In this system, the digits 8 (fiu) and 9 (no) are not used as independent digits.
          </p>
        </div>

        <div class="subsection">
          <h4>Southern System: Base-16</h4>
          <p class="mini-note">
            In the southern region, base-16 counting is preferred. The southern digit sequence is:
          </p>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Value</th>
                  <th>Word</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>0</td><td><b>zu</b></td></tr>
                <tr><td>1</td><td><b>ta</b></td></tr>
                <tr><td>2</td><td><b>re</b></td></tr>
                <tr><td>3</td><td><b>ki</b></td></tr>
                <tr><td>4</td><td><b>vo</b></td></tr>
                <tr><td>5</td><td><b>me</b></td></tr>
                <tr><td>6</td><td><b>dal</b></td></tr>
                <tr><td>7</td><td><b>zai</b></td></tr>
                <tr><td>8</td><td><b>fiu</b></td></tr>
                <tr><td>9</td><td><b>pita</b></td></tr>
                <tr><td>10</td><td><b>pire</b></td></tr>
                <tr><td>11</td><td><b>piki</b></td></tr>
                <tr><td>12</td><td><b>pivo</b></td></tr>
                <tr><td>13</td><td><b>pime</b></td></tr>
                <tr><td>14</td><td><b>pidal</b></td></tr>
                <tr><td>15</td><td><b>pizai</b></td></tr>
              </tbody>
            </table>
          </div>

          <div class="rule-note">
            <p>
              In this southern system, no is not used.
            </p>
          </div>
        </div>

        <div class="subsection">
          <h4>Quick Converter (Try it)</h4>

          <div class="info-card">
            <p class="mini-note" style="margin-bottom: 10px;">
              Input an integer and choose a region system to convert it into Spertz number wording.
            </p>

            <div class="num-converter">
              <div class="num-field">
                <label for="numInput">Integer</label>
                <input id="numInput" type="number" inputmode="numeric" placeholder="e.g., 123" min="0" max="2097152" />
              </div>

              <div class="num-field">
                <label for="numRegion">Region / Base</label>
                <select id="numRegion">
                  <option value="10">Standard (International) • Base-10</option>
                  <option value="8">Western • Base-8</option>
                  <option value="16">Southern • Base-16</option>
                </select>
              </div>
            </div>

            <div class="rule-note" style="margin-top: 14px;">
              <p style="margin: 0;">
                <b>Output:</b>
                <span id="numOutput" style="display:block; margin-top:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
                  —
                </span>
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="grammar-card">
        <h3 id="grammar-adjectives">Adjectives</h3>

        <p>
          Adjectives form an independent lexical class. They must end in a vowel, and when modifying a noun they follow the noun. Adjectival modification follows the previously defined noun-final matching rule used for adjective agreement.
        </p>

        <div class="subsection">
          <h4>Order</h4>

          <div class="rule-note">
            <p><b>Basic attributive order is:</b></p>
            <div class="syllable-grid" style="margin-top: 10px;">
              <span class="pill">Noun + Adjective</span>
            </div>
          </div>
        </div>

        <div class="subsection">
          <h4>Comparatives and Equatives</h4>

          <p class="mini-note">
            Comparative meaning is expressed with independent words, not affixes.
          </p>

          <div class="table-wrap">
            <table class="archive-table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Structure</th>
                  <th>Marker</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Comparative (“more …”)</b></td>
                  <td>Noun + Adjective + mora</td>
                  <td>mora = “more”</td>
                </tr>

                <tr>
                  <td><b>Superlative (“most …”)</b></td>
                  <td>Noun + Adjective + mesta</td>
                  <td>mesta = “most”</td>
                </tr>

                <tr>
                  <td><b>Comparative (“less …”)</b></td>
                  <td>Noun + Adjective + lora</td>
                  <td>lora = “less”</td>
                </tr>

                <tr>
                  <td><b>Superlative (“least …”)</b></td>
                  <td>Noun + Adjective + lesta</td>
                  <td>lesta = “least”</td>
                </tr>

                <tr>
                  <td><b>Equative (“as … as …”)</b></td>
                  <td>sama + Noun1 + Adjective1 + sama + Noun2 + Adjective2</td>
                  <td>sama = “as … as”</td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="rule-note">
            <p><b>Equative comparison is expressed with the marker sama, appearing on both sides of the comparison:</b></p>
            <div class="syllable-grid" style="margin-top: 10px;">
              <span class="pill">sama</span>
              <span class="pill">Noun1</span>
              <span class="pill">Adjective1</span>
              <span class="pill">sama</span>
              <span class="pill">Noun2</span>
              <span class="pill">Adjective2</span>
            </div>
          </div>
        </div>
      </div>

      <div class="grammar-card">
  <h3 id="grammar-articles">Articles</h3>

  <p>
    Spertz has both definite and indefinite articles.
  </p>

  <div class="subsection">
    <h4>Definite vs. Indefinite</h4>

    <div class="rule-note">
      <p>
        Definite reference is expressed using the demonstratives “this” and “that”, which function as definite articles when placed with a noun (equivalent to English “the (this/that) one”).
      </p>
    </div>

    <div class="rule-note">
      <p>
        Indefinite reference is marked with the article “tas”, derived historically from the numeral ta “one”. “tas” functions like English “a/an” and introduces a non-specific or newly mentioned referent.
      </p>
    </div>
  </div>

  <div class="subsection">
    <h4>Noun Phrase Order</h4>

    <p class="mini-note">
      Default noun phrase structure:
    </p>

    <div class="rule-note">
      <div class="syllable-grid">
        <span class="pill">(Topic)</span>
        <span class="pill">+</span>
        <span class="pill">(Article)</span>
        <span class="pill">+</span>
        <span class="pill">(Number)</span>
        <span class="pill">+</span>
        <span class="pill">Noun</span>
        <span class="pill">+</span>
        <span class="pill">Adjective</span>
      </div>
    </div>

    <div class="table-wrap">
      <table class="archive-table">
        <thead>
          <tr>
            <th>Slot</th>
            <th>Rule</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>Topic</b></td>
            <td>Topic marker zo (optional) appears first.</td>
          </tr>
          <tr>
            <td><b>Article</b></td>
            <td>Articles include tas (indefinite) and the demonstratives this/that (definite).</td>
          </tr>
          <tr>
            <td><b>Number</b></td>
            <td>Numbers precede the noun.</td>
          </tr>
          <tr>
            <td><b>Adjective</b></td>
            <td>Adjectives normally follow the noun and agree using the established noun-final matching rule.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="subsection">
    <h4>Possession (Genitive)</h4>

    <p class="mini-note">
      Possession is marked with the genitive suffix -e (pronounced [ɛ]).
    </p>

    <div class="rule-note">
      <p>
        In possessive noun phrases, the possessor (owner) appears first and takes -e, and the possessed noun follows immediately after.
      </p>
    </div>

    <div class="rule-note">
      <p><b>Structure:</b></p>
      <div class="syllable-grid" style="margin-top: 10px;">
        <span class="pill">(Topic)</span>
        <span class="pill">+</span>
        <span class="pill">(Article)</span>
        <span class="pill">+</span>
        <span class="pill">(Number)</span>
        <span class="pill">+</span>
        <span class="pill">Possessor-e</span>
        <span class="pill">+</span>
        <span class="pill">Possessed Noun</span>
        <span class="pill">+</span>
        <span class="pill">(Adjective for the possessed noun)</span>
      </div>
    </div>

    <div class="rule-note">
      <p>
        Important: the adjective placed after the possessed noun describes the possessed noun, not the possessor.
      </p>
    </div>
  </div>

  <div class="subsection">
    <h4>Adjectives Modifying the Possessor</h4>

    <p class="mini-note">
      If an adjective is intended to describe the possessor (the noun marked with -e), the adjective is placed before the possessor, and a written linker n is inserted to mark the scope. The linker n is silent (not pronounced) and exists purely to avoid ambiguity in writing.
    </p>

    <div class="rule-note">
      <p><b>Structure:</b></p>
      <div class="syllable-grid" style="margin-top: 10px;">
        <span class="pill">Adjective</span>
        <span class="pill">+</span>
        <span class="pill">n</span>
        <span class="pill">+</span>
        <span class="pill">Possessor-e</span>
        <span class="pill">+</span>
        <span class="pill">Possessed Noun</span>
        <span class="pill">+</span>
        <span class="pill">(Adjective for the possessed noun)</span>
      </div>
    </div>
  </div>

    </div>

    <div class="grammar-card">
      <h3 id="grammar-word-order">Sentence Word Order</h3>

      <p>
        The default word order in declarative clauses is SVO (Subject–Verb–Object).
      </p>

      <div class="rule-note">
        <p>
          For imperatives (commands), Spertz uses SOV order as a grammatical strategy to mark directive force.
        </p>
      </div>

      <div class="rule-note">
        <p>
          A topicalized element may optionally be introduced using the topic marker zo, placed at the beginning of the clause.
        </p>
      </div>

      <div class="syllable-grid">
        <span class="pill">Declarative: SVO</span>
        <span class="pill">Imperative: SOV</span>
        <span class="pill">Topic marker: zo (clause-initial)</span>
      </div>
    </div>

    <div class="grammar-card">
  <h3 id="grammar-yesno">Yes–No Questions</h3>

  <p>
    Yes–no questions are formed by placing a question marker/word (zequk, or ze) at the beginning of the sentence and using rising intonation. The internal word order does not change.
  </p>

  <div class="subsection">
    <h4>Missing Information Deletion</h4>

    <p class="mini-note">
      When information is unknown, Spertz allows deletion of the missing element rather than inserting a dummy form. In general: remove whatever information is not known (“missing information deletion”).
    </p>

    <div class="rule-note">
      <p>
        Information Deletion in Questions
      </p>
      <p style="margin: 10px 0 0;">
        If the subject is unknown, subject agreement marking may be omitted, since the pronoun/person is not specified. If other components are unknown, they are similarly omitted from the clause.
      </p>
    </div>

    <div class="example-box">
      <p>
        <b>Example (statement):</b><br>
        Wio i-kreit. = “I will make/do (it).”
      </p>

      <p style="margin-top: 12px;">
        <b>Example (question with unknown subject):</b><br>
        Kynar i-krei? = “Who will make/do (it)?”<br>
        (Subject agreement is omitted because the subject pronoun is unknown.)
      </p>
    </div>
  </div>
  </div>

  <div class="grammar-card">
    <h3 id="grammar-conjunctions">Conjunctions</h3>

    <p>
      Spertz uses independent conjunction words to link words, phrases, and clauses.
    </p>

    <div class="table-wrap">
      <table class="archive-table">
        <thead>
          <tr>
            <th>Form</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tbody>
          <tr><td><b>pa</b></td><td>“and”</td></tr>
          <tr><td><b>utrez</b></td><td>“or” (exclusive only: X or Y, but not both)</td></tr>
          <tr><td><b>zai</b></td><td>“but”</td></tr>
          <tr><td><b>lunte</b></td><td>“then / and then”</td></tr>
          <tr><td><b>bey</b></td><td>“because”</td></tr>
          <tr><td><b>eki</b></td><td>“if”</td></tr>
        </tbody>
      </table>
    </div>

    <div class="subsection">
      <h4>Note on “or”</h4>

      <div class="rule-note">
        <p>
          The conjunction utrez is exclusive by default (“X or Y, but not both”). To allow the inclusive reading (“X or Y, or both”), Spertz uses “X utrez Y utrez ve”.
        </p>
        <p style="margin: 10px 0 0;">
          ve = “both / also included”
        </p>
      </div>

      <div class="rule-note">
        <div class="syllable-grid">
          <span class="pill">X utrez Y utrez ve</span>
        </div>
      </div>
    </div>
  </div>

  <div class="grammar-card">
    <h3 id="grammar-subclauses">Subclauses</h3>

    <p>
      Subclauses are introduced by an explicit subordinator (linking word). Clause-internal word order remains SVO, just like main clauses.
    </p>

    <div class="rule-note">
      <p>
        In formal writing, subclauses are additionally enclosed with the silent boundary markers | ... | to clearly mark the start and end of the embedded clause. These bars are not pronounced; in speech, clause boundaries are inferred from context and intonation.
      </p>
    </div>

    <div class="subsection">
      <h4>Basic structure</h4>

      <div class="rule-note">
        <p><b>Main clause + subordinator + | subclause content | + remaining material</b></p>
      </div>

      <div class="syllable-grid">
        <span class="pill">Main clause</span>
        <span class="pill">+</span>
        <span class="pill">subordinator</span>
        <span class="pill">+</span>
        <span class="pill">| subclause content |</span>
        <span class="pill">+</span>
        <span class="pill">remaining material</span>
      </div>
    </div>

    <div class="subsection">
      <h4>Nested subclauses</h4>

      <p class="mini-note">
        Nested embedding uses the same system recursively:
      </p>

      <div class="rule-note">
        <p>
          Main clause + subordinator + | subclause1-part1 + subordinator + | subclause2 | + subclause1-part2 | + remaining material
        </p>
      </div>

      <div class="rule-note">
        <p>
          The boundary markers exist purely for written disambiguation.
        </p>
      </div>
    </div>
  </div>

    </div>
  </div>

  <div class="content" id="quiz">
    <h2>Quiz</h2>
    <div class="phonetics-archive">
      <div class="info-card">
        <h3>Random Spertz Quiz</h3>
        <p class="mini-note">
          Choose how many questions you want (1–10).
        </p>

        <div class="quiz-controls">
          <div class="num-converter">
            <div class="num-field">
              <label for="quizCount">Number of questions</label>
              <select id="quizCount">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5" selected>5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
              </select>
            </div>
          </div>

          <div class="quiz-actions">
            <button id="quizGenerate" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Generate Quiz</span>
              <span class="acc-icon">⟳</span>
            </button>

            <button id="quizSubmit" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Submit Answers</span>
              <span class="acc-icon">✓</span>
            </button>
          </div>
        </div>

        <div class="grammar-divider"></div>

        <div id="quizArea" class="phonetics-archive"></div>
        <div id="quizScore" class="rule-note" style="margin-top: 12px; display:none;"></div>
      </div>

      <div class="info-card" id="quiz-animal">
        <h3>Which Spertz Animal Matches You?</h3>
        <p class="mini-note">
          Answer the questions below and discover your closest animal match.
          You can optionally paste your share code to include your name and portrait on the result card.
        </p>

        <div class="num-converter" style="margin-top: 10px;">
          <div class="num-field" style="grid-column: 1 / -1;">
            <label for="animalShareCode">Optional share code (for name + portrait)</label>
            <textarea id="animalShareCode" class="share-code" placeholder="SPERTZ1:..."></textarea>
          </div>
          <div class="num-field" style="grid-column: 1 / -1;">
            <label for="animalPortraitMode">Portrait on result card</label>
            <select id="animalPortraitMode">
              <option value="traditional">Traditional (Pixel)</option>
              <option value="illustrated">Illustrated (Drawn)</option>
            </select>
          </div>
        </div>

        <div class="animal-actions">
          <button id="animalShareApply" class="accordion-btn" type="button" style="max-width: 240px;">
            <span>Use Share Code</span>
            <span class="acc-icon">✓</span>
          </button>
          <button id="animalShareClear" class="accordion-btn" type="button" style="max-width: 240px;">
            <span>Clear Share Code</span>
            <span class="acc-icon">⟳</span>
          </button>
          <div class="rule-note" style="margin:0; flex:1 1 220px;">
            <p style="margin:0;"><b>Status:</b> <span id="animalShareStatus">No code loaded.</span></p>
          </div>
        </div>

        <div class="grammar-divider"></div>

        <div id="animalQuizQuestions" class="personality-wrap"></div>

        <div class="animal-actions">
          <button id="animalQuizSubmit" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>See Results</span>
            <span class="acc-icon">✓</span>
          </button>
          <button id="animalQuizReset" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Reset</span>
            <span class="acc-icon">⟳</span>
          </button>
          <button id="animalGuideToggle" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Animal Guidebook</span>
            <span class="acc-icon">▾</span>
          </button>
        </div>

        <div id="animalGuide" class="rule-note" style="margin-top: 12px; display:none;"></div>

        <div id="animalQuizResults" class="rule-note" style="margin-top: 12px; display:none;"></div>
      </div>

      <div class="info-card" id="quiz-superpower">
        <h3>Superpower Day: Find Your Rings</h3>
        <p class="mini-note">
          On December 26 each year in Pesimura, new adults awaken ring powers. Answer the questions to reveal your rings,
          their properties, and their rank.
        </p>

        <div id="superpowerQuestions" class="personality-wrap"></div>

        <div class="animal-actions">
          <button id="superpowerSubmit" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>See Results</span>
            <span class="acc-icon">✓</span>
          </button>
          <button id="superpowerReset" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Reset</span>
            <span class="acc-icon">⟳</span>
          </button>
        </div>

        <div id="superpowerResults" class="rule-note" style="margin-top: 12px; display:none;"></div>
      </div>
    </div>
  </div>

  <div class="content" id="personality">
    <h2>SPERTZ Personality Test</h2>
    <p class="mini-note">
      Answer honestly — there are no right or wrong answers.
    </p>

    <div class="personality-wrap">
      <div class="personality-card">
        <h3 style="margin:0;">Intro</h3>
        <p class="mini-note" style="margin-top:8px;">
          Each statement uses a 7-point scale from <b>Strongly Disagree</b> to <b>Strongly Agree</b>.
        </p>
      </div>

      <div id="personalityQuestions" class="personality-wrap"></div>

      <div class="personality-actions" style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="personalitySubmit" class="accordion-btn" type="button" style="max-width: 220px;">
          <span>See Results</span>
          <span class="acc-icon">✓</span>
        </button>
        <button id="personalityReset" class="accordion-btn" type="button" style="max-width: 220px;">
          <span>Reset</span>
          <span class="acc-icon">⟳</span>
        </button>
      </div>

      <div id="personalityResults" class="rule-note" style="margin-top: 12px; display:none;"></div>
    </div>
  </div>

  <div class="content" id="create">
    <h2>Create</h2>

    <div class="phonetics-archive">
      <div class="info-card">
        <h3 id="create-archive">Name</h3>

        <p class="mini-note">
          Choose your name structure. First and last names are required (1–5 syllables each). Middle name is optional.
          If you type a custom middle name, it must follow Spertz spelling rules and allowed syllable patterns.
        </p>

        <div class="num-converter">
  <div class="num-field">
    <label for="firstMode">First name</label>
    <select id="firstMode">
      <option value="random" selected>Random</option>
      <option value="custom">Custom input</option>
    </select>
  </div>

  <div class="num-field" id="firstSylWrap">
    <label for="firstSyl">First syllables (1–5)</label>
    <select id="firstSyl">
      <option value="1">1</option>
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
    </select>
  </div>
</div>

<div id="customFirstWrap" style="margin-top: 14px; display:none;">
  <div class="num-field">
    <label for="customFirst">Custom first name (CV/CVC/CCV/VCC allowed)</label>
    <input id="customFirst" type="text" placeholder="e.g., krei / sorol / tareil" />
  </div>
</div>

<div class="num-converter" style="margin-top: 14px;">
  <div class="num-field">
    <label for="lastMode">Last name</label>
    <select id="lastMode">
      <option value="random" selected>Random</option>
      <option value="custom">Custom input</option>
    </select>
  </div>

  <div class="num-field" id="lastSylWrap">
    <label for="lastSyl">Last syllables (1–5)</label>
    <select id="lastSyl">
      <option value="1">1</option>
      <option value="2" selected>2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
    </select>
  </div>
</div>

<div id="customLastWrap" style="margin-top: 14px; display:none;">
  <div class="num-field">
    <label for="customLast">Custom last name (CV/CVC/CCV/VCC allowed)</label>
    <input id="customLast" type="text" placeholder="e.g., navine / darezu / liguria" />
  </div>
</div>

        <div class="grammar-divider"></div>

        <div class="num-converter">
          <div class="num-field">
            <label for="middleMode">Middle name</label>
            <select id="middleMode">
              <option value="none" selected>None</option>
              <option value="random">Random</option>
              <option value="custom">Custom input</option>
            </select>
          </div>

          <div class="num-field" id="middleSylWrap" style="display:none;">
            <label for="middleSyl">Middle syllables (1–5)</label>
            <select id="middleSyl">
              <option value="1">1</option>
              <option value="2" selected>2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
            </select>
          </div>
        </div>

        <div id="customMiddleWrap" style="margin-top: 14px; display:none;">
          <div class="num-field">
            <label for="customMiddle">Custom middle name (must be valid Spertz spelling)</label>
            <input id="customMiddle" type="text" placeholder="e.g., tareil / soreil / tinar" />
          </div>
        </div>

        <div class="grammar-divider"></div>

        <div class="num-converter">
          <div class="num-field">
            <label for="nameStyle">Name style</label>
            <select id="nameStyle">
              <option value="none" selected>None (fully random)</option>
              <option value="international">International / Middle (easy)</option>
              <option value="north">North</option>
              <option value="east">East</option>
              <option value="west">West</option>
              <option value="south">South</option>
            </select>
          </div>
        </div>

        <div class="grammar-divider"></div>

        <div class="num-converter">
          <div class="num-field">
            <label for="genderSelect">Gender / Class choice</label>
            <select id="genderSelect">
              <option value="male" selected>Male</option>
              <option value="female">Female</option>
              <option value="nb">Non-binary / fluid</option>
              <option value="unknown">Unknown / non-living</option>
            </select>
          </div>

          <div class="num-field">
            <label for="pronounOut">Assigned pronoun</label>
            <div id="pronounOut"
                style="padding: 12px 12px; border-radius: 12px; border: 1px solid var(--pill-border);
                        background: var(--surface-2); color: var(--text);">
              —
            </div>
          </div>
        </div>

        <div style="margin-top: 14px; display:flex; gap: 10px; flex-wrap: wrap;">
          <button id="regenNameBtn" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Generate Name</span>
            <span class="acc-icon">⟳</span>
          </button>

          <button id="copyNameBtn" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Copy Result</span>
            <span class="acc-icon">⧉</span>
          </button>
        </div>

        <div class="rule-note" style="margin-top: 14px;">
          <p style="margin:0;">
            <b>Your name:</b>
            <span id="fullNameOut" style="display:block; margin-top: 8px; font-size: 1.1em; color:var(--heading);">
              —
            </span>
          </p>
        </div>

        <div class="rule-note" style="margin-top: 12px;">
          <p style="margin:0;">
            <b>IPA:</b>
            <span id="nameIpaOut"
                  style="display:block; margin-top: 8px;
                        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
              —
            </span>
          </p>
        </div>

        <div class="rule-note" style="margin-top: 12px;">
          <p style="margin:0;">
            <b>Status:</b> <span id="nameStatusOut">Ready.</span>
          </p>
        </div>

        <div class="grammar-divider"></div>

<h3 id="create-birthday" style="margin-top: 8px;">Birthday</h3>
<p class="mini-note">
  Enter a date or generate one randomly. Year must be 1920–2099.
</p>

<div class="num-converter">
  <div class="num-field">
    <label for="birthYear">Year (1920–2099)</label>
    <input id="birthYear" type="number" min="1920" max="2099" placeholder="e.g., 2001" />
  </div>

  <div class="num-field">
    <label for="birthMonth">Month</label>
    <select id="birthMonth"></select>
  </div>
</div>

<div class="num-converter">
  <div class="num-field">
    <label for="birthDay">Day</label>
    <input id="birthDay" type="number" min="1" max="31" placeholder="e.g., 12" />
  </div>

  <div class="num-field">
    <label>Actions</label>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button id="randomBirthBtn" class="accordion-btn" type="button" style="max-width: 240px;">
        <span>Random Birthday</span>
        <span class="acc-icon">⟳</span>
      </button>
    </div>
  </div>
</div>

<div class="rule-note" style="margin-top: 12px;">
  <p style="margin:0;">
    <b>Your birthday (Spertz):</b>
    <span id="birthSpertzOut"
          style="display:block; margin-top:8px; font-size: 1.1em; color:var(--heading);
                 font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
      —
    </span>
  </p>
</div>

<div class="rule-note" style="margin-top: 12px;">
  <p style="margin:0;">
    <b>IPA:</b>
    <span id="birthIpaOut"
          style="display:block; margin-top:8px;
                 font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;">
      —
    </span>
  </p>
</div>

<div class="rule-note" style="margin-top: 12px;">
  <p style="margin:0;">
    <b>English display:</b>
    <span id="birthEngOut" style="display:block; margin-top:8px;">
      —
    </span>
  </p>
</div>

<div class="rule-note" style="margin-top: 12px;">
  <p style="margin:0;">
    <b>Status:</b> <span id="birthStatusOut">Ready.</span>
  </p>
</div>

        <div class="grammar-divider"></div>

        <h3 id="create-portrait" style="margin-top: 8px;">Portrait Maker</h3>
        <p class="mini-note">
          Build a stylized portrait.
        </p>

        <div class="portrait-wrap">
          <div class="portrait-tabs">
            <button class="portrait-tab" type="button" data-portrait-view="pixel">Traditional (Pixel)</button>
            <button class="portrait-tab active" type="button" data-portrait-view="illustrated">Illustrated (Drawn)</button>
          </div>

          <div class="portrait-stage">
            <div id="portraitViewPixel" class="portrait-view">
              <canvas id="portraitCanvas" class="portrait-canvas" width="128" height="128"></canvas>
            </div>
            <div id="portraitViewIllustrated" class="portrait-view active">
              <div id="illustratedPortrait" class="portrait-illustrated" aria-label="Illustrated portrait preview">
                <img id="drawBackHair" alt="Back hair layer" />
                <img id="drawBody" alt="Body layer" />
                <img id="drawNose" alt="Nose layer" />
                <img id="drawEyes" alt="Eyes layer" />
                <canvas id="drawEyeTint" aria-hidden="true"></canvas>
                <img id="drawWink" alt="Wink layer" />
                <img id="drawClosed" alt="Closed eyes layer" />
                <img id="drawPupil" alt="Pupil layer" />
                <img id="drawBrows" alt="Eyebrows layer" />
                <img id="drawMouth" alt="Mouth layer" />
                <img id="drawFrontHair" alt="Front hair layer" />
                <img id="drawTemples" alt="Temples layer" />
                <img id="drawBraids" alt="Braids layer" />
                <img id="drawOutfit" alt="Outfit layer" />
                <img id="drawAccessory" alt="Accessory layer" />
              </div>
            </div>
          </div>

          <h4 style="margin:0; color:var(--accent-2); font-weight:500; letter-spacing:0.3px;">Skin & Shape</h4>
          <div class="portrait-grid">
            <div class="num-field">
              <label for="skinColor">Skin color</label>
              <select id="skinColor"></select>
            </div>
            <div class="num-field">
              <label for="eyeShape">Eye shape</label>
              <select id="eyeShape"></select>
            </div>
            <div class="num-field">
              <label for="eyeWinkSide">Wink side</label>
              <select id="eyeWinkSide"></select>
            </div>
            <div class="num-field">
              <label for="eyeClosedSide">Closed side</label>
              <select id="eyeClosedSide"></select>
            </div>
            <div class="num-field">
              <label for="eyeWinkSecond">Other eye shape</label>
              <select id="eyeWinkSecond"></select>
            </div>
            <div class="num-field">
              <label for="noseShape">Nose shape</label>
              <select id="noseShape"></select>
            </div>
            <div class="num-field">
              <label for="mouthShape">Mouth shape</label>
              <select id="mouthShape"></select>
            </div>
            <div class="num-field">
              <label for="mouthSize">Mouth size</label>
              <select id="mouthSize"></select>
            </div>
            <div class="num-field">
              <label for="browShape">Eyebrows</label>
              <select id="browShape"></select>
            </div>
            <div class="num-field">
              <label for="genderStyle">Gender vibe</label>
              <select id="genderStyle"></select>
            </div>
          </div>

          <h4 style="margin:0; color:var(--accent-2); font-weight:500; letter-spacing:0.3px;">Hair</h4>
          <div class="portrait-grid">
            <div class="num-field">
              <label for="hairColor">Hair color</label>
              <select id="hairColor"></select>
            </div>
            <div class="num-field">
              <label for="hairHighlight">Hair highlight</label>
              <select id="hairHighlight"></select>
            </div>
            <div class="num-field">
              <label for="hairFront">Bangs</label>
              <select id="hairFront"></select>
            </div>
            <div class="num-field">
              <label for="hairFrontSide">Bangs side</label>
              <select id="hairFrontSide"></select>
            </div>
            <div class="num-field">
              <label for="hairTemples">Temples</label>
              <select id="hairTemples"></select>
            </div>
            <div class="num-field">
              <label for="hairBack">Back hair</label>
              <select id="hairBack"></select>
            </div>
            <div class="num-field">
              <label for="hairBackLength">Back hair length</label>
              <select id="hairBackLength"></select>
            </div>
            <div class="num-field">
              <label for="hairBackOther">Back hair (other style)</label>
              <select id="hairBackOther"></select>
            </div>
            <div class="num-field">
              <label for="hairBraids">Braids</label>
              <select id="hairBraids"></select>
            </div>
            <div class="num-field">
              <label for="hairSingleBraidPos">Single braid position</label>
              <select id="hairSingleBraidPos"></select>
            </div>
            <div class="num-field">
              <label for="hairSingleBraidLen">Ponytail length</label>
              <select id="hairSingleBraidLen"></select>
            </div>
            <div class="num-field">
              <label for="hairDoubleBraidStyle">Double braids style</label>
              <select id="hairDoubleBraidStyle"></select>
            </div>
            <div class="num-field">
              <label for="hairDoubleBraidSide">Double braids side</label>
              <select id="hairDoubleBraidSide"></select>
            </div>
            <div class="num-field">
              <label for="hairDoubleBraidLen">Twin ponytails length</label>
              <select id="hairDoubleBraidLen"></select>
            </div>
            <div class="num-field">
              <label for="hairLowTwinLen">Low twin ponytails length</label>
              <select id="hairLowTwinLen"></select>
            </div>
          </div>

          <h4 style="margin:0; color:var(--accent-2); font-weight:500; letter-spacing:0.3px;">Eyes</h4>
          <div class="portrait-grid">
            <div class="num-field">
              <label for="leftEyeColor">Eye color (base)</label>
              <select id="leftEyeColor"></select>
            </div>
            <div class="num-field" style="display:flex; align-items:flex-end; gap:10px;">
              <label style="display:flex; align-items:center; gap:8px; margin:0;">
                <input id="eyeSpecialToggle" type="checkbox" />
                Special eyes (left/right + top/bottom)
              </label>
            </div>
            <div class="num-field">
              <label for="rightEyeColor">Right eye color</label>
              <select id="rightEyeColor"></select>
            </div>
            <div class="num-field">
              <label for="leftEyeTop">Left eye top</label>
              <select id="leftEyeTop"></select>
            </div>
            <div class="num-field">
              <label for="leftEyeBottom">Left eye bottom</label>
              <select id="leftEyeBottom"></select>
            </div>
            <div class="num-field">
              <label for="rightEyeTop">Right eye top</label>
              <select id="rightEyeTop"></select>
            </div>
            <div class="num-field">
              <label for="rightEyeBottom">Right eye bottom</label>
              <select id="rightEyeBottom"></select>
            </div>
            <div class="num-field" style="display:flex; align-items:flex-end; gap:10px;">
              <label style="display:flex; align-items:center; gap:8px; margin:0;">
                <input id="pupilToggle" type="checkbox" checked />
                Pupil layer
              </label>
            </div>
          </div>

          <h4 style="margin:0; color:var(--accent-2); font-weight:500; letter-spacing:0.3px;">Costume</h4>
          <div class="portrait-grid">
            <div class="num-field">
              <label for="outfitStyle">Outfit</label>
              <select id="outfitStyle"></select>
            </div>
            <div class="num-field">
              <label for="outfitColor">Outfit color</label>
              <select id="outfitColor"></select>
            </div>
            <div class="num-field">
              <label for="blazerStyle">Blazer</label>
              <select id="blazerStyle"></select>
            </div>
          </div>

          <h4 style="margin:0; color:var(--accent-2); font-weight:500; letter-spacing:0.3px;">Background</h4>
          <div class="portrait-grid">
            <div class="num-field">
              <label for="bgStyle">Background style</label>
              <select id="bgStyle"></select>
            </div>
            <div class="num-field">
              <label for="bgColor">Background color</label>
              <select id="bgColor"></select>
            </div>
          </div>

          <div class="portrait-actions">
            <button id="portraitRandom" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Randomize Portrait</span>
              <span class="acc-icon">⟳</span>
            </button>
            <button id="portraitDownload" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Download PNG</span>
              <span class="acc-icon">⬇</span>
            </button>
          </div>
        </div>

        <div class="grammar-divider"></div>

<h3 id="create-share" style="margin-top: 8px;">Share Your Character</h3>
        <p class="mini-note">
          Generate a share code for this website. Anyone can paste it to load your name, birthday, gender, and portrait.
        </p>

        <div class="num-converter">
          <div class="num-field" style="grid-column: 1 / -1;">
            <label for="shareCode">Share code</label>
            <textarea id="shareCode" class="share-code" placeholder="SPERTZ1:..."></textarea>
          </div>
        </div>

        <div style="margin-top: 12px; display:flex; gap:10px; flex-wrap:wrap;">
          <button id="shareGenerate" class="accordion-btn" type="button" style="max-width: 240px;">
            <span>Generate Code</span>
            <span class="acc-icon">⧉</span>
          </button>

          <button id="shareApply" class="accordion-btn" type="button" style="max-width: 240px;">
            <span>Load Code</span>
            <span class="acc-icon">✓</span>
          </button>
        </div>

        <div class="rule-note" style="margin-top: 12px;">
          <p style="margin:0;">
            <b>Status:</b> <span id="shareStatus">Ready.</span>
          </p>
        </div>

      </div>

        <div class="grammar-divider"></div>

        <div class="info-card" id="create-cook">
          <h3 style="margin:0;">SPERTZ Cook</h3>
          <p class="mini-note">
            Choose ingredients and seasonings, then pick a preparation method to create a dish. New dishes unlock more options.
          </p>

          <div class="cook-grid">
            <div class="info-card">
              <h4 style="margin:0;">Ingredients</h4>
              <div id="cookIngredients" class="cook-list" style="margin-top:10px;"></div>
            </div>
            <div class="info-card">
              <h4 style="margin:0;">Seasonings</h4>
              <div id="cookSeasonings" class="cook-list" style="margin-top:10px;"></div>
            </div>
            <div class="info-card">
              <h4 style="margin:0;">Preparation</h4>
              <div id="cookMethods" class="cook-list" style="margin-top:10px;"></div>
            </div>
          </div>

        <div class="cook-actions">
          <button id="cookMake" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Make Dish</span>
            <span class="acc-icon">✓</span>
          </button>
          <button id="cookReset" class="accordion-btn" type="button" style="max-width: 220px;">
            <span>Clear Bowl</span>
            <span class="acc-icon">⟳</span>
          </button>
          <div class="cook-coins">
            <span>Coins:</span> <b id="cookCoins">0</b>
          </div>
          <div class="cook-coins">
            <span>Reputation:</span> <b id="cookRep">50</b>
          </div>
          <div class="cook-coins">
            <span>Advanced:</span> <b id="cookAdvancedCount">0/0</b>
          </div>
          <div class="rule-note" style="margin:0; flex:1 1 220px;">
            <p style="margin:0;"><b>Status:</b> <span id="cookStatus">Ready.</span></p>
          </div>
        </div>

        <div class="info-card" style="margin-top:12px;">
          <h4 style="margin:0;">Unlocks</h4>
          <p class="mini-note" style="margin-top:6px;">Spend coins to unlock more ingredients, seasonings, and methods.</p>
          <div class="cook-actions">
            <button id="cookUnlockIng" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Unlock Ingredient (3 coins)</span>
              <span class="acc-icon">＋</span>
            </button>
            <button id="cookUnlockSea" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Unlock Seasoning (3 coins)</span>
              <span class="acc-icon">＋</span>
            </button>
            <button id="cookUnlockMet" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Unlock Method (5 coins)</span>
              <span class="acc-icon">＋</span>
            </button>
          </div>
        </div>

        <div class="info-card" style="margin-top:12px;">
          <h4 style="margin:0;">Customers</h4>
          <p class="mini-note" style="margin-top:6px;">Serve the right dish to earn coins. Ignore if you want; they will leave.</p>
          <div class="rule-note" style="margin-top:8px;">
            <p style="margin:0;"><b>Current customer:</b> <span id="cookCustomer">None</span></p>
          </div>
          <div class="cook-actions">
            <button id="cookServe" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Serve Last Dish</span>
              <span class="acc-icon">✓</span>
            </button>
            <button id="cookSkip" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Ignore Customer</span>
              <span class="acc-icon">⟳</span>
            </button>
          </div>
          <div class="rule-note" style="margin-top:8px;">
            <p style="margin:0;"><b>Last dish:</b> <span id="cookLastDish">None</span></p>
          </div>
        </div>

        <div class="info-card" style="margin-top:12px;">
          <h4 style="margin:0;">Customer Guidebook</h4>
          <p class="mini-note" style="margin-top:6px;">Know what each customer likes before serving.</p>
          <div id="cookCustomerGuide" class="cook-hints" style="margin-top:10px;"></div>
        </div>

        <div class="info-card" style="margin-top:12px;">
          <h4 style="margin:0;">Dish Book</h4>
          <p class="mini-note" style="margin-top:6px;">Collected dishes and the items used. Dishes are final and can’t be turned back.</p>
          <div id="cookBook" class="cook-book"></div>
        </div>

        <div class="info-card" style="margin-top:12px;">
          <h4 style="margin:0;">Recipe Hints</h4>
          <p class="mini-note" style="margin-top:6px;">Spend coins to reveal a recipe hint for advanced dishes.</p>
          <div class="cook-actions">
            <button id="cookHintBuy" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Buy Hint (4 coins)</span>
              <span class="acc-icon">✦</span>
            </button>
          </div>
          <div id="cookHints" class="cook-hints" style="margin-top:10px;"></div>
        </div>

          <div class="info-card" style="margin-top:12px;">
            <h4 style="margin:0;">Save / Load</h4>
            <p class="mini-note" style="margin-top:6px;">Generate a save code to keep your progress, or paste one to restore.</p>
            <div class="num-converter">
              <div class="num-field" style="grid-column: 1 / -1;">
                <label for="cookSaveCode">Save code</label>
                <textarea id="cookSaveCode" class="share-code" placeholder="COOK1:..."></textarea>
              </div>
            </div>
            <div class="cook-actions">
              <button id="cookSave" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Generate Code</span>
                <span class="acc-icon">⧉</span>
              </button>
              <button id="cookLoad" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Load Code</span>
                <span class="acc-icon">✓</span>
              </button>
            </div>
          </div>

        </div>

        <div class="grammar-divider"></div>

        <div class="info-card" id="create-car">
          <h3 style="margin:0;">Car Innovation</h3>
          <p class="mini-note">
            Combine features to design your car.
          </p>

          <div class="num-converter" style="margin-top: 10px;">
            <div class="num-field" style="grid-column: 1 / -1;">
              <label for="carShareCode">Optional share code (for name on certificate)</label>
              <textarea id="carShareCode" class="share-code" placeholder="SPERTZ1:..."></textarea>
            </div>
          </div>
          <div style="margin-top: 12px; display:flex; gap:10px; flex-wrap:wrap;">
            <button id="carShareApply" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Load Code</span>
              <span class="acc-icon">✓</span>
            </button>
            <button id="carShareClear" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Clear Code</span>
              <span class="acc-icon">⟲</span>
            </button>
          </div>
          <div class="rule-note" style="margin-top: 10px;">
            <p style="margin:0;"><b>Status:</b> <span id="carShareStatus">No code loaded.</span></p>
          </div>

          <div class="car-grid" id="carInnovationOptions" style="margin-top:12px;"></div>

          <div class="cook-actions" style="margin-top:12px;">
            <button id="carGenerate" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Generate Result</span>
              <span class="acc-icon">✓</span>
            </button>
            <button id="carReset" class="accordion-btn" type="button" style="max-width: 220px;">
              <span>Clear Choices</span>
              <span class="acc-icon">⟲</span>
            </button>
          </div>

          <div id="carResults" class="car-results"></div>
        </div>

        <div class="grammar-divider"></div>

        <div class="info-card" id="create-quest">
          <h3 style="margin:0;">Kopahor Quest: Crystal of the South</h3>
          <p class="mini-note">
            You are the new leader of Kopahor. Build supplies, survive the southern march, and decide how to face the crystal conflict.
          </p>

          <div class="num-converter" style="margin-top: 10px;">
            <div class="num-field" style="grid-column: 1 / -1;">
              <label for="questShareCode">Optional share code (for name on certificate)</label>
              <textarea id="questShareCode" class="share-code" placeholder="SPERTZ1:..."></textarea>
            </div>
          </div>
          <div style="margin-top: 12px; display:flex; gap:10px; flex-wrap:wrap;">
            <button id="questShareApply" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Load Code</span>
              <span class="acc-icon">✓</span>
            </button>
            <button id="questShareClear" class="accordion-btn" type="button" style="max-width: 240px;">
              <span>Clear Code</span>
              <span class="acc-icon">⟲</span>
            </button>
          </div>
          <div class="rule-note" style="margin-top: 10px;">
            <p style="margin:0;"><b>Status:</b> <span id="questShareStatus">No code loaded.</span></p>
          </div>

          <div class="info-card" style="margin-top:12px;">
            <div class="quest-card">
              <div>
                <b id="questChapter">Chapter 1</b>
                <p class="mini-note" id="questSceneText" style="margin-top:6px;"></p>
              </div>
              <div id="questChoices" class="quest-choices"></div>
              <div id="questOutcome" class="rule-note" style="display:none;"></div>
              <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button id="questContinue" class="accordion-btn" type="button" style="max-width: 220px; display:none;">
                  <span>Continue</span>
                  <span class="acc-icon">→</span>
                </button>
              </div>
            </div>
          </div>

          <div class="info-card" style="margin-top:12px;">
            <h4 style="margin:0;">Campaign Status</h4>
            <div id="questMeters" class="quest-meter" style="margin-top:8px;"></div>
          </div>

          <div class="info-card" style="margin-top:12px;">
            <h4 style="margin:0;">Guide Book (Best Ending Path)</h4>
            <p class="mini-note" style="margin-top:6px;">
              Recommended choices to reach the best ending with minimal losses. Use as a guide.
            </p>
            <details class="rule-note" style="margin-top:8px;">
              <summary>Open guide</summary>
              <div id="questGuideList" style="margin-top:8px;"></div>
            </details>
          </div>

          <div id="questResults" class="car-results"></div>
        </div>

      </div>
    </div>
  </div>

  <div class="content" id="resources">
  <h2>Extra Resources</h2>

  <div class="phonetics-archive">
    <div class="info-card">
      <h3 id="resources-lexicon">Spertz Lexicon (Verbs)</h3>
      <div class="table-wrap">
        <table class="archive-table" id="lexiconTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Spertz</th>
              <th>English meaning</th>
            </tr>
          </thead>
          <tbody id="lexiconBody"></tbody>
        </table>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-months">A Small Story: Why the Months Have Those Names</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          In Spertz culture, months are tiny myths you carry in your pocket.
          Even the spelling tells you what kind of month you are walking into.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            Most month names begin with a digit-root, in order:
          </p>
          <div class="syllable-grid" style="margin-top: 10px;">
            <span class="pill">ta</span>
            <span class="pill">re</span>
            <span class="pill">ki</span>
            <span class="pill">vo</span>
            <span class="pill">me</span>
            <span class="pill">dal</span>
            <span class="pill">zai</span>
            <span class="pill">fiu</span>
          </div>
        </div>

        <div class="rule-note" style="margin-top: 12px;">
          <p style="margin:0;">
            But four months are different: 6, 7, 8, and 12.
            They begin with <b>xi</b>, the “star-moon” prefix,
            used for praised and worshiped festival months.
          </p>
          <div class="syllable-grid" style="margin-top: 10px;">
            <span class="pill">xi-sa-ta</span>
            <span class="pill">xi-se-re</span>
            <span class="pill">xi-si-ki</span>
            <span class="pill">xi-so-vo</span>
          </div>
        </div>

        <p>
          The story begins in a small observatory-library on the ridge of <b>Dalren</b>, where the roof is flat,
          the tea is always too hot, and the sky is treated like a serious text that must be reread every night.
        </p>

        <p>
          Three apprentices lived there: <b>Kivor</b>, who collected old calendars like other people collect seashells;
          <b>Tarim</b>, who insisted every constellation had a personal grudge; and <b>Resul</b>, who could hear
          the sound of chalk before it even touched the board.
        </p>

        <p>
          One evening, their mentor <b>Zaimel</b> arrived carrying a wooden box full of thin stone tiles.
          Each tile had a month name carved into it. He placed them on the table in a neat line, all twelve,
          like a parade that forgot it was supposed to be solemn.
        </p>

        <p>
          “Look carefully,” Zaimel said. “Spertz months wear their meaning on the first syllable.”
        </p>

        <p>
          Kivor pointed at the beginning of the line. “So the plain months start with numbers.
          <b>tarul</b>, <b>resur</b>, <b>kilup</b>, <b>votir</b>, <b>meka</b>… it’s counting.”
        </p>

        <p>
          “Exactly,” said Zaimel. “Eight months are the steady rhythm of the world. Work months.
          Study months. Repair-the-roof-before-it-leaks months. Their names begin with the familiar digit-roots:
          ta, re, ki, vo, me, dal, zai, fiu.
          A calendar that can be recited like arithmetic is a calendar that can survive a tired mind.”
        </p>

        <p>
          Tarim frowned and tapped the sixth tile. “Then why does this one cheat? Why does <b>xisata</b> start with <b>xi</b>?”
        </p>

        <p>
          Zaimel smiled, which was a dangerous expression on him. It usually meant someone was about to do math with emotions.
        </p>

        <p>
          “Because those months are not counted,” he said. “They are celebrated.”
        </p>

        <p>
          He lifted the four star-month tiles and set them aside like royal guests:
          <b>xisata</b>, <b>xisere</b>, <b>xisiki</b>, and <b>xisovo</b>.
          The light from the lamps caught the carvings and made them look slightly alive,
          as if they were about to ask for dessert.
        </p>

        <p>
          “In the old city of <b>Vokar</b>,” Zaimel continued, “people believed the sky had a second moon that only appeared
          during holidays. Not a real object, of course. More like an agreement between humans and the universe:
          <i>we will pretend the night is kinder, and the night will pretend we deserve it.</i>”
        </p>

        <p>
          Resul leaned forward. “So <b>xi</b> means…”
        </p>

        <p>
          “Star-moon,” said Zaimel. “A worship prefix. Praise carried at the front of the word.
          Those months are the ones with the biggest gatherings, the brightest lanterns, the longest songs,
          and the most questionable decisions made after midnight.”
        </p>

        <p>
          Kivor grinned. “Questionable decisions sound culturally important.”
        </p>

        <p>
          “Extremely,” Zaimel replied. “Some traditions require them.”
        </p>

        <p>
          Tarim picked up <b>xisiki</b> and squinted. “So these are festival months. But why those exact numbers?
          Why 6, 7, 8… and then 12?”
        </p>

        <p>
          Zaimel began arranging the tiles again, but this time he slid the normal months slightly closer together,
          like ordinary soldiers, and left generous space around the <b>xi-</b> months, like they needed room to dance.
        </p>

        <p>
          “Six, seven, and eight are the summer crest,” he said. “The harvest begins to brag.
          People thank their fields, their ovens, their tired hands. In <b>xisata</b> they honor arrival.
          In <b>xisere</b> they honor return. And in <b>xisiki</b>… they honor anything that survived long enough
          to be laughed at.”
        </p>

        <p>
          “And twelve?” Resul asked.
        </p>

        <p>
          Zaimel held up <b>xisovo</b> between two fingers. “Twelve is the closing gate.
          It is the month where everyone pretends to be generous and then quietly hopes the year forgives them anyway.
          So it receives <b>xi</b> too.
          It is not just the end of counting. It is the end of bargaining.”
        </p>

        <p>
          Kivor lifted <b>meka</b> and laughed. “So the calendar is basically: eight sensible months,
          four dramatic ones.”
        </p>

        <p>
          “That is one way to translate it,” Zaimel said. “A better way is:
          eight months teach you to build,
          and four months remind you why you ever wanted to.”
        </p>

        <p>
          Tarim stared at the line of tiles, then nodded slowly, as if the months had just confessed a secret.
          “So if you see <b>xi</b> at the start…”
        </p>

        <p>
          “You prepare,” said Zaimel. “You eat more. You sleep more. You practice smiling like you mean it.
          And you never, ever promise to just stay for one song.”
        </p>

        <p>
          Resul wrote the rule at the bottom of the board, underlined once:
          <b>xi months are praised months.</b>
          Then, because he was Resul, he underlined it a second time, just in case the universe was watching.
        </p>

        <div class="rule-note" style="margin-top: 16px;">
          <p style="margin:0;">
            In short:
          </p>
          <p style="margin:10px 0 0;">
            <b>Eight months</b> begin with digit-roots (ta re ki vo me dal zai fiu).<br>
            <b>Four festival months</b> begin with <b>xi</b>, the star-moon praise prefix (6, 7, 8, 12).
          </p>
        </div>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-bases">A Small Story: Why the West Counts in Base-8 and the South in Base-16</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          Spertz is the language of Onia, a nation that cast long shadows across the map.
          When Onia expanded west and south, it carried Spertz with it — but it did not rewrite every habit.
          Numbers are stubborn things.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            <b>West:</b> Base-8 counting survives.<br>
            <b>South:</b> Base-16 counting remains the civic standard.
          </p>
        </div>

        <p>
          In the west, the old river guilds had always counted by hands and stones. Eight was the reliable unit:
          four fingers per hand, two hands per bundle. Even after Onia’s surveyors arrived with neat base-10 ledgers,
          the docks and mills kept their old measures. A basket was eight. A cart was eight baskets.
          The numbers were already tied to the shape of work.
        </p>

        <p>
          The new schools taught Spertz grammar, but the old counting survived in the marketplace.
          So Spertz numbers were simply adapted: the words changed, the base did not.
          An Onian clerk could read a western invoice, but everyone in the west knew the totals by instinct.
        </p>

        <p>
          The south was different. Onia conquered its cities, but it did not replace their engineers.
          Those cities were built on sixteen-unit grids: sixteen paces per column, sixteen tiles per panel,
          sixteen lanterns per street segment. Their crafts were tuned to powers of two long before the empire arrived.
        </p>

        <p>
          The southern academies accepted Spertz for law and diplomacy,
          yet kept base-16 for architecture, astronomy, and trade.
          It was easier to keep the math that made their bridges hold.
        </p>

        <p>
          Over time, Spertz grew a polite duality:
          base-10 for international writing, base-8 in the west, base-16 in the south.
          A single language, three habits of counting — and each one learned to live with the others.
        </p>

        <div class="rule-note" style="margin-top: 16px;">
          <p style="margin:0;">
            In short:
          </p>
          <p style="margin:10px 0 0;">
            The west keeps base-8 because it matches the old work units and trade bundles.<br>
            The south keeps base-16 because its engineering and city planning were already built on it.<br>
            Onia taught Spertz, but it could not erase how people count.
          </p>
        </div>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-spertz">A Small Story: Why the Language Is Called Spertz</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          Long before it was called Spertz, the language was called <b>Oniaga</b> — simply “the language of Onia.”
          It spread because Onia’s influence spread, and for a time the name itself sounded like authority.
        </p>

        <p>
          Then Onia’s reach went too far. In the land of <b>Kopahor</b>, a leader whose name the old records shorten
          to <b>Haviel</b> convinced rival cities to stop fighting each other and stand together.
          The argument was simple: if Onia could make them share a language, then they could share a purpose too.
        </p>

        <p>
          The conflict that followed did not end in collapse, but in negotiation. Onia agreed to step back.
          The treaties kept Oniaga as the international language — not out of loyalty, but out of practicality.
          Everyone had already learned it; no one wanted a second generation of confusion.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            To mark the peace, the name changed.
          </p>
          <p style="margin:10px 0 0;">
            <b>Spertz</b> = <b>Spert + Si</b> (“men + women”), reshaped into a new spelling: <b>SPERTZ</b>.
          </p>
        </div>

        <p>
          In Kopahor, the old consonant clusters were never comfortable. People broke the word apart and said
          <b>su-pe-ri-tsi</b> instead. The peace council honored this effort and declared <b>su-pe-ri-tsi</b>
          the “official” pronunciation — a nod to Kopahor’s role in ending the war.
        </p>

        <p>
          Almost no one follows it. Diplomats say <b>Spertz</b> because it is shorter. Merchants say <b>Spertz</b>
          because it is faster. Teachers say <b>Spertz</b> because they have a syllabus to finish.
          But in Kopahor, elders still say <b>su-pe-ri-tsi</b> at ceremonies, and every crowd knows why.
        </p>

        <p>
          The name is a treaty you can speak. The pronunciation you choose says which story you remember.
        </p>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-kopahor">A Small Story: The History of Kopahor</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          Before Kopahor was its own name on maps, it was a district of the vast eastern country <b>Pesimura</b>.
          Pesimura had mountains for safety and mines for wealth, but little open land for food.
          Kopahor had the opposite: no mountains, a coastline, and wide access to the sea.
        </p>

        <p>
          For generations, Pesimura sent metal out through Kopahor’s ports and pulled grain back in.
          The trade kept the larger country alive, but it also trained Kopahor to think beyond borders.
          They learned how to negotiate, how to ship, how to read a ledger as if it were a second language.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            Pesimura relied on Kopahor’s routes for food.
            Kopahor relied on Pesimura’s mountains for security.
          </p>
        </div>

        <p>
          When Onia attacked, Pesimura’s weakness was exposed. The armies were large but not ready,
          and the food lines were too thin. A huge land can still be a hungry land.
          Pesimura surrendered.
        </p>

        <p>
          Kopahor was furious. The district argued that surrender was not survival — it was surrender to fear.
          They pushed for negotiation, for a settlement that would keep their ports open and their people safe.
          Pesimura hesitated, then listened.
        </p>

        <p>
          The decision that followed reshaped the region: Pesimura allowed Kopahor to separate
          and make its own decisions. It was an admission of weakness, but also a gesture of respect.
          Kopahor would speak for itself.
        </p>

        <p>
          Under Haviel’s leadership, Kopahor helped broker peace with Onia.
          Pesimura, once the parent, became the proud neighbor. They had lost a district,
          but gained a stabilizing ally.
        </p>

        <p>
          When Haviel’s children took his place, they kept the same promise:
          commerce without conquest, negotiation without fear.
          The ports stayed open. The fields were planted.
          And a former district learned how to be a country.
        </p>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-faith">A Small Story: The Returning Gods</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          Across Onia and the many lands that share the Spertz family, faith is a daily habit.
          People keep small rituals — a cup of water before dawn, a ribbon tied to a doorway,
          a whispered promise before a long journey — and they say the gods are never far.
        </p>

        <p>
          The most beloved is the goddess of fate, <b>Lunaiya</b>.
          She is said to always leave a message: a bent coin found in the dust,
          a bird that repeats a name, a scribble in the margins of a book.
          To the faithful, it is never coincidence.
        </p>

        <p>
          The main god is quieter — colder, older. Some believed this god had died long ago.
          Then a mysterious sign appeared: a winter that arrived on time after decades of delay,
          or a night where the stars held still and would not move.
          The faithful said the god was alive again.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            In this faith, blessings are expected to return.
            You give, and something gives back.
          </p>
        </div>

        <p>
          Then the strangest thing happened. A group of people appeared across the lands —
          in separate cities, at the same hour — carrying power no one could explain.
          Some healed. Some spoke in voices that echoed like a temple.
          A few carried the very names of the gods themselves.
        </p>

        <p>
          The streets filled with lanterns. Bells rang for weeks.
          People said the gods had stepped down into the world, or sent pieces of themselves.
          Whether it was miracle or mystery, the celebrations did not end quickly.
        </p>

        <p>
          To this day, some still search for the next message from Lunaiya,
          and some still watch the sky for the cold god’s sign — not because they doubt,
          but because in Spertz lands, waiting is also a form of praise.
        </p>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-powers">A Small Story: Superpowers Blend In</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          The sun god and the frost-snow goddess were a couple long ago — the religious have always known it.
          But the superpowered people arrived in Pesimura for a different reason: they were escaping a disaster.
          They landed in <b>Pesimura</b>, where mountains held metals and winters held silence.
        </p>

        <p>
          Pesimura found a new way to survive: it trained the gifted. Superpowered people needed structure,
          and Pesimura had metal, stone, and stubborn patience. Training centers rose beside the mines,
          and the country sold safety, not conquest.
        </p>

        <p>
          In return, the gifted learned to make small food with their powers — warm grains that sprouted in days,
          water pulled clean from the ground. It was not magic enough to feed everyone, but it was enough
          to keep the training cities alive.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            Pesimura traded metal for discipline.
            The gifted traded power for food.
          </p>
        </div>

        <p>
          Their daughter was thrown far away to <b>Whereland</b>, a place outside the Northern League
          (the league of all Spertz-speaking nations, named for the northern hemisphere they shared).
          She built a company there and unveiled a new energy source: <b>life</b> itself — a steady power drawn
          from growth, motion, and renewal.
        </p>

        <p>
          Whereland joined the League not by pressure but by relief; energy worries disappeared.
          The daughter rose further, becoming the god of spacetime, and opened a second space — a pocket realm
          that could host training grounds and food plantations beyond any border.
        </p>

        <p>
          After that, the League was never short on resources again.
          Superpowers blended into daily life, not as fear, but as infrastructure.
        </p>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-league">A Small Story: The Spertz League</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          The Northern League began as a practical alliance of Spertz-speaking nations, all in the northern hemisphere.
          Its name was geographic, not poetic.
        </p>

        <p>
          When the leader of Whereland died, their final request was simple:
          “Call it <b>Spertz</b>.” The League agreed. It was a memorial, and a promise to keep the shared language
          at the center of their cooperation. From then on, the Northern League became the <b>Spertz League</b>.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            The League has six main members, each with a distinct role:
          </p>
        </div>

        <div class="marker-grid">
          <div class="marker-row">
            <h4>Kopahor</h4>
            <p>Government center and diplomatic core.</p>
          </div>
          <div class="marker-row">
            <h4>Pesimura</h4>
            <p>Army center and defensive coordination.</p>
          </div>
          <div class="marker-row">
            <h4>Onia</h4>
            <p>Trade and economic center.</p>
          </div>
          <div class="marker-row">
            <h4>Whereland</h4>
            <p>Technology center and energy systems.</p>
          </div>
          <div class="marker-row">
            <h4>Sifyre</h4>
            <p>Agriculture center in the second space.</p>
          </div>
          <div class="marker-row">
            <h4>Outershay</h4>
            <p>A mysterious member that remains deliberately unknown.</p>
          </div>
        </div>

        <p>
          The League’s strength is balance: each member holds a pillar the others lack.
          It is a map drawn not by borders, but by functions.
        </p>
      </div>
    </div>

    <div class="info-card story-card">
      <h3 id="resources-life">A Small Story: Everyday Life in the Spertz League</h3>

      <button class="story-toggle" type="button" aria-expanded="false">
        <span>Read story</span>
        <span class="acc-icon">+</span>
      </button>

      <div class="story-panel">
        <p class="mini-note">
          Life in the Spertz League changed twice: once when the old systems were still fragile,
          and again after the life-energy breakthrough reshaped the daily routine.
        </p>

        <p>
          Before, meals were simple and local, built around whatever a city could grow or trade that week.
          Travel was functional but slow. Homes were real walls, real doors, and a real limit to space.
          Convenience existed, but it had edges.
        </p>

        <p>
          After the life-energy system spread, the rhythm of ordinary life became fast, soft, and abundant.
          Citizens choose from huge daily menus, with dishes from every member of the League —
          and superpowered cooks turn them into finished meals in one or two minutes, sauces included.
        </p>

        <div class="rule-note">
          <p style="margin:0;">
            Daily life now centers on speed, choice, and expansion.
          </p>
        </div>

        <p>
          Transportation is everywhere: layered rails, quiet sky-lanes, and short-range gates that make long distances feel small.
          Commuting is less about “going far” and more about “arriving instantly.”
        </p>

        <p>
          Housing grew upward and inward. Massive residential complexes rise over each city,
          while Whereland sells personal “virtual space” that expands a room beyond its walls.
          A small apartment can unfold into a private garden, a music studio, or a starfield hall.
        </p>

        <p>
          The most luxurious places are the <b>Whereland Tower</b> and the <b>Kopahor Tower</b>.
          They are reserved for government workers and company owners.
          On the top floors, residents often own full virtual worlds — the tower appears as a single door,
          but inside is an entire landscape of nature or any style they choose.
        </p>

        <p>
          In the Spertz League, normal life is no longer about survival.
          It is about designing how you want your day to feel.
        </p>
      </div>
    </div>
    </div>
  </div>

  <script>
    // ===== Style chooser =====
    (function () {
      const select = document.getElementById("themeSelect");
      if (!select) return;

      const storageKey = "stvnworld-theme";
      const saved = localStorage.getItem(storageKey);
      const initial = saved || "default";

      function applyTheme(theme) {
        if (theme === "default") {
          document.body.removeAttribute("data-theme");
        } else {
          document.body.setAttribute("data-theme", theme);
        }
        localStorage.setItem(storageKey, theme);
      }

      applyTheme(initial);
      select.value = initial;

      select.addEventListener("change", () => {
        applyTheme(select.value);
      });
    })();

    // ===== Nav dropdowns =====
    (function () {
      const nav = document.querySelector("nav");
      const navToggle = document.querySelector(".nav-toggle");
      const navItemsWrap = document.getElementById("mainNav");
      const navItems = document.querySelectorAll(".nav-item");
      const dropButtons = document.querySelectorAll(".nav-drop");

      if (!navItems.length) return;

      function closeNav() {
        if (!nav || !navToggle || !navItemsWrap) return;
        nav.classList.remove("nav-open");
        navToggle.setAttribute("aria-expanded", "false");
      }

      function closeAll(except) {
        navItems.forEach((item) => {
          if (item !== except) item.classList.remove("open");
        });
        dropButtons.forEach((btn) => {
          if (!except || btn.closest(".nav-item") !== except) {
            btn.setAttribute("aria-expanded", "false");
          }
        });
      }

      if (navToggle && nav && navItemsWrap) {
        navToggle.addEventListener("click", () => {
          const willOpen = !nav.classList.contains("nav-open");
          nav.classList.toggle("nav-open", willOpen);
          navToggle.setAttribute("aria-expanded", String(willOpen));
          if (!willOpen) closeAll();
        });
      }

      dropButtons.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const item = btn.closest(".nav-item");
          const isOpen = item.classList.contains("open");
          closeAll(item);
          item.classList.toggle("open", !isOpen);
          btn.setAttribute("aria-expanded", String(!isOpen));
        });
      });

      document.querySelectorAll(".nav-menu a, .nav-link").forEach((link) => {
        link.addEventListener("click", () => {
          closeAll();
          closeNav();
        });
      });

      document.addEventListener("click", (e) => {
        if (!e.target.closest(".nav-item") && !e.target.closest(".nav-toggle")) {
          closeAll();
          closeNav();
        }
      });
    })();

    // ===== Quiz =====
    (function () {
      const quizCount = document.getElementById("quizCount");
      const quizGenerate = document.getElementById("quizGenerate");
      const quizSubmit = document.getElementById("quizSubmit");
      const quizArea = document.getElementById("quizArea");
      const quizScore = document.getElementById("quizScore");

      if (!quizCount || !quizGenerate || !quizSubmit || !quizArea || !quizScore) return;

      const VERBS = [
        ["ampi","believe"],
        ["ampiria","hope"],
        ["aye","have"],
        ["beya","need, want"],
        ["dara","dance"],
        ["daresu","understand"],
        ["daro","suppose; assume"],
        ["davi","lose"],
        ["daze","close"],
        ["dezu","explain"],
        ["doye","cause; make"],
        ["dravo","arrive"],
        ["fane","end; finish"],
        ["fireno","request"],
        ["folo","forget"],
        ["fure","rest"],
        ["fureyi","continue"],
        ["gavu","eat"],
        ["golu","drink"],
        ["heta","speak; say"],
        ["heti","listen"],
        ["hodape","open"],
        ["jion","like"],
        ["kame","consider"],
        ["kampi","keep"],
        ["kamu","think"],
        ["korati","challenge"],
        ["krei","do; make"],
        ["krechei","decision"],
        ["lanko","belong to"],
        ["lavi","love"],
        ["laza","play"],
        ["liguria","shine; illuminate"],
        ["lika","read"],
        ["lume","research; study"],
        ["lure","talk; converse"],
        ["meli","remember"],
        ["melu","miss"],
        ["mezu","write"],
        ["mie","meet"],
        ["miori","participate"],
        ["mire","describe"],
        ["mura","marry"],
        ["namu","be called; be named"],
        ["nata","put; place"],
        ["navine","walk"],
        ["nelu","search; look for"],
        ["novi","follow"],
        ["oio","regard as; treat as"],
        ["paraya","leave"],
        ["petra","rise"],
        ["poso","occupy"],
        ["pozo","prove"],
        ["praisa","aim at"],
        ["praise","guide"],
        ["quino","ask"],
        ["quma","choose"],
        ["rake","get; obtain"],
        ["raku","prepare"],
        ["reni","answer"],
        ["revo","run"],
        ["revu","return"],
        ["sela","tell"],
        ["sire","paint"],
        ["sola","sleep"],
        ["solvia","sing"],
        ["soraye","study; learn"],
        ["sorae","teach"],
        ["sumi","count"],
        ["su","live; exist"],
        ["suri","live"],
        ["tamu","work"],
        ["tira","come"],
        ["tiru","bring"],
        ["tori","carry"],
        ["trake","begin; start"],
        ["tra","stand"],
        ["trepsa","oppose"],
        ["trive","share"],
        ["vayi","want"],
        ["veli","wait"],
        ["veska","travel"],
        ["veskari","please"],
        ["vese","see"],
        ["vire","receive"],
        ["vona","watch"],
        ["zanu","appreciate; admire"],
        ["zeyo","go"],
        ["zeyu","should"],
        ["zima","buy"],
      ];

      const VERB_MEANING = Object.fromEntries(VERBS);

      const SUBJECT_SUFFIX = {
        "omit": "",
        "1sg": "t",
        "1pl": "wen",
        "2sg": "ya",
        "2pl": "yen",
        "3sg": "se",
        "3pl": "ten",
      };

      const SUBJECT_EN = {
        "omit": "(someone)",
        "1sg": "I",
        "1pl": "we",
        "2sg": "you",
        "2pl": "you (pl)",
        "3sg": "they/he/she",
        "3pl": "they",
      };

      const ASPECT_SUFFIX = {
        "none": "",
        "ok": "ok",
        "im": "im",
        "ul": "ul",
        "en": "en",
      };

      const MOOD_SUFFIX = {
        "none": "",
        "or": "or",
        "el": "el",
      };

      const VOWELS = [
        { spelling: "i", ipa: "i" },
        { spelling: "ei", ipa: "e" },
        { spelling: "e", ipa: "ɛ" },
        { spelling: "ae", ipa: "æ" },
        { spelling: "u", ipa: "u" },
        { spelling: "oe", ipa: "ʊ" },
        { spelling: "o", ipa: "o" },
        { spelling: "a", ipa: "ɑ" },
        { spelling: "ai", ipa: "ɑi" },
        { spelling: "iu", ipa: "ju" },
        { spelling: "au", ipa: "ɑu" },
        { spelling: "ua", ipa: "wɑ" },
        { spelling: "yi", ipa: "iː" },
        { spelling: "ye", ipa: "ɛː" },
      ];

      const CONSONANTS = [
        { spelling: "p", ipa: "p" },
        { spelling: "b", ipa: "b" },
        { spelling: "t", ipa: "t" },
        { spelling: "d", ipa: "d" },
        { spelling: "k", ipa: "k" },
        { spelling: "g", ipa: "g" },
        { spelling: "f", ipa: "f" },
        { spelling: "v", ipa: "v" },
        { spelling: "s", ipa: "s" },
        { spelling: "z", ipa: "z" },
        { spelling: "sh", ipa: "ʃ" },
        { spelling: "h", ipa: "h" },
        { spelling: "ch", ipa: "ʧ" },
        { spelling: "m", ipa: "m" },
        { spelling: "n", ipa: "n" },
        { spelling: "ng", ipa: "ŋ" },
        { spelling: "r", ipa: "ɹ" },
        { spelling: "l", ipa: "l" },
        { spelling: "w", ipa: "w" },
        { spelling: "y", ipa: "j" },
        { spelling: "x", ipa: "ks" },
      ];

      const PRONOUNS = [
        { person: "1st", number: "singular", form: "Wio" },
        { person: "1st", number: "plural", form: "Wol" },
        { person: "2nd", number: "singular", form: "Nye" },
        { person: "2nd", number: "plural", form: "Nyeya" },
        { person: "3rd", number: "singular", form: "Sperte / Sie / Tatie" },
        { person: "3rd", number: "plural", form: "Spiten / Tatien" },
      ];

      const CASES = [
        { name: "Nominative", marker: "∅", function: "Subject" },
        { name: "Accusative", marker: "-ta", function: "Direct Object" },
        { name: "Genitive", marker: "-e", function: "Possessive" },
        { name: "Dative", marker: "k-", function: "Indirect Object / Recipient" },
        { name: "Ablative", marker: "separate phrase", function: "Source / from where" },
      ];

      const DIGITS = [
        { value: "0", word: "zu" },
        { value: "1", word: "ta" },
        { value: "2", word: "re" },
        { value: "3", word: "ki" },
        { value: "4", word: "vo" },
        { value: "5", word: "me" },
        { value: "6", word: "dal" },
        { value: "7", word: "zai" },
        { value: "8", word: "fiu" },
        { value: "9", word: "no" },
      ];

      const CONJUNCTIONS = [
        { form: "pa", meaning: "and" },
        { form: "utrez", meaning: "or (exclusive)" },
        { form: "zai", meaning: "but" },
        { form: "lunte", meaning: "then / and then" },
        { form: "bey", meaning: "because" },
        { form: "eki", meaning: "if" },
      ];

      const MONTHS = [
        { en: "January", sp: "tarul" },
        { en: "February", sp: "resur" },
        { en: "March", sp: "kilup" },
        { en: "April", sp: "votir" },
        { en: "May", sp: "meka" },
        { en: "June", sp: "xisata" },
        { en: "July", sp: "xisere" },
        { en: "August", sp: "xisiki" },
        { en: "September", sp: "dalur" },
        { en: "October", sp: "zaivim" },
        { en: "November", sp: "fiurua" },
        { en: "December", sp: "xisovo" },
      ];

      const SYLLABLE_PATTERNS = ["V", "CV", "VC", "CCV", "CCCV", "CVC", "VCC", "VCCC", "CVCC", "CVCCC", "CCVC", "CCCVC", "CCVCC"];

      const TEMPLATE_POOL = [];

      function addTemplate(fn) {
        TEMPLATE_POOL.push(fn);
      }

      function pickOptions(list, correct, count) {
        const pool = list.filter((v) => v !== correct);
        const shuffled = shuffle(pool);
        const opts = [correct, ...shuffled.slice(0, Math.max(0, count - 1))];
        return shuffle(opts);
      }

      function makeMcq(prompt, correct, options, signature, concept) {
        return { id: signature, type: "mcq", prompt, options, answer: correct, signature, concept: concept || signature };
      }

      function makeTyped(prompt, answers, signature, concept) {
        return { id: signature, type: "text", prompt, answers, signature, concept: concept || signature };
      }

      VOWELS.forEach((v) => {
        const concept = `vowel_${v.spelling}`;
        addTemplate(() => makeMcq(
          `Which spelling corresponds to IPA [${v.ipa}]?`,
          v.spelling,
          pickOptions(VOWELS.map(x => x.spelling), v.spelling, 4),
          `vowel_spell_${v.spelling}`,
          concept
        ));
        addTemplate(() => makeMcq(
          `Which IPA corresponds to spelling "${v.spelling}"?`,
          `[${v.ipa}]`,
          pickOptions(VOWELS.map(x => `[${x.ipa}]`), `[${v.ipa}]`, 4),
          `vowel_ipa_${v.spelling}`,
          concept
        ));
        addTemplate(() => makeTyped(
          `Type the IPA for spelling "${v.spelling}".`,
          [`[${v.ipa}]`, v.ipa],
          `vowel_typed_${v.spelling}`,
          concept
        ));
      });

      CONSONANTS.forEach((c) => {
        const concept = `consonant_${c.spelling}`;
        addTemplate(() => makeMcq(
          `Which IPA corresponds to spelling "${c.spelling}"?`,
          `[${c.ipa}]`,
          pickOptions(CONSONANTS.map(x => `[${x.ipa}]`), `[${c.ipa}]`, 4),
          `cons_ipa_${c.spelling}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "In Spertz, <c> before <i> is pronounced:",
        "[s]",
        ["[s]", "[k]", "[ʧ]", "[ʃ]"],
        "rule_c_before_i",
        "rule_c_before_i"
      ));

      addTemplate(() => makeTyped(
        "Type the diphthong spelling for IPA [wɑ].",
        ["ua"],
        "diphthong_ua",
        "diphthong_ua"
      ));

      addTemplate(() => makeMcq(
        "Which spelling is a contrastive length vowel?",
        "yi",
        ["yi", "ai", "au", "ua"],
        "length_vowel_yi",
        "length_vowel_yi"
      ));

      addTemplate(() => makeMcq(
        "What is the future tense marker?",
        "i- (prefix)",
        ["i- (prefix)", "-et (suffix)", "-or (suffix)", "mi (particle)"],
        "tense_future",
        "tense_future"
      ));
      addTemplate(() => makeMcq(
        "What is the past tense marker?",
        "-et (suffix)",
        ["-et (suffix)", "i- (prefix)", "-ok (suffix)", "k- (prefix)"],
        "tense_past",
        "tense_past"
      ));
      addTemplate(() => makeMcq(
        "Progressive aspect marker is:",
        "-ok",
        ["-ok", "-im", "-ul", "-en"],
        "aspect_progressive",
        "aspect_progressive"
      ));
      addTemplate(() => makeMcq(
        "Perfect/Completed aspect marker is:",
        "-im",
        ["-im", "-ok", "-ul", "-en"],
        "aspect_perfect",
        "aspect_perfect"
      ));
      addTemplate(() => makeMcq(
        "Habitual aspect marker is:",
        "-ul",
        ["-ul", "-ok", "-im", "-en"],
        "aspect_habitual",
        "aspect_habitual"
      ));
      addTemplate(() => makeMcq(
        "Iterative/Repetitive aspect marker is:",
        "-en",
        ["-en", "-ok", "-im", "-ul"],
        "aspect_iterative",
        "aspect_iterative"
      ));
      addTemplate(() => makeMcq(
        "Optative/Subjunctive mood suffix is:",
        "-el",
        ["-el", "-or", "-ok", "-et"],
        "mood_optative",
        "mood_optative"
      ));
      addTemplate(() => makeMcq(
        "Declarative/Indicative mood suffix is:",
        "-or",
        ["-or", "-el", "-ok", "-et"],
        "mood_declarative",
        "mood_declarative"
      ));
      addTemplate(() => makeMcq(
        "Negation word is:",
        "mi",
        ["mi", "zo", "pa", "k-"],
        "negation_word",
        "negation_word"
      ));
      addTemplate(() => makeMcq(
        "Topic marker is:",
        "zo",
        ["zo", "mi", "pa", "k-"],
        "topic_marker",
        "topic_marker"
      ));
      addTemplate(() => makeMcq(
        "Dynamic marker (final suffix) is:",
        "-og",
        ["-og", "-ok", "-or", "-ul"],
        "dynamic_marker",
        "dynamic_marker"
      ));
      addTemplate(() => makeMcq(
        "Direct object marker on the verb is:",
        "-ta",
        ["-ta", "-e", "k-", "zo"],
        "direct_object",
        "direct_object"
      ));
      addTemplate(() => makeMcq(
        "Genitive (possessive) suffix is:",
        "-e",
        ["-e", "-ta", "-og", "-en"],
        "genitive_marker",
        "genitive_marker"
      ));
      addTemplate(() => makeMcq(
        "Plural noun suffix is:",
        "-an",
        ["-an", "-et", "-sa", "-el"],
        "plural_marker",
        "plural_marker"
      ));
      addTemplate(() => makeMcq(
        "Adjectives must end in:",
        "a vowel",
        ["a vowel", "a consonant", "either", "a glide only"],
        "adj_endings",
        "adj_endings"
      ));
      addTemplate(() => makeMcq(
        "Nouns must end in:",
        "a consonant",
        ["a consonant", "a vowel", "either", "a glide only"],
        "noun_endings",
        "noun_endings"
      ));
      addTemplate(() => makeMcq(
        "Verbs (with no conjugation) must end in:",
        "a vowel",
        ["a vowel", "a consonant", "either", "a glide only"],
        "verb_endings",
        "verb_endings"
      ));
      addTemplate(() => makeTyped(
        "Type the dative (recipient) marker.",
        ["k-", "k"],
        "dative_typed",
        "dative_marker"
      ));

      const SUBJECT_LABELS = {
        "1sg": "1st person singular",
        "1pl": "1st person plural",
        "2sg": "2nd person singular",
        "2pl": "2nd person plural",
        "3sg": "3rd person singular",
        "3pl": "3rd person plural",
      };

      Object.keys(SUBJECT_SUFFIX).forEach((key) => {
        if (key === "omit") return;
        const suffix = SUBJECT_SUFFIX[key];
        const label = SUBJECT_LABELS[key] || key;
        const concept = `subj_${key}`;
        addTemplate(() => makeMcq(
          `Which subject suffix marks ${label}?`,
          suffix,
          pickOptions(Object.values(SUBJECT_SUFFIX).filter(v => v), suffix, 4),
          `subj_suffix_${key}`,
          concept
        ));
        addTemplate(() => makeMcq(
          `The subject suffix "${suffix}" marks:`,
          label,
          pickOptions(Object.values(SUBJECT_LABELS), label, 4),
          `subj_label_${key}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "Reflexive direct object marker is:",
        "te",
        ["te", "ta", "k-", "mi"],
        "reflexive_marker",
        "reflexive_marker"
      ));
      addTemplate(() => makeMcq(
        "Human direct object suffix (after -ta) is:",
        "sa",
        ["sa", "x", "ta", "e"],
        "human_object_suffix",
        "human_object_suffix"
      ));
      addTemplate(() => makeMcq(
        "Royal direct object suffix (after -ta) is:",
        "x",
        ["x", "sa", "ta", "e"],
        "royal_object_suffix",
        "royal_object_suffix"
      ));
      addTemplate(() => makeMcq(
        "Yes–no questions are formed by placing:",
        "zequk / ze at the beginning",
        ["zequk / ze at the beginning", "mi after the verb", "ta before the verb", "zo at the end"],
        "yesno_marker",
        "yesno_marker"
      ));
      addTemplate(() => makeMcq(
        "Negation particle mi is placed:",
        "before verbs or nouns",
        ["before verbs or nouns", "after the verb only", "as a suffix on adjectives", "before the subject"],
        "negation_placement",
        "negation_placement"
      ));

      VERBS.forEach(([verb, meaning]) => {
        const concept = `verb_def_${verb}`;
        addTemplate(() => makeMcq(
          `What does "${verb}" mean?`,
          meaning,
          pickOptions(VERBS.map(x => x[1]), meaning, 4),
          `verb_meaning_${verb}`,
          concept
        ));
        addTemplate(() => makeMcq(
          `Which verb means "${meaning}"?`,
          verb,
          pickOptions(VERBS.map(x => x[0]), verb, 4),
          `verb_form_${verb}`,
          concept
        ));
      });

      CASES.forEach((c) => {
        const concept = `case_${c.name}`;
        addTemplate(() => makeMcq(
          `Which case uses marker "${c.marker}"?`,
          c.name,
          pickOptions(CASES.map(x => x.name), c.name, 4),
          `case_marker_${c.name}`,
          concept
        ));
        addTemplate(() => makeMcq(
          `The ${c.name} case primarily marks:`,
          c.function,
          pickOptions(CASES.map(x => x.function), c.function, 4),
          `case_function_${c.name}`,
          concept
        ));
      });

      PRONOUNS.forEach((p) => {
        const concept = `pronoun_${p.person}_${p.number}`;
        addTemplate(() => makeMcq(
          `Which pronoun is ${p.person} person ${p.number}?`,
          p.form,
          pickOptions(PRONOUNS.map(x => x.form), p.form, 4),
          `pronoun_${p.person}_${p.number}`,
          concept
        ));
      });

      DIGITS.forEach((d) => {
        const concept = `digit_${d.value}`;
        addTemplate(() => makeMcq(
          `Digit word for ${d.value} (base-10) is:`,
          d.word,
          pickOptions(DIGITS.map(x => x.word), d.word, 4),
          `digit_word_${d.value}`,
          concept
        ));
        addTemplate(() => makeTyped(
          `Type the Spertz digit word for ${d.value}.`,
          [d.word],
          `digit_typed_${d.value}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "Indefinite article is:",
        "tas",
        ["tas", "zo", "mi", "pa"],
        "article_indef",
        "article_indef"
      ));
      addTemplate(() => makeMcq(
        "Definite reference is expressed using:",
        "demonstratives (this/that)",
        ["demonstratives (this/that)", "a suffix -e", "a prefix k-", "a particle mi"],
        "article_def",
        "article_def"
      ));
      addTemplate(() => makeMcq(
        "Default noun phrase order is:",
        "(Topic) + (Article) + (Number) + Noun + Adjective",
        [
          "(Topic) + (Article) + (Number) + Noun + Adjective",
          "Noun + Article + Number + Adjective",
          "Article + Noun + Adjective + Number",
          "Noun + Number + Article + Adjective"
        ],
        "noun_phrase_order",
        "noun_phrase_order"
      ));

      addTemplate(() => makeMcq(
        "Default declarative word order is:",
        "SVO",
        ["SVO", "SOV", "VSO", "OSV"],
        "word_order_decl",
        "word_order_decl"
      ));
      addTemplate(() => makeMcq(
        "Imperative word order is:",
        "SOV",
        ["SOV", "SVO", "VSO", "OSV"],
        "word_order_imp",
        "word_order_imp"
      ));

      CONJUNCTIONS.forEach((c) => {
        const concept = `conj_${c.form}`;
        addTemplate(() => makeMcq(
          `Which conjunction means "${c.meaning}"?`,
          c.form,
          pickOptions(CONJUNCTIONS.map(x => x.form), c.form, 4),
          `conj_${c.form}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "In formal writing, subclauses are enclosed with:",
        "| ... |",
        ["| ... |", "( ... )", "{ ... }", "[ ... ]"],
        "subclause_markers",
        "subclause_markers"
      ));
      addTemplate(() => makeMcq(
        "Subclauses are introduced by:",
        "an explicit subordinator",
        ["an explicit subordinator", "a case suffix", "a verb prefix", "a topic marker"],
        "subclause_intro",
        "subclause_intro"
      ));

      MONTHS.forEach((m) => {
        const concept = `month_${m.en}`;
        addTemplate(() => makeMcq(
          `Which month is "${m.sp}"?`,
          m.en,
          pickOptions(MONTHS.map(x => x.en), m.en, 4),
          `month_sp_${m.sp}`,
          concept
        ));
        addTemplate(() => makeMcq(
          `What is the Spertz name for ${m.en}?`,
          m.sp,
          pickOptions(MONTHS.map(x => x.sp), m.sp, 4),
          `month_en_${m.en}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "The star-month prefix is:",
        "xi",
        ["xi", "zo", "mi", "ta"],
        "month_prefix_xi",
        "month_prefix_xi"
      ));

      SYLLABLE_PATTERNS.forEach((p) => {
        const concept = `syllable_${p}`;
        addTemplate(() => makeMcq(
          `Is "${p}" an allowed syllable pattern in words (including names)?`,
          "Yes",
          ["Yes", "No", "Only in the south", "Only for verbs"],
          `syllable_allowed_${p}`,
          concept
        ));
      });

      addTemplate(() => makeMcq(
        "When \"y\" appears in yi/ye, it functions as:",
        "part of the vowel",
        ["part of the vowel", "a glide [j]", "a consonant stop", "a nasal"],
        "y_vowel_rule",
        "y_vowel_rule"
      ));

      addTemplate(() => makeMcq(
        "Outside yi/ye, \"y\" represents:",
        "the glide [j]",
        ["the glide [j]", "a vowel", "a click", "a nasal"],
        "y_glide_rule",
        "y_glide_rule"
      ));

      let currentQuestions = [];

      function shuffle(arr) {
        const copy = arr.slice();
        for (let i = copy.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      }

      function normalizeAnswer(text) {
        return String(text || "")
          .toLowerCase()
          .replace(/\s+/g, " ")
          .trim();
      }

      function randPick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function buildVerbForm(config) {
        const verb = config.verb;
        const subj = SUBJECT_SUFFIX[config.subj] || "";
        const obj = config.obj;
        let human = config.human;
        const tense = config.tense;
        const asp = ASPECT_SUFFIX[config.aspect] || "";
        const mood = MOOD_SUFFIX[config.mood] || "";
        const dyn = config.dynamic ? "og" : "";

        if (obj === "none" || obj === "te") human = "none";

        let base = verb;
        if (tense === "future") base = `i-${verb}`;

        let out = base;
        if (subj) out += subj;
        if (obj !== "none") out += obj;
        if (human !== "none") out += human;
        if (tense === "past") out += "et";
        if (asp) out += asp;
        if (mood) out += mood;
        if (dyn) out += dyn;

        return out;
      }

      function glossFromConfig(config) {
        const meaning = VERB_MEANING[config.verb] || "—";
        const subjEn = SUBJECT_EN[config.subj] || "(someone)";

        let aux = "";
        if (config.mood === "el") aux += "might ";
        if (config.tense === "future") aux += "will ";
        if (config.tense === "past") aux += "did ";

        let objPhrase = "";
        if (config.obj === "ta") {
          if (config.human === "sa") objPhrase = " someone";
          else if (config.human === "x") objPhrase = " (a royal person)";
          else objPhrase = " something";
        } else if (config.obj === "te") {
          objPhrase = " (oneself)";
        }

        let aspectNote = "";
        if (config.aspect === "ok") aspectNote = " (ongoing)";
        if (config.aspect === "im") aspectNote = " (completed)";
        if (config.aspect === "ul") aspectNote = " (habitually)";
        if (config.aspect === "en") aspectNote = " (repeatedly)";

        const dyn = config.dynamic ? " (dynamic)" : "";

        return `${subjEn} ${aux}${meaning}${objPhrase}${aspectNote}${dyn}`.replace(/\s+/g, " ").trim();
      }

      function randomVerbConfig() {
        const verb = randPick(VERBS)[0];
        const subj = randPick(["omit","1sg","1pl","2sg","2pl","3sg","3pl"]);
        const obj = randPick(["none", "ta", "te"]);
        const human = randPick(["none", "sa", "x"]);
        const tense = randPick(["none", "future", "past"]);
        const aspect = randPick(["none", "ok", "im", "ul", "en"]);
        const mood = randPick(["none", "or", "el"]);
        const dynamic = Math.random() < 0.4;

        return { verb, subj, obj, human, tense, aspect, mood, dynamic };
      }

      function makeConjugationQuestion() {
        const config = randomVerbConfig();
        const form = buildVerbForm(config);
        const gloss = glossFromConfig(config);

        const mode = randPick(["form_from_gloss", "gloss_from_form"]);
        if (mode === "form_from_gloss") {
          const prompt = `Choose the correct Spertz verb form for: "${gloss}"`;
          const correct = form;
          const options = new Set([correct]);
          while (options.size < 4) {
            const altConfig = { ...config };
            const tweak = randPick(["tense","aspect","mood","obj","subj","dynamic"]);
            if (tweak === "tense") altConfig.tense = randPick(["none","future","past"]);
            if (tweak === "aspect") altConfig.aspect = randPick(["none","ok","im","ul","en"]);
            if (tweak === "mood") altConfig.mood = randPick(["none","or","el"]);
            if (tweak === "obj") altConfig.obj = randPick(["none","ta","te"]);
            if (tweak === "subj") altConfig.subj = randPick(["omit","1sg","1pl","2sg","2pl","3sg","3pl"]);
            if (tweak === "dynamic") altConfig.dynamic = !altConfig.dynamic;
            const altForm = buildVerbForm(altConfig);
            if (altForm !== correct) options.add(altForm);
          }
        return {
          id: `conj_form_${form}_${config.verb}`,
          type: "mcq",
          prompt,
          options: shuffle(Array.from(options)),
          answer: correct,
          signature: `form|${form}|${gloss}`,
          concept: `conj_form|${form}|${gloss}`,
        };
        }

        const prompt = `Choose the correct gloss for: "${form}"`;
        const correct = gloss;
        const options = new Set([correct]);
        while (options.size < 4) {
          const altConfig = { ...config };
          const tweak = randPick(["tense","aspect","mood","obj","subj","dynamic"]);
          if (tweak === "tense") altConfig.tense = randPick(["none","future","past"]);
          if (tweak === "aspect") altConfig.aspect = randPick(["none","ok","im","ul","en"]);
          if (tweak === "mood") altConfig.mood = randPick(["none","or","el"]);
          if (tweak === "obj") altConfig.obj = randPick(["none","ta","te"]);
          if (tweak === "subj") altConfig.subj = randPick(["omit","1sg","1pl","2sg","2pl","3sg","3pl"]);
          if (tweak === "dynamic") altConfig.dynamic = !altConfig.dynamic;
          const altGloss = glossFromConfig(altConfig);
          if (altGloss !== correct) options.add(altGloss);
        }
        return {
          id: `conj_gloss_${form}_${config.verb}`,
          type: "mcq",
          prompt,
          options: shuffle(Array.from(options)),
          answer: correct,
          signature: `gloss|${form}|${gloss}`,
          concept: `conj_gloss|${form}|${gloss}`,
        };
      }

      function renderQuiz(count) {
        quizArea.innerHTML = "";
        quizScore.style.display = "none";
        quizScore.textContent = "";

        const n = Math.max(1, Math.min(10, count));
        currentQuestions = [];
        const used = new Set();
        const sources = TEMPLATE_POOL.concat([
          makeConjugationQuestion,
          makeConjugationQuestion,
          makeConjugationQuestion,
          makeConjugationQuestion,
        ]);

        let attempts = 0;
        while (currentQuestions.length < n && attempts < 200) {
          attempts++;
          const source = randPick(sources);
          const q = typeof source === "function" ? source() : source;
          const key = q.concept || q.signature || q.id;
          if (used.has(key)) continue;
          used.add(key);
          currentQuestions.push(q);
        }

        currentQuestions.forEach((q, idx) => {
          const card = document.createElement("div");
          card.className = "quiz-card";
          card.dataset.qid = q.id;

          const title = document.createElement("h4");
          title.textContent = `Q${idx + 1}. ${q.prompt}`;
          card.appendChild(title);

          if (q.type === "mcq") {
            const opts = document.createElement("div");
            opts.className = "quiz-options";
            q.options.forEach((opt, optIdx) => {
              const label = document.createElement("label");
              label.className = "quiz-option";

              const input = document.createElement("input");
              input.type = "radio";
              input.name = `q_${idx}`;
              input.value = opt;
              input.id = `q_${idx}_${optIdx}`;

              const span = document.createElement("span");
              span.textContent = opt;

              label.appendChild(input);
              label.appendChild(span);
              opts.appendChild(label);
            });
            card.appendChild(opts);
          } else {
            const input = document.createElement("input");
            input.type = "text";
            input.className = "quiz-input";
            input.placeholder = "Type your answer...";
            input.name = `q_${idx}`;
            card.appendChild(input);
          }

          const result = document.createElement("div");
          result.className = "quiz-result";
          result.style.display = "none";
          card.appendChild(result);

          const answer = document.createElement("div");
          answer.className = "quiz-answer";
          answer.style.display = "none";
          card.appendChild(answer);

          quizArea.appendChild(card);
        });
      }

      function gradeQuiz() {
        let correct = 0;
        const cards = quizArea.querySelectorAll(".quiz-card");

        cards.forEach((card, idx) => {
          const q = currentQuestions[idx];
          const result = card.querySelector(".quiz-result");
          const answer = card.querySelector(".quiz-answer");

          let userAnswer = "";
          if (q.type === "mcq") {
            const checked = card.querySelector(`input[name="q_${idx}"]:checked`);
            userAnswer = checked ? checked.value : "";
          } else {
            const input = card.querySelector(`input[name="q_${idx}"]`);
            userAnswer = input ? input.value : "";
          }

          let isCorrect = false;
          if (q.type === "mcq") {
            isCorrect = userAnswer === q.answer;
          } else {
            const normalized = normalizeAnswer(userAnswer);
            isCorrect = q.answers.some((a) => normalizeAnswer(a) === normalized);
          }

          if (isCorrect) correct += 1;

          result.style.display = "";
          result.textContent = isCorrect ? "Correct ✅" : "Incorrect ✗";

          answer.style.display = "";
          if (q.type === "mcq") {
            answer.textContent = `Answer: ${q.answer}`;
          } else {
            answer.textContent = `Answer: ${q.answers[0]}`;
          }
        });

        quizScore.style.display = "";
        quizScore.textContent = `Score: ${correct} / ${currentQuestions.length}`;
      }

      quizGenerate.addEventListener("click", () => {
        const count = parseInt(quizCount.value, 10) || 5;
        renderQuiz(count);
      });

      quizSubmit.addEventListener("click", () => {
        if (!currentQuestions.length) {
          renderQuiz(parseInt(quizCount.value, 10) || 5);
        }
        gradeQuiz();
      });

      renderQuiz(parseInt(quizCount.value, 10) || 5);
    })();

    // ===== SPERTZ Personality Test (96 Types) =====
    (function () {
      const questionsWrap = document.getElementById("personalityQuestions");
      const submitBtn = document.getElementById("personalitySubmit");
      const resetBtn = document.getElementById("personalityReset");
      const resultsBox = document.getElementById("personalityResults");

      if (!questionsWrap || !submitBtn || !resetBtn || !resultsBox) return;

      const QUESTIONS = [
        { text: "A stranger drops a wallet in front of you. You expect them to come back for it.", weights: { D: 1, B: -1 } },
        { text: "You’re offered a deal that sounds too good to be true. You assume there’s a catch.", weights: { B: 1, D: -1 } },
        { text: "You ask for help in a new town; you believe most people will point you the right way.", weights: { D: 1, B: -1 } },
        { text: "When someone apologizes, you assume it’s partly about saving face.", weights: { B: 1, D: -1 } },
        { text: "At a group project, you expect people to pull their weight without being chased.", weights: { D: 1, B: -1 } },
        { text: "If you hear gossip, you assume there’s more manipulation than truth.", weights: { B: 1, D: -1 } },
        { text: "You lend things easily because you expect them to be returned.", weights: { D: 1, B: -1 } },
        { text: "When two people clash, you assume someone is trying to control the other.", weights: { B: 1, D: -1 } },
        { text: "A friend makes a mistake; you bounce back to trust quickly.", weights: { D: 1, B: -1 } },
        { text: "You keep a safety buffer because people can be unpredictable.", weights: { B: 1, D: -1 } },

        { text: "You have free time on a weekend; your first instinct is to check on family.", weights: { O: 1, W: -1 } },
        { text: "You’d skip a family event to show up for a close friend in need.", weights: { L: 1, O: -1 } },
        { text: "If your partner needs you, you rearrange everything.", weights: { N: 1, L: -1 } },
        { text: "You protect your personal goals even when others want more of you.", weights: { W: 1, O: -1 } },
        { text: "You feel responsible for keeping your family grounded.", weights: { O: 1, N: -1 } },
        { text: "You feel most loyal to the people you chose, not the ones you were born with.", weights: { L: 1, W: -1 } },
        { text: "You want a life that revolves around your partner’s well-being too.", weights: { N: 1, W: -1 } },
        { text: "You prefer to be self-reliant even if it means less closeness.", weights: { W: 1, L: -1 } },
        { text: "If a move benefits family, you’d take the risk.", weights: { O: 1, W: -1 } },
        { text: "Your closest friendships are the center of your life.", weights: { L: 1, O: -1 } },
        { text: "You see your romantic relationship as your main home base.", weights: { N: 1, L: -1 } },
        { text: "You want space that is fully yours, no matter who you love.", weights: { W: 1, N: -1 } },
        { text: "When you share good news, your partner is the first person you call.", weights: { N: 1, O: -1 } },
        { text: "Your friends shape your identity more than family does.", weights: { L: 1, N: -1 } },
        { text: "You keep boundaries even when people ask for more closeness.", weights: { W: 1, O: -1 } },
        { text: "Traditions and family rituals feel like a foundation.", weights: { O: 1, L: -1 } },

        { text: "You’d take a lower-paying role if it aligned with your purpose.", weights: { K: 1, Z: -1 } },
        { text: "You track success by the results you can point to.", weights: { Z: 1, K: -1 } },
        { text: "If a project is meaningful, you can tolerate slower progress.", weights: { K: 1, Z: -1 } },
        { text: "You judge plans by what they deliver, not by their symbolism.", weights: { Z: 1, K: -1 } },
        { text: "You feel most successful when you’re at peace inside.", weights: { K: 1, Z: -1 } },
        { text: "Clear metrics motivate you more than abstract ideals.", weights: { Z: 1, K: -1 } },
        { text: "You would rather live meaningfully than comfortably.", weights: { K: 1, Z: -1 } },
        { text: "If something doesn’t work, you change it—meaning or not.", weights: { Z: 1, K: -1 } },

        { text: "When solving a problem, you pick one direction and go deep.", weights: { P: 1, A: -1 } },
        { text: "When stuck, you map out every possibility you can think of.", weights: { A: 1, P: -1 } },
        { text: "You prefer a clear plan over a big brainstorm.", weights: { P: 1, A: -1 } },
        { text: "You keep several options open until the last responsible moment.", weights: { A: 1, P: -1 } },
        { text: "You’d rather refine one good idea than chase many.", weights: { P: 1, A: -1 } },
        { text: "Your best ideas come from wild exploration first.", weights: { A: 1, P: -1 } },
        { text: "You trust steady progress more than creative detours.", weights: { P: 1, A: -1 } },
        { text: "You think in webs, not straight lines.", weights: { A: 1, P: -1 } },

        { text: "When choices are tough, you prioritize excellence and output.", weights: { S: 1, I: -1 } },
        { text: "You slow down decisions to protect people’s feelings.", weights: { I: 1, S: -1 } },
        { text: "How the process feels to you matters as much as the outcome.", weights: { E: 1, S: -1 } },
        { text: "You’d rather be effective than widely liked.", weights: { S: 1, I: -1 } },
        { text: "You’d rather be considerate than fast.", weights: { I: 1, S: -1 } },
        { text: "You pick projects that feel meaningful and immersive.", weights: { E: 1, S: -1 } },
        { text: "High standards come before comfort.", weights: { S: 1, I: -1 } },
        { text: "You adjust to people first and plans second.", weights: { I: 1, E: -1 } },
        { text: "You choose experiences that feel personal and vivid.", weights: { E: 1, I: -1 } },
        { text: "If it’s worth doing, it must be done well.", weights: { S: 1, E: -1 } },
        { text: "Harmony is a better success signal than speed.", weights: { I: 1, S: -1 } },
        { text: "You notice the atmosphere before the checklist.", weights: { E: 1, S: -1 } },

        { text: "You trust people, but you still verify the facts.", weights: { D: 1, Z: 1 } },
        { text: "You favor big visions even if they take time to land.", weights: { A: 1, K: 1 } },
        { text: "You stay loyal to family but won’t erase your own path.", weights: { O: 1, W: 1 } },
        { text: "You care about people and still want strong results.", weights: { I: 1, S: 1 } },
        { text: "You lean on your partner for balance and perspective.", weights: { N: 1, D: 1 } },
        { text: "Your closest friends are your main support system.", weights: { L: 1, D: 1 } },
      ];

      const LIKERT_LABELS = [
        "Strongly Disagree",
        "Disagree",
        "Slightly Disagree",
        "Neutral",
        "Slightly Agree",
        "Agree",
        "Strongly Agree",
      ];

      const LABELS = {
        D: "People are kind",
        B: "People are evil",
        O: "Family focus",
        L: "Friends focus",
        N: "Lover focus",
        W: "Self focus",
        K: "Spiritual success",
        Z: "Practical success",
        P: "One-direction solver",
        A: "Big brainstorm solver",
        S: "Get it done",
        I: "Consider everyone",
        E: "Experience first",
      };

      const DESC = {
        D: "Trusting and optimistic about people.",
        B: "Cautious and realistic about human motives.",
        O: "Family-centered and protective of kinship bonds.",
        L: "Friend-centered and loyal to chosen community.",
        N: "Romance-centered and invested in partnership.",
        W: "Self-centered in a healthy way, valuing independence.",
        K: "Driven by meaning, purpose, and inner growth.",
        Z: "Driven by results, structure, and tangible progress.",
        P: "Linear problem-solver who commits early.",
        A: "Expansive problem-solver who explores options.",
        S: "Execution-first with high standards.",
        I: "People-first with strong empathy.",
        E: "Experience-first with strong sense of feel.",
      };

      const STRENGTH = {
        D: "builds trust quickly",
        B: "spots risks early",
        O: "anchors family stability",
        L: "nurtures community",
        N: "invests deeply in partnership",
        W: "maintains strong self-direction",
        K: "keeps purpose in view",
        Z: "drives tangible outcomes",
        P: "executes with focus",
        A: "generates creative options",
        S: "delivers reliably",
        I: "protects group harmony",
        E: "keeps experiences meaningful",
      };

      const WATCH = {
        D: "may overlook red flags",
        B: "can become guarded",
        O: "may neglect wider circles",
        L: "may under-prioritize family duties",
        N: "may overinvest in romance",
        W: "may isolate when stressed",
        K: "may drift from practical needs",
        Z: "may downplay meaning",
        P: "may miss alternatives",
        A: "may overcomplicate",
        S: "may seem blunt",
        I: "may slow decisions",
        E: "may chase novelty",
      };

      function buildTypeMap() {
        const map = {};
        const dAxis = ["D", "B"];
        const focus = ["O", "L", "N", "W"];
        const success = ["K", "Z"];
        const solve = ["P", "A"];
        const care = ["S", "I", "E"];

        dAxis.forEach((d) => {
          focus.forEach((f) => {
            success.forEach((s) => {
              solve.forEach((p) => {
                care.forEach((c) => {
                  const type = `${d}${f}${s}${p}${c}`;
                  const summary = `${DESC[d]} ${DESC[f]} ${DESC[s]} ${DESC[p]} ${DESC[c]}`;
                  const strengths = [STRENGTH[d], STRENGTH[f], STRENGTH[s], STRENGTH[p], STRENGTH[c]];
                  const watchouts = [WATCH[d], WATCH[f], WATCH[s], WATCH[p], WATCH[c]];
                  map[type] = { summary, strengths, watchouts };
                });
              });
            });
          });
        });
        return map;
      }

      const TYPE_MAP = buildTypeMap();
      let lastCardCanvas = null;

      function renderQuestions() {
        questionsWrap.innerHTML = "";
        QUESTIONS.forEach((q, idx) => {
          const card = document.createElement("div");
          card.className = "personality-card";

          const title = document.createElement("h4");
          title.textContent = `Q${idx + 1}. ${q.text}`;
          card.appendChild(title);

          const row = document.createElement("div");
          row.className = "likert-row";

          LIKERT_LABELS.forEach((label, i) => {
            const val = i + 1;
            const wrap = document.createElement("label");
            wrap.className = "likert-option";

            const input = document.createElement("input");
            input.type = "radio";
            input.name = `pt_q_${idx}`;
            input.value = String(val);

            const text = document.createElement("span");
            text.textContent = label;

            wrap.appendChild(input);
            wrap.appendChild(text);
            row.appendChild(wrap);
          });

          card.appendChild(row);
          questionsWrap.appendChild(card);
        });
      }

      function normalizeGroup(scores, maxByLetter, letters) {
        const raw = letters.map((l) => {
          const max = maxByLetter[l] || 0;
          if (max <= 0) return 0.5;
          const z = (scores[l] || 0) / max; // -1..1
          return Math.max(0, Math.min(1, (z + 1) / 2));
        });
        let total = raw.reduce((a, b) => a + b, 0);
        if (total === 0) {
          total = raw.length;
          for (let i = 0; i < raw.length; i++) raw[i] = 1;
        }
        const scaled = raw.map((v) => (v / total) * 100);
        const rounded = scaled.map((v) => Math.round(v));
        const diff = 100 - rounded.reduce((a, b) => a + b, 0);
        if (diff !== 0) {
          let maxIdx = 0;
          for (let i = 1; i < scaled.length; i++) {
            if (scaled[i] > scaled[maxIdx]) maxIdx = i;
          }
          rounded[maxIdx] += diff;
        }
        const out = {};
        letters.forEach((l, i) => { out[l] = rounded[i]; });
        return out;
      }

      function pickMax(scores, letters) {
        let best = letters[0];
        letters.forEach((l) => {
          if ((scores[l] || 0) > (scores[best] || 0)) best = l;
        });
        return best;
      }

      function barPairHtml(left, right, perc) {
        return `
          <div class="result-block">
            <div class="result-row">
              <div class="result-row-header">
                <span>${left} — ${LABELS[left]}</span>
                <span>${perc[left]}% / ${perc[right]}%</span>
              </div>
              <div class="result-bar"><span style="left:0; width:${perc[left]}%;"></span></div>
              <div class="result-row-header">
                <span>${left}</span>
                <span>${right}</span>
              </div>
            </div>
          </div>
        `;
      }

      function barMultiHtml(title, perc, letters) {
        const rows = letters.map((l) => `
          <div class="result-row">
            <div class="result-row-header">
              <span>${l} — ${LABELS[l]}</span>
              <span>${perc[l]}%</span>
            </div>
            <div class="result-bar"><span style="left:0; width:${perc[l]}%;"></span></div>
          </div>
        `).join("");
        return `
          <div class="result-block">
            <div class="result-row-header"><span>${title}</span><span></span></div>
            ${rows}
          </div>
        `;
      }

      function topLetters(perc, letters, n) {
        return letters
          .map((l) => ({ l, v: perc[l] }))
          .sort((a, b) => b.v - a.v)
          .slice(0, n);
      }

      function getThemeVar(name, fallback) {
        const val = getComputedStyle(document.body).getPropertyValue(name).trim();
        return val || fallback;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let yy = y;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + " ";
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x, yy);
            line = words[i] + " ";
            yy += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, yy);
        return yy + lineHeight;
      }

      function drawBar(ctx, x, y, w, h, perc, colorBg, colorFill) {
        ctx.fillStyle = colorBg;
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = colorFill;
        ctx.fillRect(x, y, Math.max(0, Math.min(1, perc / 100)) * w, h);
      }

      function buildCardCanvas(data) {
        const canvas = document.createElement("canvas");
        canvas.width = 900;
        canvas.height = 560;
        const ctx = canvas.getContext("2d");

        const bg = getThemeVar("--bg-2", "#15182a");
        const surface = getThemeVar("--surface", "rgba(255,255,255,0.06)");
        const text = getThemeVar("--text", "#e8e8e8");
        const heading = getThemeVar("--heading", "#ffffff");
        const accent = getThemeVar("--accent", "#c6a664");
        const accent2 = getThemeVar("--accent-2", "#9bc1ff");
        const barBg = getThemeVar("--surface-dark", "rgba(0,0,0,0.25)");

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = surface;
        ctx.fillRect(24, 24, canvas.width - 48, canvas.height - 48);

        ctx.fillStyle = heading;
        ctx.font = "700 28px serif";
        ctx.fillText("SPERTZ Personality Card", 48, 70);

        ctx.fillStyle = accent2;
        ctx.font = "700 46px serif";
        ctx.fillText(data.type, 48, 125);

        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        let yy = wrapText(ctx, data.summary, 48, 160, 520, 22);

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Top focus", 48, yy + 10);
        ctx.fillStyle = text;
        ctx.font = "14px sans-serif";
        const focusText = data.focusTop.map((t) => `${t.l} (${t.v}%)`).join(" · ");
        ctx.fillText(focusText, 48, yy + 32);

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Care style", 48, yy + 60);
        ctx.fillStyle = text;
        ctx.font = "14px sans-serif";
        const careText = data.careTop.map((t) => `${t.l} (${t.v}%)`).join(" · ");
        ctx.fillText(careText, 48, yy + 82);

        const startX = 560;
        let barY = 120;
        const barW = 280;
        const barH = 12;

        ctx.fillStyle = heading;
        ctx.font = "600 14px sans-serif";
        ctx.fillText(`D (${data.pairDB.D}%) vs B (${data.pairDB.B}%)`, startX, barY - 10);
        drawBar(ctx, startX, barY, barW, barH, data.pairDB.D, barBg, accent2);
        barY += 50;

        ctx.fillStyle = heading;
        ctx.fillText(`K (${data.pairKZ.K}%) vs Z (${data.pairKZ.Z}%)`, startX, barY - 10);
        drawBar(ctx, startX, barY, barW, barH, data.pairKZ.K, barBg, accent);
        barY += 50;

        ctx.fillStyle = heading;
        ctx.fillText(`P (${data.pairPA.P}%) vs A (${data.pairPA.A}%)`, startX, barY - 10);
        drawBar(ctx, startX, barY, barW, barH, data.pairPA.P, barBg, accent2);
        barY += 50;

        ctx.fillStyle = heading;
        ctx.fillText("Focus group", startX, barY - 10);
        const focusKeys = ["O", "L", "N", "W"];
        focusKeys.forEach((k, i) => {
          const y = barY + i * 26;
          ctx.fillStyle = text;
          ctx.fillText(`${k} ${data.groupFocus[k]}%`, startX, y + 10);
          drawBar(ctx, startX + 60, y + 2, barW - 60, 8, data.groupFocus[k], barBg, accent2);
        });
        barY += 120;

        ctx.fillStyle = heading;
        ctx.fillText("Care style", startX, barY - 10);
        const careKeys = ["S", "I", "E"];
        careKeys.forEach((k, i) => {
          const y = barY + i * 26;
          ctx.fillStyle = text;
          ctx.fillText(`${k} ${data.groupSIE[k]}%`, startX, y + 10);
          drawBar(ctx, startX + 60, y + 2, barW - 60, 8, data.groupSIE[k], barBg, accent);
        });

        return canvas;
      }

      function concatBytes(chunks) {
        let total = 0;
        chunks.forEach((c) => { total += c.length; });
        const out = new Uint8Array(total);
        let offset = 0;
        chunks.forEach((c) => {
          out.set(c, offset);
          offset += c.length;
        });
        return out;
      }

      function buildPdfFromJpeg(jpegBytes, width, height) {
        const enc = new TextEncoder();
        const chunks = [];
        let offset = 0;
        const xref = [];

        function pushStr(s) {
          const b = enc.encode(s);
          chunks.push(b);
          offset += b.length;
        }
        function pushBytes(b) {
          chunks.push(b);
          offset += b.length;
        }

        pushStr("%PDF-1.3\n");
        xref.push(offset); pushStr("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
        xref.push(offset); pushStr("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
        xref.push(offset); pushStr(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`);
        xref.push(offset); pushStr(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`);
        pushBytes(jpegBytes);
        pushStr("\nendstream\nendobj\n");
        const content = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        const contentBytes = enc.encode(content);
        xref.push(offset); pushStr(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
        pushBytes(contentBytes);
        pushStr("\nendstream\nendobj\n");

        const xrefStart = offset;
        pushStr("xref\n0 6\n0000000000 65535 f \n");
        xref.forEach((pos) => {
          const line = String(pos).padStart(10, "0") + " 00000 n \n";
          pushStr(line);
        });
        pushStr(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`);
        return concatBytes(chunks);
      }

      function downloadPng() {
        if (!lastCardCanvas) return;
        const link = document.createElement("a");
        link.download = "spertz-personality-card.png";
        link.href = lastCardCanvas.toDataURL("image/png");
        link.click();
      }

      function downloadPdf() {
        if (!lastCardCanvas) return;
        const dataUrl = lastCardCanvas.toDataURL("image/jpeg", 0.92);
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const pdfBytes = buildPdfFromJpeg(bytes, lastCardCanvas.width, lastCardCanvas.height);
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "spertz-personality-card.pdf";
        link.click();
        URL.revokeObjectURL(url);
      }

      function calculate() {
        const scores = {
          D: 0, B: 0, O: 0, L: 0, N: 0, W: 0, K: 0, Z: 0, P: 0, A: 0, S: 0, I: 0, E: 0
        };
        const maxByLetter = {
          D: 0, B: 0, O: 0, L: 0, N: 0, W: 0, K: 0, Z: 0, P: 0, A: 0, S: 0, I: 0, E: 0
        };

        let answered = 0;
        const unanswered = [];

        QUESTIONS.forEach((q, idx) => {
          const checked = document.querySelector(`input[name="pt_q_${idx}"]:checked`);
          if (!checked) {
            unanswered.push(idx);
            return;
          }
          answered += 1;
          const val = parseInt(checked.value, 10) - 4; // -3..3
          Object.entries(q.weights).forEach(([letter, weight]) => {
            scores[letter] += val * weight;
            maxByLetter[letter] += Math.abs(weight) * 3;
          });
        });

        if (unanswered.length) {
          resultsBox.style.display = "";
          const list = unanswered.map((i) => i + 1).slice(0, 8).join(", ");
          const more = unanswered.length > 8 ? ` (+${unanswered.length - 8} more)` : "";
          resultsBox.innerHTML = `
            <div class="personality-card">
              <h3 style="margin:0;">Complete all questions</h3>
              <p class="mini-note" style="margin-top:8px;">
                Please answer every question to see results. Unanswered: ${list}${more}
              </p>
            </div>
          `;
          resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
          const firstMissing = document.querySelector(`input[name="pt_q_${unanswered[0]}"]`);
          if (firstMissing) {
            firstMissing.closest(".personality-card")?.scrollIntoView({ behavior: "smooth", block: "center" });
            firstMissing.focus({ preventScroll: true });
          }
          return;
        }

        const pairDB = normalizeGroup(scores, maxByLetter, ["D", "B"]);
        const groupFocus = normalizeGroup(scores, maxByLetter, ["O", "L", "N", "W"]);
        const pairKZ = normalizeGroup(scores, maxByLetter, ["K", "Z"]);
        const pairPA = normalizeGroup(scores, maxByLetter, ["P", "A"]);
        const groupSIE = normalizeGroup(scores, maxByLetter, ["S", "I", "E"]);

        const type =
          pickMax(scores, ["D", "B"]) +
          pickMax(scores, ["O", "L", "N", "W"]) +
          pickMax(scores, ["K", "Z"]) +
          pickMax(scores, ["P", "A"]) +
          pickMax(scores, ["S", "I", "E"]);

        const info = TYPE_MAP[type];
        const missing = QUESTIONS.length - answered;

        resultsBox.style.display = "";
        resultsBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Your type: ${type}</h3>
            <p class="mini-note" style="margin-top:8px;">${info.summary}</p>
            ${missing > 0 ? `<p class="mini-note" style="margin-top:6px;">Note: ${missing} unanswered question(s) were skipped.</p>` : ""}
            <div class="result-pills" style="margin-top:10px;">
              ${info.strengths.map((s) => `<span class="result-pill">Strength: ${s}</span>`).join("")}
              ${info.watchouts.map((s) => `<span class="result-pill">Watch-out: ${s}</span>`).join("")}
            </div>
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Download your card</h4>
            <p class="mini-note" style="margin-top:8px;">
              Save a small result card as a PNG or PDF.
            </p>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button id="personalityDownloadPng" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PNG</span>
                <span class="acc-icon">⬇</span>
              </button>
              <button id="personalityDownloadPdf" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PDF</span>
                <span class="acc-icon">⬇</span>
              </button>
            </div>
          </div>
          ${barPairHtml("D", "B", pairDB)}
          ${barMultiHtml("Focus group", groupFocus, ["O", "L", "N", "W"])}
          ${barPairHtml("K", "Z", pairKZ)}
          ${barPairHtml("P", "A", pairPA)}
          ${barMultiHtml("Care style", groupSIE, ["S", "I", "E"])}
        `;
        const focusTop = topLetters(groupFocus, ["O", "L", "N", "W"], 2);
        const careTop = topLetters(groupSIE, ["S", "I", "E"], 2);
        lastCardCanvas = buildCardCanvas({
          type,
          summary: info.summary,
          pairDB,
          pairKZ,
          pairPA,
          groupFocus,
          groupSIE,
          focusTop,
          careTop,
        });
        resultsBox.querySelector("#personalityDownloadPng")?.addEventListener("click", downloadPng);
        resultsBox.querySelector("#personalityDownloadPdf")?.addEventListener("click", downloadPdf);
        resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      function resetAll() {
        document.querySelectorAll('#personalityQuestions input[type="radio"]').forEach((input) => {
          input.checked = false;
        });
        resultsBox.style.display = "none";
        resultsBox.innerHTML = "";
      }

      submitBtn.addEventListener("click", calculate);
      resetBtn.addEventListener("click", resetAll);

      renderQuestions();
    })();

    // ===== Animal Match Quiz =====
    (function () {
      const questionsWrap = document.getElementById("animalQuizQuestions");
      const submitBtn = document.getElementById("animalQuizSubmit");
      const resetBtn = document.getElementById("animalQuizReset");
      const resultsBox = document.getElementById("animalQuizResults");
      const guideToggle = document.getElementById("animalGuideToggle");
      const guideBox = document.getElementById("animalGuide");
      const shareInput = document.getElementById("animalShareCode");
      const shareApplyBtn = document.getElementById("animalShareApply");
      const shareClearBtn = document.getElementById("animalShareClear");
      const shareStatus = document.getElementById("animalShareStatus");
      const portraitMode = document.getElementById("animalPortraitMode");
      const shareCode = document.getElementById("shareCode");
      const shareApply = document.getElementById("shareApply");
      const characterShareStatus = document.getElementById("shareStatus");
      const fullNameOut = document.getElementById("fullNameOut");
      const portraitCanvas = document.getElementById("portraitCanvas");
      const illustratedPortrait = document.getElementById("illustratedPortrait");
      const drawBackHair = document.getElementById("drawBackHair");
      const drawBody = document.getElementById("drawBody");
      const drawNose = document.getElementById("drawNose");
      const drawEyes = document.getElementById("drawEyes");
      const drawEyeTint = document.getElementById("drawEyeTint");
      const drawWink = document.getElementById("drawWink");
      const drawClosed = document.getElementById("drawClosed");
      const drawPupil = document.getElementById("drawPupil");
      const drawBrows = document.getElementById("drawBrows");
      const drawMouth = document.getElementById("drawMouth");
      const drawFrontHair = document.getElementById("drawFrontHair");
      const drawTemples = document.getElementById("drawTemples");
      const drawBraids = document.getElementById("drawBraids");
      const drawOutfit = document.getElementById("drawOutfit");
      const drawAccessory = document.getElementById("drawAccessory");
      const skinSelect = document.getElementById("skinColor");
      const hairSelect = document.getElementById("hairColor");
      const eyeSelect = document.getElementById("leftEyeColor");
      const outfitSelect = document.getElementById("outfitColor");
      const genderSelect = document.getElementById("genderStyle");

      if (!questionsWrap || !submitBtn || !resetBtn || !resultsBox) return;

      const TRAITS = {
        BOLD: "Bold",
        GENTLE: "Gentle",
        SOCIAL: "Social",
        IND: "Independent",
        CUR: "Curious",
        DISC: "Disciplined",
        MYST: "Mystic",
        PLAY: "Playful",
      };

      const QUESTIONS = [
        { text: "You see an unknown trail and want to explore it right away.", weights: { CUR: 1, BOLD: 1 } },
        { text: "You’d rather observe first before acting.", weights: { DISC: 1, BOLD: -1 } },
        { text: "At a gathering, you naturally move between groups and talk.", weights: { SOCIAL: 1 } },
        { text: "You recharge best when you’re on your own.", weights: { IND: 1, SOCIAL: -1 } },
        { text: "You notice subtle moods and hidden meanings quickly.", weights: { MYST: 1, CUR: 1 } },
        { text: "You keep playful energy even in serious moments.", weights: { PLAY: 1 } },
        { text: "You prefer steady routines to big surprises.", weights: { DISC: 1, CUR: -1 } },
        { text: "You defend what matters even if it’s risky.", weights: { BOLD: 1 } },
        { text: "You are gentle in the way you handle fragile things.", weights: { GENTLE: 1 } },
        { text: "You like small circles over large crowds.", weights: { IND: 1, SOCIAL: -1 } },

        { text: "You feel more alive when learning something new.", weights: { CUR: 1 } },
        { text: "You keep your emotions soft and calm around others.", weights: { GENTLE: 1 } },
        { text: "You move fast when a goal matters to you.", weights: { BOLD: 1, DISC: 1 } },
        { text: "You like to be the spark that makes people laugh.", weights: { PLAY: 1, SOCIAL: 1 } },
        { text: "You trust your instincts more than external rules.", weights: { IND: 1, DISC: -1 } },
        { text: "You’re drawn to myths, legends, or the unknown.", weights: { MYST: 1 } },
        { text: "You protect your energy and don’t overcommit.", weights: { IND: 1 } },
        { text: "You prefer harmony and kindness in most situations.", weights: { GENTLE: 1, SOCIAL: 1 } },
        { text: "You like to master a craft with patience.", weights: { DISC: 1 } },
        { text: "You are happiest when you can roam freely.", weights: { IND: 1, CUR: 1 } },

        { text: "You prefer to lead from the front.", weights: { BOLD: 1 } },
        { text: "You are energized by teamwork.", weights: { SOCIAL: 1 } },
        { text: "You tend to playfully challenge your friends.", weights: { PLAY: 1, BOLD: 1 } },
        { text: "You feel most comfortable in quiet, safe spaces.", weights: { GENTLE: 1, IND: 1 } },
        { text: "You like deep conversations more than small talk.", weights: { MYST: 1, SOCIAL: -1 } },
        { text: "You push through obstacles with steady discipline.", weights: { DISC: 1 } },
        { text: "You enjoy being admired for your style or grace.", weights: { GENTLE: 1, SOCIAL: 1 } },
        { text: "You test boundaries to see what is possible.", weights: { BOLD: 1, CUR: 1 } },
        { text: "You adapt quickly to new environments.", weights: { CUR: 1, SOCIAL: 1 } },
        { text: "You prefer a clean, ordered plan.", weights: { DISC: 1 } },

        { text: "You can be mysterious even to people close to you.", weights: { MYST: 1, IND: 1 } },
        { text: "You feel protective of the people you care about.", weights: { BOLD: 1, GENTLE: 1 } },
        { text: "You turn stressful moments into something playful.", weights: { PLAY: 1 } },
        { text: "You prefer deep loyalty to wide popularity.", weights: { IND: 1, SOCIAL: -1 } },
      ];

      const ANIMALS = [
        { name: "Cat", traits: { IND: 1, CUR: 0.8, GENTLE: 0.4, MYST: 0.3 } ,
          desc: "Quietly confident, agile, and selective with trust. You move on your own rhythm and spot details others miss." },
        { name: "Tiger", traits: { BOLD: 1, IND: 0.7, DISC: 0.4, MYST: 0.2 },
          desc: "Focused and powerful, with a solitary strength. You prefer precision, presence, and impact." },
        { name: "Owl", traits: { MYST: 0.9, DISC: 0.6, IND: 0.4, CUR: 0.5 },
          desc: "Observant, calm, and quietly wise. You notice patterns and choose your words carefully." },
        { name: "Red Panda", traits: { PLAY: 0.8, GENTLE: 0.7, IND: 0.4, CUR: 0.4 },
          desc: "Warm, quirky, and affectionate in bursts. You bring softness and charm wherever you go." },
        { name: "Dragon", traits: { BOLD: 1, MYST: 0.9, IND: 0.6, DISC: 0.4 },
          desc: "Mythic, commanding, and visionary. You carry big energy and protect what you value." },
        { name: "Dog", traits: { SOCIAL: 1, GENTLE: 0.7, PLAY: 0.6, BOLD: 0.3 },
          desc: "Loyal, warm, and grounding. You thrive in connection and make others feel safe." },
        { name: "Rabbit", traits: { GENTLE: 0.9, PLAY: 0.5, IND: 0.4, CUR: 0.3 },
          desc: "Soft-spoken, cautious, and kind. You’re sensitive to atmosphere and protect peace." },
        { name: "Jaguar", traits: { BOLD: 0.9, IND: 0.7, MYST: 0.5, DISC: 0.3 },
          desc: "Stealthy and intense. You combine power with patience and strike when it counts." },
        { name: "Leopard", traits: { CUR: 0.6, BOLD: 0.7, IND: 0.6, PLAY: 0.3 },
          desc: "Adaptable and stylish, with a quiet edge. You move fast and think on your feet." },
        { name: "Cheetah", traits: { BOLD: 0.8, CUR: 0.6, DISC: 0.4, PLAY: 0.3 },
          desc: "Fast and driven. You aim straight at what you want and thrive on momentum." },
        { name: "Phoenix", traits: { MYST: 0.9, BOLD: 0.7, GENTLE: 0.4, DISC: 0.4 },
          desc: "Resilient and radiant. You reinvent yourself and bring hope after hard seasons." },
        { name: "Eagle", traits: { BOLD: 0.8, DISC: 0.6, IND: 0.6, CUR: 0.4 },
          desc: "Clear-sighted and determined. You see the big picture and act with purpose." },
        { name: "Penguin", traits: { SOCIAL: 0.8, DISC: 0.6, GENTLE: 0.4, PLAY: 0.3 },
          desc: "Loyal and steady. You value community and show care in practical ways." },
        { name: "Panda", traits: { GENTLE: 0.9, PLAY: 0.6, SOCIAL: 0.3, IND: 0.2 },
          desc: "Calm, sweet, and grounded. You keep the vibe gentle and cozy." },
        { name: "Snake", traits: { MYST: 0.8, IND: 0.8, CUR: 0.3, DISC: 0.4 },
          desc: "Quiet and strategic. You move with precision and keep your energy protected." },
        { name: "Monkey", traits: { PLAY: 0.9, CUR: 0.8, SOCIAL: 0.6, BOLD: 0.3 },
          desc: "Energetic and clever. You learn fast and keep things lively." },
        { name: "Fox", traits: { CUR: 0.7, MYST: 0.5, IND: 0.6, PLAY: 0.4 },
          desc: "Clever and adaptable. You solve problems in creative ways and keep a playful edge." },
        { name: "Pigeon", traits: { SOCIAL: 0.7, DISC: 0.5, GENTLE: 0.3 },
          desc: "Reliable and familiar. You find your way back and keep bonds steady." },
        { name: "Parrot", traits: { SOCIAL: 0.9, PLAY: 0.7, CUR: 0.5 },
          desc: "Bright and expressive. You connect through voice, style, and curiosity." },
        { name: "Peacock", traits: { BOLD: 0.6, SOCIAL: 0.7, MYST: 0.3, PLAY: 0.3 },
          desc: "Vibrant and expressive. You bring presence and beauty to any space." },
        { name: "Duck", traits: { GENTLE: 0.6, SOCIAL: 0.5, PLAY: 0.4, DISC: 0.3 },
          desc: "Easygoing and friendly. You keep things light while moving steadily forward." },
        { name: "Swan", traits: { GENTLE: 0.7, MYST: 0.4, IND: 0.4, DISC: 0.3 },
          desc: "Graceful and composed. You move with quiet elegance and calm confidence." },
      ];
      ANIMALS.sort((a, b) => a.name.localeCompare(b.name));

      const LIKERT_LABELS = [
        "Strongly Disagree",
        "Disagree",
        "Slightly Disagree",
        "Neutral",
        "Slightly Agree",
        "Agree",
        "Strongly Agree",
      ];

      let cachedName = "";
      let cachedPortrait = null;

      function buildIllustratedCanvas() {
        const canvas = document.createElement("canvas");
        const size = illustratedPortrait ? illustratedPortrait.clientWidth || 512 : 512;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, size, size);
        const layers = [
          drawBackHair, drawBody, drawNose, drawEyes, drawEyeTint, drawWink, drawClosed, drawPupil, drawBrows, drawMouth, drawFrontHair, drawTemples, drawBraids, drawOutfit, drawAccessory
        ].filter(Boolean);
        layers.forEach((layer) => {
          if (layer instanceof HTMLCanvasElement) {
            ctx.drawImage(layer, 0, 0, size, size);
          } else if (layer.complete && layer.naturalWidth) {
            ctx.drawImage(layer, 0, 0, size, size);
          }
        });
        try {
          canvas.toDataURL("image/png");
          return canvas;
        } catch {
          return portraitCanvas || null;
        }
      }

      function updateCachedPortrait() {
        const mode = portraitMode ? portraitMode.value : "traditional";
        if (mode === "illustrated") {
          cachedPortrait = buildIllustratedCanvas() || portraitCanvas || null;
        } else {
          cachedPortrait = portraitCanvas || null;
        }
      }

      function renderQuestions() {
        questionsWrap.innerHTML = "";
        QUESTIONS.forEach((q, idx) => {
          const card = document.createElement("div");
          card.className = "personality-card";

          const title = document.createElement("h4");
          title.textContent = `Q${idx + 1}. ${q.text}`;
          card.appendChild(title);

          const row = document.createElement("div");
          row.className = "likert-row";

          LIKERT_LABELS.forEach((label, i) => {
            const val = i + 1;
            const wrap = document.createElement("label");
            wrap.className = "likert-option";

            const input = document.createElement("input");
            input.type = "radio";
            input.name = `aq_${idx}`;
            input.value = String(val);

            const text = document.createElement("span");
            text.textContent = label;

            wrap.appendChild(input);
            wrap.appendChild(text);
            row.appendChild(wrap);
          });

          card.appendChild(row);
          questionsWrap.appendChild(card);
        });
      }

      function renderGuidebook() {
        if (!guideBox) return;
        guideBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Animal Guidebook</h3>
            <p class="mini-note" style="margin-top:8px;">All possible animal identities and their traits.</p>
          </div>
          ${ANIMALS.map((a) => `
            <div class="personality-card">
              <h4 style="margin:0;">${a.name}</h4>
              <p class="mini-note" style="margin-top:8px;">${a.desc}</p>
            </div>
          `).join("")}
        `;
      }

      function normalizeTraits(scores, maxByTrait) {
        const out = {};
        Object.keys(TRAITS).forEach((k) => {
          const max = maxByTrait[k] || 0;
          if (max <= 0) out[k] = 0;
          else out[k] = Math.max(-1, Math.min(1, (scores[k] || 0) / max));
        });
        return out;
      }

      function similarity(user, animal) {
        const keys = Object.keys(TRAITS);
        let sum = 0;
        keys.forEach((k) => {
          const a = animal[k] || 0;
          const u = user[k] || 0;
          sum += u * a;
        });
        return sum / keys.length;
      }

      function topMatches(user, animal, n) {
        const keys = Object.keys(TRAITS);
        const ranked = keys.map((k) => {
          const a = animal[k] || 0;
          const u = user[k] || 0;
          const match = 1 - Math.abs(u - a) / 2;
          return { key: k, match };
        }).sort((a, b) => b.match - a.match);
        return ranked.slice(0, n);
      }

      function getThemeVar(name, fallback) {
        const val = getComputedStyle(document.body).getPropertyValue(name).trim();
        return val || fallback;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let yy = y;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + " ";
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x, yy);
            line = words[i] + " ";
            yy += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, yy);
        return yy + lineHeight;
      }

      function concatBytes(chunks) {
        let total = 0;
        chunks.forEach((c) => { total += c.length; });
        const out = new Uint8Array(total);
        let offset = 0;
        chunks.forEach((c) => {
          out.set(c, offset);
          offset += c.length;
        });
        return out;
      }

      function buildPdfFromJpeg(jpegBytes, width, height) {
        const enc = new TextEncoder();
        const chunks = [];
        let offset = 0;
        const xref = [];

        function pushStr(s) {
          const b = enc.encode(s);
          chunks.push(b);
          offset += b.length;
        }
        function pushBytes(b) {
          chunks.push(b);
          offset += b.length;
        }

        pushStr("%PDF-1.3\n");
        xref.push(offset); pushStr("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
        xref.push(offset); pushStr("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
        xref.push(offset); pushStr(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`);
        xref.push(offset); pushStr(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`);
        pushBytes(jpegBytes);
        pushStr("\nendstream\nendobj\n");
        const content = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        const contentBytes = enc.encode(content);
        xref.push(offset); pushStr(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
        pushBytes(contentBytes);
        pushStr("\nendstream\nendobj\n");

        const xrefStart = offset;
        pushStr("xref\n0 6\n0000000000 65535 f \n");
        xref.forEach((pos) => {
          const line = String(pos).padStart(10, "0") + " 00000 n \n";
          pushStr(line);
        });
        pushStr(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`);
        return concatBytes(chunks);
      }

      function buildCardCanvas(result, userTraits) {
        const canvas = document.createElement("canvas");
        canvas.width = 900;
        canvas.height = 560;
        const ctx = canvas.getContext("2d");

        const bg = getThemeVar("--bg-2", "#15182a");
        const surface = getThemeVar("--surface", "rgba(255,255,255,0.06)");
        const text = getThemeVar("--text", "#e8e8e8");
        const heading = getThemeVar("--heading", "#ffffff");
        const accent = getThemeVar("--accent", "#c6a664");
        const accent2 = getThemeVar("--accent-2", "#9bc1ff");

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = surface;
        ctx.fillRect(24, 24, canvas.width - 48, canvas.height - 48);

        ctx.fillStyle = heading;
        ctx.font = "700 26px serif";
        ctx.fillText("SPERTZ Animal Match", 48, 70);

        ctx.fillStyle = accent2;
        ctx.font = "700 40px serif";
        ctx.fillText(result.name, 48, 122);

        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        let yy = wrapText(ctx, result.desc, 48, 160, 500, 22);

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText(`Match: ${result.percent}%`, 48, yy + 10);

        const matchText = result.topTraits.map((t) => `${TRAITS[t.key]} ${Math.round(t.match * 100)}%`).join(" · ");
        ctx.fillStyle = text;
        ctx.font = "14px sans-serif";
        ctx.fillText(matchText, 48, yy + 34);

        if (cachedName) {
          ctx.fillStyle = accent;
          ctx.font = "600 14px sans-serif";
          ctx.fillText("Name", 48, yy + 64);
          ctx.fillStyle = text;
          ctx.font = "16px sans-serif";
          ctx.fillText(cachedName, 48, yy + 88);
        }

        if (cachedPortrait && cachedPortrait.width) {
          const px = 620;
          const py = 80;
          const size = 200;
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(px - 6, py - 6, size + 12, size + 12);
          ctx.drawImage(cachedPortrait, px, py, size, size);
        }

        ctx.fillStyle = accent2;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Your trait blend", 48, 430);
        ctx.fillStyle = text;
        ctx.font = "13px sans-serif";
        const blend = Object.keys(TRAITS)
          .map((k) => `${TRAITS[k]} ${(Math.round((userTraits[k] + 1) * 50))}%`)
          .join(" · ");
        wrapText(ctx, blend, 48, 452, 800, 18);

        return canvas;
      }

      function downloadPng(canvas) {
        const link = document.createElement("a");
        link.download = "spertz-animal-card.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      function downloadPdf(canvas) {
        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const pdfBytes = buildPdfFromJpeg(bytes, canvas.width, canvas.height);
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "spertz-animal-card.pdf";
        link.click();
        URL.revokeObjectURL(url);
      }

      function calculate() {
        const scores = {};
        const maxByTrait = {};
        Object.keys(TRAITS).forEach((k) => { scores[k] = 0; maxByTrait[k] = 0; });

        const unanswered = [];

        QUESTIONS.forEach((q, idx) => {
          const checked = document.querySelector(`input[name="aq_${idx}"]:checked`);
          if (!checked) {
            unanswered.push(idx);
            return;
          }
          const val = parseInt(checked.value, 10) - 4;
          Object.entries(q.weights).forEach(([trait, weight]) => {
            scores[trait] += val * weight;
            maxByTrait[trait] += Math.abs(weight) * 3;
          });
        });

        if (unanswered.length) {
          resultsBox.style.display = "";
          const list = unanswered.map((i) => i + 1).slice(0, 8).join(", ");
          const more = unanswered.length > 8 ? ` (+${unanswered.length - 8} more)` : "";
          resultsBox.innerHTML = `
            <div class="personality-card">
              <h3 style="margin:0;">Complete all questions</h3>
              <p class="mini-note" style="margin-top:8px;">
                Please answer every question to see results. Unanswered: ${list}${more}
              </p>
            </div>
          `;
          resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
          const firstMissing = document.querySelector(`input[name="aq_${unanswered[0]}"]`);
          if (firstMissing) {
            firstMissing.closest(".personality-card")?.scrollIntoView({ behavior: "smooth", block: "center" });
            firstMissing.focus({ preventScroll: true });
          }
          return;
        }

        const userTraits = normalizeTraits(scores, maxByTrait);

        const ranked = ANIMALS.map((a) => {
          const sim = similarity(userTraits, a.traits || {});
          return { ...a, sim };
        }).sort((a, b) => b.sim - a.sim);

        const best = ranked[0];
        const percent = Math.round((best.sim + 1) * 50);
        const topTraits = topMatches(userTraits, best.traits || {}, 3);

        resultsBox.style.display = "";
        resultsBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Your animal match: ${best.name}</h3>
            <p class="mini-note" style="margin-top:8px;">${best.desc}</p>
            <div class="result-pills" style="margin-top:10px;">
              <span class="result-pill">Match: ${percent}%</span>
              ${topTraits.map((t) => `<span class="result-pill">${TRAITS[t.key]} ${Math.round(t.match * 100)}%</span>`).join("")}
            </div>
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Download your card</h4>
            <p class="mini-note" style="margin-top:8px;">
              Save a small result card as a PNG or PDF.
            </p>
            <div class="animal-actions">
              <button id="animalDownloadPng" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PNG</span>
                <span class="acc-icon">⬇</span>
              </button>
              <button id="animalDownloadPdf" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PDF</span>
                <span class="acc-icon">⬇</span>
              </button>
            </div>
          </div>
        `;

        const cardCanvas = buildCardCanvas({ ...best, percent, topTraits }, userTraits);
        resultsBox.querySelector("#animalDownloadPng")?.addEventListener("click", () => downloadPng(cardCanvas));
        resultsBox.querySelector("#animalDownloadPdf")?.addEventListener("click", () => downloadPdf(cardCanvas));
        resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      function resetAll() {
        document.querySelectorAll('#animalQuizQuestions input[type="radio"]').forEach((input) => {
          input.checked = false;
        });
        resultsBox.style.display = "none";
        resultsBox.innerHTML = "";
      }

      if (shareApplyBtn) {
        shareApplyBtn.addEventListener("click", () => {
          const code = shareInput ? shareInput.value.trim() : "";
          if (!code) {
            shareStatus.textContent = "Please paste a share code first.";
            return;
          }
          if (!code.startsWith("SPERTZ1:")) {
            shareStatus.textContent = "Invalid code. Please paste a character share code.";
            cachedName = "";
            cachedPortrait = null;
            return;
          }
          if (shareCode && shareApply) {
            shareCode.value = code;
            shareApply.click();
            if (characterShareStatus && characterShareStatus.textContent.startsWith("Error")) {
              shareStatus.textContent = "Invalid code. Please paste a character share code.";
              cachedName = "";
              cachedPortrait = null;
              return;
            }
            cachedName = (fullNameOut && fullNameOut.textContent && fullNameOut.textContent !== "—") ? fullNameOut.textContent : "";
            updateCachedPortrait();
            shareStatus.textContent = cachedName ? "Code loaded ✅" : "Code loaded (name not found).";
          } else {
            shareStatus.textContent = "Share system not available.";
          }
        });
      }

      if (shareClearBtn) {
        shareClearBtn.addEventListener("click", () => {
          if (shareInput) shareInput.value = "";
          cachedName = "";
          cachedPortrait = null;
          shareStatus.textContent = "No code loaded.";
        });
      }

      if (portraitMode) {
        portraitMode.addEventListener("change", () => {
          if (!cachedName && !cachedPortrait) return;
          updateCachedPortrait();
        });
      }

      [drawBackHair, drawBody, drawNose, drawEyes, drawWink, drawClosed, drawPupil, drawBrows, drawMouth, drawFrontHair, drawTemples, drawBraids, drawOutfit, drawAccessory]
        .filter(Boolean)
        .forEach((img) => {
          img.addEventListener("load", () => {
            if (portraitMode && portraitMode.value === "illustrated" && cachedName) {
              updateCachedPortrait();
            }
          });
        });

      submitBtn.addEventListener("click", calculate);
      resetBtn.addEventListener("click", resetAll);

      if (guideToggle && guideBox) {
        renderGuidebook();
        guideToggle.addEventListener("click", () => {
          const open = guideBox.style.display !== "none";
          guideBox.style.display = open ? "none" : "";
          guideToggle.querySelector(".acc-icon").textContent = open ? "▾" : "▴";
        });
      }

      renderQuestions();
    })();

    // ===== Superpower Day Quiz =====
    (function () {
      const questionsWrap = document.getElementById("superpowerQuestions");
      const submitBtn = document.getElementById("superpowerSubmit");
      const resetBtn = document.getElementById("superpowerReset");
      const resultsBox = document.getElementById("superpowerResults");

      if (!questionsWrap || !submitBtn || !resetBtn || !resultsBox) return;

      const PROPS = [
        "Fire", "Water", "Earth", "Electricity", "Wind", "Sand", "Ice",
        "Fate", "Shadow", "Dark", "Night", "Nature", "Light",
        "Stars-Creation", "Stars-Destruction",
        "Thought", "Bright", "Heart", "Gravity", "Thunder", "Flame", "Blaze", "Sky", "Chill",
        "Sound", "Jade", "Life", "Brilliance", "Color", "Vine",
        "Origin", "Forest", "Dream", "Wave", "Metal"
      ];

      const RANKS = [
        "Common", "Fine", "Excellent", "Epic", "Legendary", "Mythical", "Temporal", "Eternal"
      ];

      const TRAITS = ["power", "focus", "harmony", "adapt", "myst", "resolve"];

      const PROP_PROFILES = [
        { name: "Fire", traits: { power: 0.9, resolve: 0.6, focus: 0.2 } },
        { name: "Water", traits: { harmony: 0.8, adapt: 0.6, focus: 0.3 } },
        { name: "Earth", traits: { focus: 0.8, resolve: 0.6, harmony: 0.3 } },
        { name: "Electricity", traits: { power: 0.8, adapt: 0.7, focus: 0.2 } },
        { name: "Wind", traits: { adapt: 0.8, power: 0.5, myst: 0.2 } },
        { name: "Sand", traits: { resolve: 0.8, focus: 0.5, harmony: 0.2 } },
        { name: "Ice", traits: { focus: 0.9, myst: 0.4, resolve: 0.3 } },
        { name: "Fate", traits: { myst: 0.9, focus: 0.4, harmony: 0.3 } },
        { name: "Shadow", traits: { myst: 0.8, focus: 0.6, adapt: 0.2 } },
        { name: "Dark", traits: { myst: 0.7, resolve: 0.6, focus: 0.3 } },
        { name: "Night", traits: { myst: 0.6, harmony: 0.4, focus: 0.4 } },
        { name: "Nature", traits: { harmony: 0.9, focus: 0.3, adapt: 0.3 } },
        { name: "Light", traits: { harmony: 0.7, power: 0.5, focus: 0.2 } },
        { name: "Stars-Creation", traits: { harmony: 0.8, myst: 0.6, resolve: 0.3 } },
        { name: "Stars-Destruction", traits: { power: 0.9, resolve: 0.6, myst: 0.3 } },
        { name: "Thought", traits: { focus: 0.8, myst: 0.4, resolve: 0.3 } },
        { name: "Bright", traits: { harmony: 0.7, adapt: 0.4, power: 0.3 } },
        { name: "Heart", traits: { harmony: 0.9, resolve: 0.3, myst: 0.2 } },
        { name: "Gravity", traits: { focus: 0.7, resolve: 0.7, power: 0.2 } },
        { name: "Thunder", traits: { power: 0.9, adapt: 0.4, resolve: 0.3 } },
        { name: "Flame", traits: { power: 0.7, focus: 0.4, resolve: 0.5 } },
        { name: "Blaze", traits: { power: 0.9, adapt: 0.3, resolve: 0.4 } },
        { name: "Sky", traits: { adapt: 0.7, harmony: 0.5, myst: 0.2 } },
        { name: "Chill", traits: { focus: 0.7, harmony: 0.4, myst: 0.3 } },
        { name: "Sound", traits: { focus: 0.6, adapt: 0.5, harmony: 0.3 } },
        { name: "Jade", traits: { resolve: 0.7, harmony: 0.5, focus: 0.3 } },
        { name: "Life", traits: { harmony: 0.9, focus: 0.2, myst: 0.3 } },
        { name: "Brilliance", traits: { power: 0.6, myst: 0.5, harmony: 0.4 } },
        { name: "Color", traits: { harmony: 0.6, adapt: 0.5, myst: 0.3 } },
        { name: "Vine", traits: { harmony: 0.7, resolve: 0.5, focus: 0.3 } },
        { name: "Origin", traits: { myst: 0.7, focus: 0.5, resolve: 0.3 } },
        { name: "Forest", traits: { harmony: 0.8, focus: 0.4, adapt: 0.3 } },
        { name: "Dream", traits: { myst: 0.9, harmony: 0.3, adapt: 0.3 } },
        { name: "Wave", traits: { adapt: 0.7, harmony: 0.5, power: 0.2 } },
        { name: "Metal", traits: { resolve: 0.8, focus: 0.5, power: 0.2 } }
      ];

      const QUESTION_TEMPLATES = [
        "You stay composed when plans shift suddenly.",
        "You prefer to act quickly rather than wait.",
        "You listen for details others miss.",
        "You keep your focus even when distracted.",
        "You thrive when you can improvise.",
        "You feel strongest when you lead.",
        "You feel strongest when you support others.",
        "You favor steady progress over fast wins.",
        "You recover quickly after setbacks.",
        "You trust your instincts more than advice.",
        "You are energized by high-stakes moments.",
        "You are energized by quiet, steady work.",
        "You choose clarity over complexity.",
        "You keep secrets with care.",
        "You notice patterns in small events.",
        "You protect what matters, even at a cost.",
        "You prefer calm spaces to loud ones.",
        "You feel most alive when learning something new.",
        "You feel most alive when creating structure.",
        "You stay grounded when others panic.",
        "You push forward even when unsure.",
        "You prefer patient strategy to bold risk.",
        "You naturally inspire others.",
        "You take pride in precision.",
        "You read a room quickly.",
        "You can wait for the right moment.",
        "You notice hidden meaning in simple things.",
        "You adapt to change without stress.",
        "You prefer balance over extremes.",
        "You follow through on long projects.",
        "You keep your energy protected from noise.",
        "You trust quiet progress over loud success.",
        "You value loyalty over popularity.",
        "You seek depth more than speed.",
        "You remain calm under pressure.",
        "You act decisively when needed.",
        "You care about impact, not applause.",
        "You keep your path even when it's hard.",
        "You aim to be fair in conflict.",
        "You hold onto hope during setbacks."
      ];

      function buildQuestions() {
        const traitCycle = ["focus", "power", "harmony", "adapt", "myst", "resolve"];
        return QUESTION_TEMPLATES.map((text, idx) => {
          const t1 = traitCycle[idx % traitCycle.length];
          const t2 = traitCycle[(idx + 2) % traitCycle.length];
          return {
            text,
            traits: { [t1]: 1, [t2]: 1 }
          };
        });
      }

      const QUESTIONS = buildQuestions();

      const LIKERT_LABELS = [
        "Strongly Disagree",
        "Disagree",
        "Slightly Disagree",
        "Neutral",
        "Slightly Agree",
        "Agree",
        "Strongly Agree",
      ];

      function renderQuestions() {
        questionsWrap.innerHTML = "";
        QUESTIONS.forEach((q, idx) => {
          const card = document.createElement("div");
          card.className = "personality-card";

          const title = document.createElement("h4");
          title.textContent = `Q${idx + 1}. ${q.text}`;
          card.appendChild(title);

          const row = document.createElement("div");
          row.className = "likert-row";

          LIKERT_LABELS.forEach((label, i) => {
            const val = i + 1;
            const wrap = document.createElement("label");
            wrap.className = "likert-option";

            const input = document.createElement("input");
            input.type = "radio";
            input.name = `spq_${idx}`;
            input.value = String(val);

            const text = document.createElement("span");
            text.textContent = label;

            wrap.appendChild(input);
            wrap.appendChild(text);
            row.appendChild(wrap);
          });

          card.appendChild(row);
          questionsWrap.appendChild(card);
        });
      }

      function getThemeVar(name, fallback) {
        const val = getComputedStyle(document.body).getPropertyValue(name).trim();
        return val || fallback;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let yy = y;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + " ";
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x, yy);
            line = words[i] + " ";
            yy += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, yy);
        return yy + lineHeight;
      }

      function concatBytes(chunks) {
        let total = 0;
        chunks.forEach((c) => { total += c.length; });
        const out = new Uint8Array(total);
        let offset = 0;
        chunks.forEach((c) => {
          out.set(c, offset);
          offset += c.length;
        });
        return out;
      }

      function buildPdfFromJpeg(jpegBytes, width, height) {
        const enc = new TextEncoder();
        const chunks = [];
        let offset = 0;
        const xref = [];

        function pushStr(s) {
          const b = enc.encode(s);
          chunks.push(b);
          offset += b.length;
        }
        function pushBytes(b) {
          chunks.push(b);
          offset += b.length;
        }

        pushStr("%PDF-1.3\n");
        xref.push(offset); pushStr("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
        xref.push(offset); pushStr("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
        xref.push(offset); pushStr(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`);
        xref.push(offset); pushStr(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`);
        pushBytes(jpegBytes);
        pushStr("\nendstream\nendobj\n");
        const content = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        const contentBytes = enc.encode(content);
        xref.push(offset); pushStr(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
        pushBytes(contentBytes);
        pushStr("\nendstream\nendobj\n");

        const xrefStart = offset;
        pushStr("xref\n0 6\n0000000000 65535 f \n");
        xref.forEach((pos) => {
          const line = String(pos).padStart(10, "0") + " 00000 n \n";
          pushStr(line);
        });
        pushStr(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`);
        return concatBytes(chunks);
      }

      function downloadPng(canvas) {
        const link = document.createElement("a");
        link.download = "spertz-superpower-card.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      function downloadPdf(canvas) {
        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const pdfBytes = buildPdfFromJpeg(bytes, canvas.width, canvas.height);
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "spertz-superpower-card.pdf";
        link.click();
        URL.revokeObjectURL(url);
      }

      function pickRings(propScores, traitScores) {
        const entries = Object.entries(propScores).sort((a, b) => b[1] - a[1]);
        const topScore = entries[0]?.[1] || 0;
        const secondScore = entries[1]?.[1] || 0;
        const thirdScore = entries[2]?.[1] || 0;
        const power = traitScores.power || 0;
        const focus = traitScores.focus || 0;
        const harmony = traitScores.harmony || 0;
        let ringCount = 1;
        if (topScore >= 12 && power + focus + harmony >= 7) ringCount = 3;
        else if (topScore >= 7 || power + focus + harmony >= 5) ringCount = 2;

        const chosen = [];
        for (let i = 0; i < ringCount; i++) {
          if (i === 1 && topScore >= secondScore + 3) {
            chosen.push(entries[0]);
          } else if (i === 2 && topScore >= thirdScore + 5) {
            chosen.push(entries[0]);
          } else {
            chosen.push(entries[i] || entries[0]);
          }
        }
        const hasCreation = chosen.some((c) => c[0] === "Stars-Creation");
        const hasDestruction = chosen.some((c) => c[0] === "Stars-Destruction");
        if (hasCreation && hasDestruction) {
          const creationScore = chosen.find((c) => c[0] === "Stars-Creation")?.[1] ?? -Infinity;
          const destructionScore = chosen.find((c) => c[0] === "Stars-Destruction")?.[1] ?? -Infinity;
          const removeName = creationScore <= destructionScore ? "Stars-Creation" : "Stars-Destruction";
          for (let i = 0; i < chosen.length; i++) {
            if (chosen[i][0] === removeName) {
              const replacement = entries.find((e) => e[0] !== "Stars-Creation" && e[0] !== "Stars-Destruction");
              if (replacement) chosen[i] = replacement;
              break;
            }
          }
        }
        const hasDestructionFinal = chosen.some((c) => c[0] === "Stars-Destruction");
        const hasCreationFinal = chosen.some((c) => c[0] === "Stars-Creation");

        const maxIndex = ringCount === 3 ? 7 : 6;
        const strength = Math.max(0, topScore + power + focus + harmony);
        let baseRank = 1;
        if (strength >= 8) baseRank = 2;
        if (strength >= 11) baseRank = 3;
        if (strength >= 14) baseRank = 4;
        if (strength >= 17) baseRank = 5;
        if (strength >= 20) baseRank = 6;
        if (ringCount === 3 && strength >= 24) baseRank = 7;
        baseRank = Math.min(maxIndex, Math.max(1, baseRank));

        return chosen.map((entry, idx) => {
          const ringIdx = idx + 1;
          const rankOffset = ringIdx - 2;
          let rankIndex = baseRank + rankOffset;
          rankIndex = Math.max(0, Math.min(maxIndex, rankIndex));
          if (ringCount < 3 && rankIndex > 6) rankIndex = 6;
          const primaryScore = entry[1];
          const primary = entry[0];
          const candidates = primary === "Stars-Destruction"
            ? []
            : entries
                .filter((e) => e[0] !== primary)
                .filter((e) => e[0] !== "Stars-Destruction")
                .filter((e) => !hasDestructionFinal || e[0] !== "Stars-Creation")
                .filter((e) => !hasCreationFinal || e[0] !== "Stars-Destruction");
          const extras = candidates
            .filter((e) => e[1] >= primaryScore - 0.6)
            .slice(0, 1)
            .map((e) => e[0]);
          if (extras.length === 1) {
            const third = candidates.find((e) => e[1] >= primaryScore - 0.2 && e[0] !== extras[0]);
            if (third) extras.push(third[0]);
          }
          const properties = [primary].concat(extras);
          return {
            property: properties.join(" / "),
            properties,
            score: entry[1],
            rank: RANKS[rankIndex]
          };
        });
      }

      function buildCardCanvas(rings) {
        const canvas = document.createElement("canvas");
        canvas.width = 900;
        canvas.height = 560;
        const ctx = canvas.getContext("2d");

        const bg = getThemeVar("--bg-2", "#15182a");
        const surface = getThemeVar("--surface", "rgba(255,255,255,0.06)");
        const text = getThemeVar("--text", "#e8e8e8");
        const heading = getThemeVar("--heading", "#ffffff");
        const accent = getThemeVar("--accent", "#c6a664");
        const accent2 = getThemeVar("--accent-2", "#9bc1ff");

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = surface;
        ctx.fillRect(24, 24, canvas.width - 48, canvas.height - 48);

        ctx.fillStyle = heading;
        ctx.font = "700 26px serif";
        ctx.fillText("Superpower Day Rings", 48, 70);

        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        wrapText(ctx, "Pesimura · December 26 · Rings awaken when you reach adulthood.", 48, 98, 800, 22);

        ctx.fillStyle = accent;
        ctx.font = "700 18px serif";
        ctx.fillText(`Rings: ${rings.length}`, 48, 140);

        const startY = 180;
        const cardW = 250;
        rings.forEach((ring, idx) => {
          const x = 48 + idx * (cardW + 16);
          const y = startY;
          const innerX = x + 16;
          const innerW = cardW - 32;
          ctx.fillStyle = "rgba(255,255,255,0.08)";
          ctx.fillRect(x, y, cardW, 220);
          ctx.fillStyle = accent2;
          ctx.font = "700 18px serif";
          ctx.fillText(`Ring ${idx + 1}`, innerX, y + 36);
          ctx.fillStyle = text;
          ctx.font = "16px sans-serif";
          let yy = wrapText(ctx, `Property: ${ring.property}`, innerX, y + 70, innerW, 20);
          const rankStyles = {
            Common: { fill: "#b8b8b8" },
            Fine: { fill: "#9bc1ff" },
            Excellent: { fill: "#7ad6c5" },
            Epic: { fill: "#b58cff" },
            Legendary: { fill: "#f0b55a" },
            Mythical: { fill: "#ff7fb0" },
            Temporal: { fill: "#9ef2ff" },
            Eternal: { fill: "#ffd166" },
          };
          const rank = rankStyles[ring.rank] || rankStyles.Common;
          ctx.fillStyle = rank.fill;
          ctx.fillRect(innerX, yy + 6, Math.min(150, innerW), 26);
          ctx.fillStyle = "#1d1a16";
          ctx.font = "700 14px sans-serif";
          ctx.fillText(ring.rank, innerX + 10, yy + 24);
        });

        return canvas;
      }

      function calculate() {
        const traitScores = {};
        TRAITS.forEach((t) => { traitScores[t] = 0; });

        const unanswered = [];

        QUESTIONS.forEach((q, idx) => {
          const checked = document.querySelector(`input[name="spq_${idx}"]:checked`);
          if (!checked) {
            unanswered.push(idx);
            return;
          }
          const val = parseInt(checked.value, 10) - 4;
          Object.entries(q.traits || {}).forEach(([t, w]) => {
            traitScores[t] += val * w;
          });
        });

        if (unanswered.length) {
          resultsBox.style.display = "";
          const list = unanswered.map((i) => i + 1).slice(0, 8).join(", ");
          const more = unanswered.length > 8 ? ` (+${unanswered.length - 8} more)` : "";
          resultsBox.innerHTML = `
            <div class="personality-card">
              <h3 style="margin:0;">Complete all questions</h3>
              <p class="mini-note" style="margin-top:8px;">
                Please answer every question to see results. Unanswered: ${list}${more}
              </p>
            </div>
          `;
          resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
          const firstMissing = document.querySelector(`input[name="spq_${unanswered[0]}"]`);
          if (firstMissing) {
            firstMissing.closest(".personality-card")?.scrollIntoView({ behavior: "smooth", block: "center" });
            firstMissing.focus({ preventScroll: true });
          }
          return;
        }

        const propScores = {};
        PROP_PROFILES.forEach((p) => {
          let score = 0;
          TRAITS.forEach((t) => {
            score += (traitScores[t] || 0) * (p.traits[t] || 0);
          });
          propScores[p.name] = score;
        });

        const rings = pickRings(propScores, traitScores);
        const fancyByRank = {
          Common: "color:#f5efe6; background:rgba(255,255,255,0.14); border:1px solid rgba(255,255,255,0.35);",
          Fine: "color:#f5efe6; background:rgba(155,193,255,0.22); border:1px solid rgba(155,193,255,0.55);",
          Excellent: "color:#f5efe6; background:rgba(122,214,197,0.22); border:1px solid rgba(122,214,197,0.55);",
          Epic: "color:#f5efe6; background:rgba(181,140,255,0.24); border:1px solid rgba(181,140,255,0.6);",
          Legendary: "color:#f5efe6; background:rgba(240,181,90,0.26); border:1px solid rgba(240,181,90,0.65);",
          Mythical: "color:#f5efe6; background:rgba(255,127,176,0.28); border:1px solid rgba(255,127,176,0.7);",
          Temporal: "color:#f5efe6; background:rgba(158,242,255,0.28); border:1px solid rgba(158,242,255,0.75); box-shadow:0 0 12px rgba(158,242,255,0.25);",
          Eternal: "color:#f5efe6; background:rgba(255,209,102,0.32); border:1px solid rgba(255,209,102,0.8); box-shadow:0 0 16px rgba(255,209,102,0.45);"
        };
        const propertyPalette = {
          "Fire": "#4d0f16",
          "Water": "#0b2a4d",
          "Earth": "#2c1f1a",
          "Electricity": "#2a1347",
          "Wind": "#113034",
          "Sand": "#3a2613",
          "Ice": "#0b2f3a",
          "Fate": "#2b183f",
          "Shadow": "#120f1f",
          "Dark": "#0b0a12",
          "Night": "#101534",
          "Nature": "#12301e",
          "Light": "#3b2c0f",
          "Stars-Creation": "#1f1a33",
          "Stars-Destruction": "#2d0b0b",
          "Thought": "#1a1f35",
          "Bright": "#2f2b16",
          "Heart": "#3a1420",
          "Gravity": "#1b1a24",
          "Thunder": "#1a0f2d",
          "Flame": "#3b120c",
          "Blaze": "#4a1408",
          "Sky": "#12253b",
          "Chill": "#0f2a33",
          "Sound": "#1a2133",
          "Jade": "#123327",
          "Life": "#1c2f1a",
          "Brilliance": "#2f1f12",
          "Color": "#2b1530",
          "Vine": "#1a2b1a",
          "Origin": "#1f1a2a",
          "Forest": "#14301b",
          "Dream": "#1a1230",
          "Wave": "#0d2440",
          "Metal": "#2a2a2f"
        };
        function hashColor(name) {
          let hash = 0;
          for (let i = 0; i < name.length; i++) hash = (hash * 31 + name.charCodeAt(i)) | 0;
          const hue = Math.abs(hash) % 360;
          return `hsl(${hue}, 35%, 20%)`;
        }
        function propColor(name) {
          return propertyPalette[name] || hashColor(name);
        }
        function ringGradient(props) {
          const list = (props && props.length ? props : []).map(propColor);
          const colors = list.length ? list.slice(0, 3) : ["#1a1520", "#211b2a", "#151019"];
          return `linear-gradient(135deg, ${colors.join(", ")})`;
        }

        resultsBox.style.display = "";
        resultsBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Your Rings</h3>
            <p class="mini-note" style="margin-top:8px;">
              Rings awaken in Pesimura on December 26, the year you become an adult.
            </p>
            <div class="result-pills" style="margin-top:10px;">
              <span class="result-pill">Rings: ${rings.length}</span>
            </div>
          </div>
          <div class="personality-card">
            ${rings.map((r, idx) => `
              <div class="rule-note" style="margin-top:10px; border-color: rgba(255,255,255,0.18); background:${ringGradient(r.properties || [r.property])}; color:#f5efe6; box-shadow:0 12px 26px rgba(0,0,0,0.18);">
                <p style="margin:0; color:#f5efe6;"><b>Ring ${idx + 1}</b> · Property: ${r.property}</p>
                <span style="display:inline-flex; margin-top:8px; padding:6px 12px; border-radius:999px; font-weight:700; letter-spacing:0.3px; text-shadow:0 1px 2px rgba(0,0,0,0.4); ${fancyByRank[r.rank] || ""}">${r.rank}</span>
              </div>
            `).join("")}
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Download your card</h4>
            <p class="mini-note" style="margin-top:8px;">
              Save a small result card as a PNG or PDF.
            </p>
            <div class="animal-actions">
              <button id="superpowerDownloadPng" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PNG</span>
                <span class="acc-icon">⬇</span>
              </button>
              <button id="superpowerDownloadPdf" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PDF</span>
                <span class="acc-icon">⬇</span>
              </button>
            </div>
          </div>
        `;

        const cardCanvas = buildCardCanvas(rings);
        resultsBox.querySelector("#superpowerDownloadPng")?.addEventListener("click", () => downloadPng(cardCanvas));
        resultsBox.querySelector("#superpowerDownloadPdf")?.addEventListener("click", () => downloadPdf(cardCanvas));
        resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      function resetAll() {
        document.querySelectorAll('#superpowerQuestions input[type="radio"]').forEach((input) => {
          input.checked = false;
        });
        resultsBox.style.display = "none";
        resultsBox.innerHTML = "";
      }

      submitBtn.addEventListener("click", calculate);
      resetBtn.addEventListener("click", resetAll);

      renderQuestions();
    })();

    // ===== SPERTZ Cook =====
    (function () {
      const ingWrap = document.getElementById("cookIngredients");
      const seaWrap = document.getElementById("cookSeasonings");
      const metWrap = document.getElementById("cookMethods");
      const makeBtn = document.getElementById("cookMake");
      const resetBtn = document.getElementById("cookReset");
      const statusOut = document.getElementById("cookStatus");
      const bookWrap = document.getElementById("cookBook");
      const saveCode = document.getElementById("cookSaveCode");
      const saveBtn = document.getElementById("cookSave");
      const loadBtn = document.getElementById("cookLoad");
      const coinOut = document.getElementById("cookCoins");
      const repOut = document.getElementById("cookRep");
      const advOut = document.getElementById("cookAdvancedCount");
      const unlockIngBtn = document.getElementById("cookUnlockIng");
      const unlockSeaBtn = document.getElementById("cookUnlockSea");
      const unlockMetBtn = document.getElementById("cookUnlockMet");
      const hintBtn = document.getElementById("cookHintBuy");
      const hintWrap = document.getElementById("cookHints");
      const guideWrap = document.getElementById("cookCustomerGuide");
      const customerOut = document.getElementById("cookCustomer");
      const serveBtn = document.getElementById("cookServe");
      const skipBtn = document.getElementById("cookSkip");
      const lastDishOut = document.getElementById("cookLastDish");

      if (!ingWrap || !seaWrap || !metWrap || !makeBtn || !resetBtn || !bookWrap) return;

      const INGREDIENTS = [
        "moon rice", "sunroot", "river beans", "cloud tofu", "ember fish", "forest mushroom",
        "crystal onion", "sky kale", "dawn berry", "iron pumpkin", "golden corn", "wind garlic",
        "silver noodles", "mist shrimp", "lava pepperleaf", "root carrot", "amber apple",
        "cobalt algae", "stone lentils", "honey yam", "star potato",
        "glacier kelp", "ember tomato", "midnight squash", "sunflower grain", "cloudberry",
        "storm barley", "jade celery", "sky trout", "starfruit", "onion bloom"
      ];
      const SEASONINGS = [
        "salt glass", "sweet mist", "smoke pepper", "herb spiral", "citrus ash",
        "night sugar", "sea umami", "star honey", "vine leaf", "black spice",
        "ginger glow", "mint dust", "chili flake", "saffron spark", "soy ripple",
        "umbral vinegar", "crystal salt", "ember oil", "sky basil", "lunar lime"
      ];
      const METHODS = [
        "simmer", "grill", "steam", "bake", "stir-fry", "roast",
        "braise", "poach", "smoke", "sear", "ferment", "char"
      ];

      const ADVANCED_RECIPES = [
        {
          name: "starlit harvest bowl",
          method: "simmer",
          ingredients: ["moon rice", "golden corn", "sunroot", "sky kale"],
          seasonings: ["star honey", "herb spiral", "salt glass", "vine leaf"],
          coins: 6
        },
        {
          name: "ember festival feast",
          method: "grill",
          ingredients: ["ember fish", "crystal onion", "iron pumpkin", "wind garlic"],
          seasonings: ["smoke pepper", "black spice", "salt glass", "sea umami"],
          coins: 7
        },
        {
          name: "moonmist tofu tapestry",
          method: "steam",
          ingredients: ["cloud tofu", "sky kale", "forest mushroom", "sunroot"],
          seasonings: ["sweet mist", "vine leaf", "salt glass", "citrus ash"],
          coins: 6
        },
        {
          name: "dawn orchard bake",
          method: "bake",
          ingredients: ["dawn berry", "golden corn", "moon rice", "sunroot"],
          seasonings: ["night sugar", "star honey", "salt glass", "herb spiral"],
          coins: 7
        },
        {
          name: "river garden stew",
          method: "simmer",
          ingredients: ["river beans", "sky kale", "forest mushroom", "crystal onion"],
          seasonings: ["herb spiral", "vine leaf", "salt glass", "citrus ash"],
          coins: 6
        },
        {
          name: "silver noodle blaze",
          method: "stir-fry",
          ingredients: ["silver noodles", "ember fish", "wind garlic", "crystal onion"],
          seasonings: ["chili flake", "soy ripple", "smoke pepper", "salt glass"],
          coins: 8
        },
        {
          name: "honey yam roast",
          method: "roast",
          ingredients: ["honey yam", "root carrot", "iron pumpkin", "sunroot"],
          seasonings: ["star honey", "ginger glow", "salt glass", "herb spiral"],
          coins: 7
        },
        {
          name: "glacier kelp tableau",
          method: "poach",
          ingredients: ["glacier kelp", "mist shrimp", "sky kale", "moon rice"],
          seasonings: ["sea umami", "crystal salt", "lunar lime", "vine leaf"],
          coins: 8
        },
        {
          name: "ember tomato char",
          method: "char",
          ingredients: ["ember tomato", "crystal onion", "wind garlic", "jade celery"],
          seasonings: ["ember oil", "black spice", "salt glass", "smoke pepper"],
          coins: 8
        },
        {
          name: "midnight squash braise",
          method: "braise",
          ingredients: ["midnight squash", "root carrot", "stone lentils", "sunroot"],
          seasonings: ["umbral vinegar", "ginger glow", "herb spiral", "salt glass"],
          coins: 9
        },
        {
          name: "sky trout sear",
          method: "sear",
          ingredients: ["sky trout", "crystal onion", "jade celery", "moon rice"],
          seasonings: ["lunar lime", "sea umami", "salt glass", "mint dust"],
          coins: 8
        },
        {
          name: "starfruit ferment",
          method: "ferment",
          ingredients: ["starfruit", "amber apple", "cloudberry", "sunflower grain"],
          seasonings: ["night sugar", "lunar lime", "crystal salt", "vine leaf"],
          coins: 9
        },
        {
          name: "storm barley smoke",
          method: "smoke",
          ingredients: ["storm barley", "silver noodles", "ember fish", "onion bloom"],
          seasonings: ["smoke pepper", "black spice", "soy ripple", "salt glass"],
          coins: 9
        }
      ];

      const CUSTOMER_TYPES = [
        { id: "fish", label: "Fish-only customer", check: (dish) => dish.tags.fish },
        { id: "tofu", label: "Tofu lover", check: (dish) => dish.tags.tofu },
        { id: "veg", label: "Vegetarian", check: (dish) => dish.tags.veg },
        { id: "child", label: "Child", check: (dish) => dish.tags.child },
        { id: "elder", label: "Elderly", check: (dish) => dish.tags.elder },
        { id: "spicy", label: "Spice seeker", check: (dish) => dish.tags.spicy },
        { id: "sweet", label: "Sweet tooth", check: (dish) => dish.tags.sweet },
        { id: "herbal", label: "Herbal purist", check: (dish) => dish.tags.herbal },
        { id: "sea", label: "Sea-lover", check: (dish) => dish.tags.sea },
        { id: "light", label: "Light eater", check: (dish) => dish.tags.light },
        { id: "chef", label: "Master chef", check: (dish) => dish.tags.herbal || dish.tags.sea },
        { id: "traveler", label: "World traveler", check: (dish) => dish.tags.spicy || dish.tags.sweet },
        { id: "ritual", label: "Ritual diner", check: (dish) => dish.method === "simmer" || dish.method === "steam" },
        { id: "rich", label: "Rich patron", check: (dish) => dish.isAdvanced }
      ];

      const STATE = {
        unlockedIng: 2,
        unlockedSea: 2,
        unlockedMet: 2,
        dishes: [],
        coins: 0,
        lastDish: null,
        hints: [],
        reputation: 50,
        customer: null,
        richProgress: []
      };

      function renderList(wrap, list, unlocked, namePrefix) {
        wrap.innerHTML = "";
        list.forEach((item, i) => {
          const label = document.createElement("label");
          label.className = "cook-item";
          const input = document.createElement("input");
          input.type = "checkbox";
          input.name = `${namePrefix}_${i}`;
          input.value = item;
          input.disabled = i >= unlocked;
          const span = document.createElement("span");
          span.textContent = i < unlocked ? item : "Locked";
          label.appendChild(input);
          label.appendChild(span);
          wrap.appendChild(label);
        });
      }

      function renderMethods() {
        metWrap.innerHTML = "";
        METHODS.forEach((m, i) => {
          const label = document.createElement("label");
          label.className = "cook-item";
          const input = document.createElement("input");
          input.type = "radio";
          input.name = "cook_method";
          input.value = m;
          input.disabled = i >= STATE.unlockedMet;
          const span = document.createElement("span");
          span.textContent = i < STATE.unlockedMet ? m : "Locked";
          label.appendChild(input);
          label.appendChild(span);
          metWrap.appendChild(label);
        });
      }

      function renderAll() {
        renderList(ingWrap, INGREDIENTS, STATE.unlockedIng, "ing");
        renderList(seaWrap, SEASONINGS, STATE.unlockedSea, "sea");
        renderMethods();
        renderBook();
        renderHints();
        renderGuidebook();
        if (coinOut) coinOut.textContent = String(STATE.coins);
        if (repOut) repOut.textContent = String(STATE.reputation);
        if (advOut) {
          const advCount = STATE.dishes.filter((d) => d.isAdvanced).length;
          advOut.textContent = `${advCount}/${ADVANCED_RECIPES.length}`;
        }
        if (lastDishOut) lastDishOut.textContent = STATE.lastDish ? STATE.lastDish.name : "None";
        if (customerOut) customerOut.textContent = STATE.customer ? STATE.customer.label : "None";
      }

      function selectedValues(prefix) {
        return Array.from(document.querySelectorAll(`input[name^="${prefix}_"]:checked`)).map((i) => i.value);
      }

      function selectedMethod() {
        const sel = document.querySelector(`input[name="cook_method"]:checked`);
        return sel ? sel.value : "";
      }

      function dishName(ings, seas, method) {
        const adj = seas[0] ? seas[0].split(" ")[0] : "plain";
        const base = ings[0] || "mix";
        const extra = ings[1] ? ` & ${ings[1]}` : "";
        const end = seas[1] ? ` with ${seas[1]}` : "";
        return `${method} ${adj} ${base}${extra}${end}`.replace(/\s+/g, " ");
      }

      function makeKey(ings, seas, method) {
        const m = METHODS.indexOf(method);
        const ingIdx = ings.map((i) => INGREDIENTS.indexOf(i)).filter((i) => i >= 0).sort((a, b) => a - b);
        const seaIdx = seas.map((s) => SEASONINGS.indexOf(s)).filter((i) => i >= 0).sort((a, b) => a - b);
        const toBase36 = (n) => n.toString(36);
        return `${toBase36(m)}:${ingIdx.map(toBase36).join(".")}-${seaIdx.map(toBase36).join(".")}`;
      }

      function decodeKey(key) {
        const [mPart, rest] = key.split(":");
        const [ingPart, seaPart] = (rest || "").split("-");
        const fromBase36 = (s) => (s ? parseInt(s, 36) : -1);
        const mIdx = fromBase36(mPart);
        const method = METHODS[mIdx] || "";
        const ings = (ingPart ? ingPart.split(".") : []).filter(Boolean).map(fromBase36).map((i) => INGREDIENTS[i]).filter(Boolean);
        const seas = (seaPart ? seaPart.split(".") : []).filter(Boolean).map(fromBase36).map((i) => SEASONINGS[i]).filter(Boolean);
        return { method, ings, seas };
      }

      function matchAdvanced(ings, seas, method) {
        const is = new Set(ings);
        const ss = new Set(seas);
        return ADVANCED_RECIPES.find((r) => {
          if (r.method !== method) return false;
          if (r.ingredients.some((i) => !is.has(i))) return false;
          if (r.seasonings.some((s) => !ss.has(s))) return false;
          if (ings.length < 4 || seas.length < 4) return false;
          return true;
        }) || null;
      }

      function dishTags(ings, seas, method) {
        const set = new Set(ings);
        const seasoningSet = new Set(seas);
        const fish = set.has("ember fish");
        const tofu = set.has("cloud tofu");
        const veg = !fish;
        const child = (seasoningSet.has("sweet mist") || seasoningSet.has("star honey")) && !seasoningSet.has("smoke pepper");
        const elder = (method === "simmer" || method === "steam") && !seasoningSet.has("smoke pepper");
        const spicy = seasoningSet.has("smoke pepper") || seasoningSet.has("chili flake");
        const sweet = seasoningSet.has("sweet mist") || seasoningSet.has("star honey") || seasoningSet.has("night sugar");
        const herbal = seasoningSet.has("herb spiral") || seasoningSet.has("vine leaf") || seasoningSet.has("mint dust");
        const sea = seasoningSet.has("sea umami") || set.has("mist shrimp") || set.has("cobalt algae");
        const light = (method === "steam" || method === "simmer") && ings.length <= 2;
        return { fish, tofu, veg, child, elder, spicy, sweet, herbal, sea, light };
      }

      function priceClass(price) {
        if (price >= 8) return "cook-price-5";
        if (price >= 6) return "cook-price-4";
        if (price >= 5) return "cook-price-3";
        if (price >= 4) return "cook-price-2";
        return "cook-price-1";
      }

      function renderBook() {
        if (!STATE.dishes.length) {
          bookWrap.innerHTML = "<p class=\"mini-note\" style=\"margin:0;\">No dishes yet.</p>";
          return;
        }
        bookWrap.innerHTML = STATE.dishes.map((d, i) => {
          const price = Number.isFinite(d.price) ? d.price : 1;
          const fancy = d.isAdvanced ? "cook-advanced" : "";
          const priceCls = priceClass(price);
          return `<div class="cook-book-entry ${priceCls} ${fancy}">
            <b>${i + 1}. ${d.name}</b>
            <span class="cook-price-tag">Price: ${price} coin${price === 1 ? "" : "s"}</span><br>
            <span>${d.method}</span><br>
            <span>Ingredients: ${d.ingredients.join(", ")}</span><br>
            <span>Seasonings: ${d.seasonings.join(", ")}</span>
          </div>`;
        }).join("");
      }

      function renderHints() {
        if (!hintWrap) return;
        if (!STATE.hints.length) {
          hintWrap.innerHTML = "<p class=\"mini-note\" style=\"margin:0;\">No hints yet.</p>";
          return;
        }
        hintWrap.innerHTML = STATE.hints.map((idx, i) => {
          const r = ADVANCED_RECIPES[idx];
          if (!r) return "";
          return `<div class="cook-hint-item">
            <b>${i + 1}. ${r.name}</b><br>
            <span>Method: ${r.method}</span><br>
            <span>Ingredients: ${r.ingredients.join(", ")}</span><br>
            <span>Seasonings: ${r.seasonings.join(", ")}</span>
          </div>`;
        }).join("");
      }

      function renderGuidebook() {
        if (!guideWrap) return;
        guideWrap.innerHTML = CUSTOMER_TYPES.map((c) => {
          const likes = {
            fish: "Must include ember fish.",
            tofu: "Must include cloud tofu.",
            veg: "No fish; plant-based only.",
            child: "Sweet and non-smoky seasonings.",
            elder: "Gentle methods (simmer/steam) and no smoke pepper.",
            spicy: "Needs smoke pepper or chili flake.",
            sweet: "Needs sweet mist, star honey, or night sugar.",
            herbal: "Needs herb spiral, vine leaf, or mint dust.",
            sea: "Needs sea umami, mist shrimp, or cobalt algae.",
            light: "Steam/simmer with 2 or fewer ingredients.",
            chef: "Prefers herbal or sea-forward dishes.",
            traveler: "Likes spicy or sweet profiles.",
            ritual: "Prefers simmered or steamed dishes.",
            rich: "Only accepts advanced dishes. Needs two different advanced dishes to be satisfied."
          };
          return `<div class="cook-hint-item">
            <b>${c.label}</b><br>
            <span>${likes[c.id] || "No special preference."}</span>
          </div>`;
        }).join("");
      }

      function adjustReputation(delta) {
        STATE.reputation = Math.max(0, Math.min(100, STATE.reputation + delta));
        if (STATE.reputation > 0 && STATE.reputation <= 15) {
          statusOut.textContent = "Warning: Reputation is very low. One more bad service could close the restaurant.";
        }
        if (STATE.reputation <= 0) {
          statusOut.textContent = "Reputation collapsed. Restaurant closed ❌";
          makeBtn.disabled = true;
          if (serveBtn) serveBtn.disabled = true;
          if (skipBtn) skipBtn.disabled = true;
        }
      }

      function unlockMore() {
        const made = STATE.dishes.length;
        STATE.unlockedIng = Math.min(INGREDIENTS.length, 2 + Math.floor(made / 3));
        STATE.unlockedSea = Math.min(SEASONINGS.length, 2 + Math.floor(made / 3));
        STATE.unlockedMet = Math.min(METHODS.length, 2 + Math.floor(made / 5));
      }

      function clearSelections() {
        document.querySelectorAll('#create-cook input[type="checkbox"], #create-cook input[type="radio"]').forEach((i) => {
          i.checked = false;
        });
      }

      function invalidCombo(ings, seas, method) {
        const s = new Set(ings);
        const t = new Set(seas);
        const has = (x) => s.has(x);
        const hasS = (x) => t.has(x);

        if (method === "steam" && (has("iron pumpkin") || has("ember fish"))) return "Steam fails with iron pumpkin or ember fish.";
        if (method === "grill" && has("cloud tofu") && hasS("sweet mist")) return "Grilled cloud tofu with sweet mist collapses.";
        if (method === "bake" && has("river beans") && hasS("sea umami")) return "Baked river beans with sea umami turn bitter.";
        if (has("dawn berry") && hasS("smoke pepper")) return "Dawn berry and smoke pepper clash.";
        if (has("forest mushroom") && hasS("citrus ash")) return "Forest mushroom and citrus ash cancel flavor.";
        if (has("ember fish") && hasS("night sugar") && method !== "simmer") return "Ember fish with night sugar only works simmered.";
        return "";
      }

      function makeDish() {
        const ings = selectedValues("ing");
        const seas = selectedValues("sea");
        const method = selectedMethod();
        if (!ings.length || !seas.length || !method) {
          statusOut.textContent = "Pick at least 1 ingredient, 1 seasoning, and a method.";
          return;
        }
        const advanced = matchAdvanced(ings, seas, method);
        if (!advanced && (ings.length > 2 || seas.length > 2)) {
          statusOut.textContent = "Basic bowl limit is 2 ingredients and 2 seasonings. Advanced recipes need 4+ and a valid recipe.";
          return;
        }
        const invalid = advanced ? "" : invalidCombo(ings, seas, method);
        if (invalid) {
          statusOut.textContent = `No dish: ${invalid}`;
          return;
        }
        const key = makeKey(ings, seas, method);
        if (STATE.dishes.some((d) => d.key === key)) {
          statusOut.textContent = "You already made that dish.";
          return;
        }
        const name = advanced ? advanced.name : dishName(ings, seas, method);
        const tags = dishTags(ings, seas, method);
        const basePrice = 1 + Math.floor((ings.length + seas.length) / 2);
        const methodBonus = (method === "roast" || method === "grill") ? 1 : 0;
        const price = advanced ? advanced.coins : (basePrice + methodBonus);
        const coins = advanced ? advanced.coins : 0;
        const isAdvanced = Boolean(advanced);
        STATE.dishes.push({ key, name, ingredients: ings, seasonings: seas, method, tags, coins, price, isAdvanced });
        STATE.lastDish = { key, name, tags, coins, price, isAdvanced };
        if (coins) STATE.coins += coins;
        if (isAdvanced) adjustReputation(6);
        unlockMore();
        renderAll();
        clearSelections();
        if (STATE.dishes.filter((d) => d.isAdvanced).length >= ADVANCED_RECIPES.length) {
          statusOut.textContent = "Victory! All advanced recipes discovered. 🎉";
        } else {
          statusOut.textContent = coins ? `Created: ${name} (+${coins} coins)` : `Created: ${name} (price ${price})`;
        }
      }

      function encode(obj) {
        const json = JSON.stringify(obj);
        const b64 = btoa(unescape(encodeURIComponent(json)));
        return "COOK1:" + b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      }

      function decode(str) {
        if (!str.startsWith("COOK1:")) throw new Error("Invalid code (missing prefix).");
        let b64 = str.slice(6).replace(/-/g, "+").replace(/_/g, "/");
        while (b64.length % 4) b64 += "=";
        const json = decodeURIComponent(escape(atob(b64)));
        return JSON.parse(json);
      }

      makeBtn.addEventListener("click", makeDish);
      resetBtn.addEventListener("click", () => {
        clearSelections();
        statusOut.textContent = "Bowl cleared.";
      });

      function spend(cost) {
        if (STATE.coins < cost) {
          statusOut.textContent = "Not enough coins.";
          return false;
        }
        STATE.coins -= cost;
        return true;
      }

      if (unlockIngBtn) {
        unlockIngBtn.addEventListener("click", () => {
          if (STATE.unlockedIng >= INGREDIENTS.length) {
            statusOut.textContent = "All ingredients unlocked.";
            return;
          }
          if (spend(3)) {
            STATE.unlockedIng += 1;
            renderAll();
            statusOut.textContent = "Ingredient unlocked ✅";
          }
        });
      }

      if (unlockSeaBtn) {
        unlockSeaBtn.addEventListener("click", () => {
          if (STATE.unlockedSea >= SEASONINGS.length) {
            statusOut.textContent = "All seasonings unlocked.";
            return;
          }
          if (spend(3)) {
            STATE.unlockedSea += 1;
            renderAll();
            statusOut.textContent = "Seasoning unlocked ✅";
          }
        });
      }

      if (unlockMetBtn) {
        unlockMetBtn.addEventListener("click", () => {
          if (STATE.unlockedMet >= METHODS.length) {
            statusOut.textContent = "All methods unlocked.";
            return;
          }
          if (spend(5)) {
            STATE.unlockedMet += 1;
            renderAll();
            statusOut.textContent = "Method unlocked ✅";
          }
        });
      }

      if (hintBtn) {
        hintBtn.addEventListener("click", () => {
          const cost = 4;
          const available = ADVANCED_RECIPES.map((_, i) => i).filter((i) => !STATE.hints.includes(i));
          if (!available.length) {
            statusOut.textContent = "All advanced recipes already revealed.";
            return;
          }
          if (!spend(cost)) return;
          const pick = available[Math.floor(Math.random() * available.length)];
          STATE.hints.push(pick);
          renderAll();
          statusOut.textContent = "Hint revealed ✨";
        });
      }

      function newCustomer() {
        const canRich = STATE.dishes.filter((d) => d.isAdvanced).length >= 2;
        const pool = canRich ? CUSTOMER_TYPES : CUSTOMER_TYPES.filter((c) => c.id !== "rich");
        STATE.customer = pool[Math.floor(Math.random() * pool.length)];
        if (STATE.customer && STATE.customer.id !== "rich") STATE.richProgress = [];
        renderAll();
      }

      if (serveBtn) {
        serveBtn.addEventListener("click", () => {
          if (!STATE.customer) {
            statusOut.textContent = "No customer right now.";
            return;
          }
          if (!STATE.lastDish) {
            statusOut.textContent = "Make a dish first.";
            return;
          }
          if (STATE.customer.id === "rich") {
            if (!STATE.lastDish.isAdvanced) {
              adjustReputation(-6);
              statusOut.textContent = "Rich patron rejected it. Advanced dishes only.";
            } else {
              const key = STATE.lastDish.key;
              if (!STATE.richProgress.includes(key)) STATE.richProgress.push(key);
              if (STATE.richProgress.length >= 2) {
                const pay = 20;
                STATE.coins += pay;
                adjustReputation(5);
                statusOut.textContent = `Rich patron satisfied (+${pay} coins) ✨`;
                STATE.richProgress = [];
                newCustomer();
                return;
              } else {
                adjustReputation(1);
                statusOut.textContent = "Rich patron impressed. Serve a second different advanced dish.";
                return;
              }
            }
          } else if (STATE.customer.check(STATE.lastDish)) {
            const pay = Math.max(1, STATE.lastDish.price || 1);
            STATE.coins += pay;
            adjustReputation(2);
            statusOut.textContent = `Customer satisfied (+${pay} coins) ✅`;
          } else {
            adjustReputation(-4);
            statusOut.textContent = "Customer disliked it. No coins.";
          }
          newCustomer();
        });
      }

      if (skipBtn) {
        skipBtn.addEventListener("click", () => {
          statusOut.textContent = "Customer left.";
          adjustReputation(-3);
          newCustomer();
        });
      }

      if (saveBtn) {
        saveBtn.addEventListener("click", () => {
          const dishKeys = STATE.dishes.map((d) => d.key).join(";");
          const payload = {
            dishKeys,
            unlockedIng: STATE.unlockedIng,
            unlockedSea: STATE.unlockedSea,
            unlockedMet: STATE.unlockedMet,
            coins: STATE.coins,
            hints: STATE.hints,
            reputation: STATE.reputation,
            richProgress: STATE.richProgress
          };
          if (saveCode) saveCode.value = encode(payload);
          statusOut.textContent = "Save code generated ✅";
        });
      }

      if (loadBtn) {
        loadBtn.addEventListener("click", () => {
          try {
            const data = decode(saveCode.value.trim());
            const keys = typeof data.dishKeys === "string" && data.dishKeys.length
              ? data.dishKeys.split(";")
              : [];
            STATE.dishes = keys.map((key) => {
              const { method, ings, seas } = decodeKey(key);
              const advanced = matchAdvanced(ings, seas, method);
              const name = advanced ? advanced.name : dishName(ings, seas, method);
              const tags = dishTags(ings, seas, method);
              const basePrice = 1 + Math.floor((ings.length + seas.length) / 2);
              const methodBonus = (method === "roast" || method === "grill") ? 1 : 0;
              const price = advanced ? advanced.coins : (basePrice + methodBonus);
              const coins = advanced ? advanced.coins : 0;
              return { key, name, ingredients: ings, seasonings: seas, method, tags, coins, price, isAdvanced: Boolean(advanced) };
            });
            STATE.unlockedIng = Math.min(INGREDIENTS.length, data.unlockedIng || 2);
            STATE.unlockedSea = Math.min(SEASONINGS.length, data.unlockedSea || 2);
            STATE.unlockedMet = Math.min(METHODS.length, data.unlockedMet || 2);
            STATE.coins = Number.isFinite(data.coins) ? data.coins : 0;
            STATE.hints = Array.isArray(data.hints)
              ? data.hints.filter((i) => Number.isInteger(i) && i >= 0 && i < ADVANCED_RECIPES.length)
              : [];
            STATE.reputation = Number.isFinite(data.reputation) ? data.reputation : 50;
            STATE.richProgress = Array.isArray(data.richProgress) ? data.richProgress : [];
            STATE.lastDish = STATE.dishes.length ? STATE.dishes[STATE.dishes.length - 1] : null;
            renderAll();
            statusOut.textContent = "Save loaded ✅";
          } catch (e) {
            statusOut.textContent = `Error: ${e.message}`;
          }
        });
      }

      newCustomer();
      renderAll();
    })();

    // ===== Create: Car Innovation =====
    (function () {
      const optionsWrap = document.getElementById("carInnovationOptions");
      const generateBtn = document.getElementById("carGenerate");
      const resetBtn = document.getElementById("carReset");
      const resultsBox = document.getElementById("carResults");
      const shareInput = document.getElementById("carShareCode");
      const shareApplyBtn = document.getElementById("carShareApply");
      const shareClearBtn = document.getElementById("carShareClear");
      const shareStatus = document.getElementById("carShareStatus");
      const shareCode = document.getElementById("shareCode");
      const shareApply = document.getElementById("shareApply");
      const fullNameOut = document.getElementById("fullNameOut");

      if (!optionsWrap || !generateBtn || !resetBtn || !resultsBox) return;

      const USES = [
        { id: "city", label: "City Commuter", desc: "Efficient, quiet, and easy to park. Perfect for daily urban driving." },
        { id: "adventure", label: "Adventure Explorer", desc: "Stable on rough terrain with endurance for long journeys." },
        { id: "racing", label: "Performance Sprint", desc: "Lightweight, high power, and sharp response for speed." },
        { id: "family", label: "Family Comfort", desc: "Safe, spacious, and smooth for group travel." },
        { id: "cargo", label: "Cargo Carrier", desc: "Built to haul and carry with steady reliability." },
        { id: "luxury", label: "Luxury Lounge", desc: "Premium comfort and elegance with smart tech." },
        { id: "eco", label: "Eco Pioneer", desc: "Low footprint with maximum efficiency." }
      ];

      const CATEGORIES = [
        {
          title: "Power & Energy",
          options: [
            { label: "Twin-motor electric", scores: { eco: 3, city: 2, luxury: 1 } },
            { label: "Hybrid core", scores: { eco: 2, family: 2, city: 1 } },
            { label: "Turbo performance", scores: { racing: 3, adventure: 1 } },
            { label: "Diesel endurance", scores: { cargo: 2, adventure: 2 } },
            { label: "Hydrogen cell", scores: { eco: 3, adventure: 1, luxury: 1 } },
            { label: "Biofuel drive", scores: { eco: 2, cargo: 1, city: 1 } },
            { label: "Solar range extender", scores: { eco: 3, city: 1 } },
            { label: "Quiet luxury motor", scores: { luxury: 3, city: 1 } },
            { label: "High-torque crawler", scores: { adventure: 3, cargo: 1 } },
            { label: "Urban eco cell", scores: { city: 3, eco: 3 } },
            { label: "Industrial haul core", scores: { cargo: 3, adventure: 2 } },
            { label: "Family silent drive", scores: { family: 3, luxury: 2 } }
          ]
        },
        {
          title: "Body & Frame",
          options: [
            { label: "Lightweight carbon shell", scores: { racing: 3, city: 1 } },
            { label: "Reinforced steel frame", scores: { cargo: 2, adventure: 2 } },
            { label: "Compact city frame", scores: { city: 3, eco: 1 } },
            { label: "Extended cabin body", scores: { family: 3, cargo: 1 } },
            { label: "Elevated off-road chassis", scores: { adventure: 3, cargo: 1 } },
            { label: "Aero coupe shell", scores: { racing: 2, luxury: 1, city: 1 } },
            { label: "Impact-safe shell", scores: { family: 2, city: 2 } },
            { label: "Long-range touring body", scores: { luxury: 2, adventure: 1 } },
            { label: "Luxury aero frame", scores: { luxury: 3, racing: 2 } },
            { label: "Cargo lattice frame", scores: { cargo: 3, family: 1 } },
            { label: "Eco feather shell", scores: { eco: 2, city: 2 } }
          ]
        },
        {
          title: "Drive & Control",
          options: [
            { label: "All-wheel traction", scores: { adventure: 3, family: 1 } },
            { label: "Precision sport steering", scores: { racing: 2, city: 1 } },
            { label: "Comfort cruise assist", scores: { family: 2, luxury: 2 } },
            { label: "Smart eco drive", scores: { eco: 2, city: 1 } },
            { label: "Adaptive dampers", scores: { luxury: 2, adventure: 1 } },
            { label: "Launch control", scores: { racing: 3 } },
            { label: "Ultra-stable braking", scores: { family: 2, city: 1 } },
            { label: "Auto terrain scan", scores: { adventure: 2, eco: 1 } },
            { label: "City glide control", scores: { city: 3, eco: 1 } },
            { label: "Cargo torque vectoring", scores: { cargo: 2, adventure: 1 } },
            { label: "Family comfort lock", scores: { family: 3, luxury: 1 } },
            { label: "Eco pulse drive", scores: { eco: 3, city: 1 } },
            { label: "Luxury serenity drive", scores: { luxury: 3, city: 1 } }
          ]
        },
        {
          title: "Cabin & Tech",
          options: [
            { label: "Panoramic luxury cabin", scores: { luxury: 3, family: 1 } },
            { label: "Minimalist eco cabin", scores: { eco: 2, city: 1 } },
            { label: "Modular cargo interior", scores: { cargo: 3, family: 1 } },
            { label: "Track-ready cockpit", scores: { racing: 2, luxury: 1 } },
            { label: "Family safety suite", scores: { family: 3, city: 1 } },
            { label: "Adventure navigation rig", scores: { adventure: 2, luxury: 1 } },
            { label: "Executive lounge seats", scores: { luxury: 3 } },
            { label: "Cargo command console", scores: { cargo: 2, adventure: 1 } },
            { label: "City smart dash", scores: { city: 3, eco: 1 } },
            { label: "Eco airy cabin", scores: { eco: 3, city: 1 } },
            { label: "Sprint HUD rig", scores: { racing: 3 } }
          ]
        },
        {
          title: "Utility & Extras",
          options: [
            { label: "Roof storage system", scores: { cargo: 2, adventure: 1 } },
            { label: "Terrain adaptive kit", scores: { adventure: 3 } },
            { label: "Urban safety package", scores: { city: 2, family: 1 } },
            { label: "Premium audio suite", scores: { luxury: 2, family: 1 } },
            { label: "Fold-flat cargo deck", scores: { cargo: 3, family: 1 } },
            { label: "Eco regeneration kit", scores: { eco: 2, city: 1 } },
            { label: "Rapid charging port", scores: { city: 2, eco: 1 } },
            { label: "All-weather canopy", scores: { adventure: 2, family: 1 } },
            { label: "Sprint aero kit", scores: { racing: 2, city: 1 } },
            { label: "Family comfort pack", scores: { family: 2, luxury: 1 } },
            { label: "Eco solar roof", scores: { eco: 3, city: 1 } },
            { label: "City micro-park system", scores: { city: 2 } }
          ]
        }
      ];

      let cachedName = "";
      let lastCarCanvas = null;

      function renderOptions() {
        optionsWrap.innerHTML = "";
        CATEGORIES.forEach((cat, cIdx) => {
          const card = document.createElement("div");
          card.className = "info-card";
          const title = document.createElement("h4");
          title.style.margin = "0";
          title.textContent = cat.title;
          card.appendChild(title);

          const list = document.createElement("div");
          list.className = "car-list";

          cat.options.forEach((opt, oIdx) => {
            const label = document.createElement("label");
            label.className = "car-item";
            const input = document.createElement("input");
            input.type = "checkbox";
            input.name = `car_opt_${cIdx}_${oIdx}`;
            input.dataset.cat = String(cIdx);
            input.dataset.opt = String(oIdx);
            const span = document.createElement("span");
            span.textContent = opt.label;
            label.appendChild(input);
            label.appendChild(span);
            list.appendChild(label);
          });

          card.appendChild(list);
          optionsWrap.appendChild(card);
        });
      }

      function selectedOptions() {
        const inputs = Array.from(optionsWrap.querySelectorAll("input[type=\"checkbox\"]:checked"));
        return inputs.map((input) => {
          const cIdx = parseInt(input.dataset.cat, 10);
          const oIdx = parseInt(input.dataset.opt, 10);
          return CATEGORIES[cIdx].options[oIdx];
        });
      }

      function scoreUses(opts) {
        const scores = {};
        USES.forEach((u) => { scores[u.id] = 0; });
        opts.forEach((opt) => {
          Object.entries(opt.scores).forEach(([use, val]) => {
            scores[use] += val;
          });
        });
        return scores;
      }

      function maxUsePossible() {
        const maxByUse = {};
        USES.forEach((u) => { maxByUse[u.id] = 0; });
        CATEGORIES.forEach((cat) => {
          USES.forEach((u) => {
            let best = 0;
            cat.options.forEach((opt) => {
              const val = opt.scores[u.id] || 0;
              if (val > best) best = val;
            });
            maxByUse[u.id] += best;
          });
        });
        return maxByUse;
      }

      function bestUse(scores) {
        return USES.reduce((best, cur) => {
          if (!best) return cur;
          return scores[cur.id] > scores[best.id] ? cur : best;
        }, null);
      }

      function getThemeVar(name, fallback) {
        const val = getComputedStyle(document.body).getPropertyValue(name).trim();
        return val || fallback;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let yy = y;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + " ";
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x, yy);
            line = words[i] + " ";
            yy += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, yy);
        return yy + lineHeight;
      }

      function concatBytes(chunks) {
        let total = 0;
        chunks.forEach((c) => { total += c.length; });
        const out = new Uint8Array(total);
        let offset = 0;
        chunks.forEach((c) => {
          out.set(c, offset);
          offset += c.length;
        });
        return out;
      }

      function buildPdfFromJpeg(jpegBytes, width, height) {
        const enc = new TextEncoder();
        const chunks = [];
        let offset = 0;
        const xref = [];

        function pushStr(s) {
          const b = enc.encode(s);
          chunks.push(b);
          offset += b.length;
        }
        function pushBytes(b) {
          chunks.push(b);
          offset += b.length;
        }

        pushStr("%PDF-1.3\n");
        xref.push(offset); pushStr("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
        xref.push(offset); pushStr("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
        xref.push(offset); pushStr(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`);
        xref.push(offset); pushStr(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`);
        pushBytes(jpegBytes);
        pushStr("\nendstream\nendobj\n");
        const content = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        const contentBytes = enc.encode(content);
        xref.push(offset); pushStr(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
        pushBytes(contentBytes);
        pushStr("\nendstream\nendobj\n");

        const xrefStart = offset;
        pushStr("xref\n0 6\n0000000000 65535 f \n");
        xref.forEach((pos) => {
          const line = String(pos).padStart(10, "0") + " 00000 n \n";
          pushStr(line);
        });
        pushStr(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`);
        return concatBytes(chunks);
      }

      function buildCarCard(best, scores, selections, overallScore) {
        const canvas = document.createElement("canvas");
        canvas.width = 900;
        canvas.height = 560;
        const ctx = canvas.getContext("2d");

        const bg = getThemeVar("--bg-2", "#15182a");
        const surface = getThemeVar("--surface", "rgba(255,255,255,0.06)");
        const text = getThemeVar("--text", "#e8e8e8");
        const heading = getThemeVar("--heading", "#ffffff");
        const accent = getThemeVar("--accent", "#c6a664");
        const accent2 = getThemeVar("--accent-2", "#9bc1ff");

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = surface;
        ctx.fillRect(24, 24, canvas.width - 48, canvas.height - 48);

        ctx.fillStyle = heading;
        ctx.font = "700 26px serif";
        ctx.fillText("SPERTZ Car Innovation", 48, 70);

        ctx.fillStyle = accent2;
        ctx.font = "700 36px serif";
        ctx.fillText(best.label, 48, 120);

        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        let yy = wrapText(ctx, best.desc, 48, 152, 520, 22);

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Overall score", 48, yy + 12);
        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        ctx.fillText(`${overallScore}/1000`, 48, yy + 36);
        yy += 40;

        if (cachedName) {
          ctx.fillStyle = accent;
          ctx.font = "600 14px sans-serif";
          ctx.fillText("Name", 48, yy + 14);
          ctx.fillStyle = text;
          ctx.font = "16px sans-serif";
          ctx.fillText(cachedName, 48, yy + 38);
          yy += 40;
        }

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Selected features", 48, yy + 12);
        ctx.fillStyle = text;
        ctx.font = "13px sans-serif";
        const featureText = selections.slice(0, 12).join(" · ");
        wrapText(ctx, featureText || "—", 48, yy + 32, 800, 18);

        const startX = 580;
        let barY = 120;
        const barW = 260;
        const barH = 12;
        const maxScore = Math.max(...USES.map((u) => scores[u.id]));

        ctx.fillStyle = heading;
        ctx.font = "600 13px sans-serif";
        USES.forEach((u) => {
          const val = scores[u.id];
          const pct = maxScore > 0 ? val / maxScore : 0;
          ctx.fillText(`${u.label}: ${val}`, startX, barY - 6);
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.fillRect(startX, barY, barW, barH);
          ctx.fillStyle = accent2;
          ctx.fillRect(startX, barY, barW * pct, barH);
          barY += 30;
          ctx.fillStyle = heading;
        });

        return canvas;
      }

      function downloadPng(canvas) {
        const link = document.createElement("a");
        link.download = "spertz-car-certificate.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      function downloadPdf(canvas) {
        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const pdfBytes = buildPdfFromJpeg(bytes, canvas.width, canvas.height);
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "spertz-car-certificate.pdf";
        link.click();
        URL.revokeObjectURL(url);
      }

      function generateResults() {
        const opts = selectedOptions();
        if (!opts.length) {
          resultsBox.innerHTML = `
            <div class="personality-card">
              <h3 style="margin:0;">Select at least one feature</h3>
              <p class="mini-note" style="margin-top:8px;">Choose some options to calculate your car’s best use.</p>
            </div>
          `;
          return;
        }

        const scores = scoreUses(opts);
        const selections = opts.map((o) => o.label);
        const maxPossibleByUse = maxUsePossible();
        const globalMax = Math.max(...Object.values(maxPossibleByUse));
        const scaledScores = {};
        USES.forEach((u) => {
          const maxVal = maxPossibleByUse[u.id] || 1;
          const factor = maxVal > 0 ? globalMax / maxVal : 1;
          scaledScores[u.id] = Math.round((scores[u.id] || 0) * factor);
        });
        const best = bestUse(scaledScores);
        const rawMax = globalMax || 1;
        const baseScore = (scaledScores[best.id] / rawMax) * 1000;
        const totalCategories = CATEGORIES.length;
        const extraChoices = Math.max(0, selections.length - totalCategories);
        const clutterPenalty = 1 - Math.min(0.6, (extraChoices / (totalCategories * 2)) * 0.6);
        const overallScore = Math.max(0, Math.min(1000, Math.round(baseScore * clutterPenalty)));

        resultsBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Best use: ${best.label}</h3>
            <p class="mini-note" style="margin-top:8px;">${best.desc}</p>
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              <span class="car-tag">Features: ${selections.length}</span>
              <span class="car-tag">Overall: ${overallScore}/1000</span>
              ${cachedName ? `<span class="car-tag">Name: ${cachedName}</span>` : ""}
            </div>
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Scores</h4>
            <div class="car-score" style="margin-top:8px;">
              ${USES.map((u) => {
                const val = scaledScores[u.id];
                const maxVal = globalMax || 1;
                const pct = maxVal > 0 ? Math.round((val / maxVal) * 100) : 0;
                return `
                  <div class="car-score-row">
                    <div>
                      <b>${u.label}</b> <span class="mini-note">(${val}/${maxVal})</span>
                      <div class="car-bar"><span style="width:${pct}%;"></span></div>
                    </div>
                    <span class="mini-note">${pct}%</span>
                  </div>
                `;
              }).join("")}
            </div>
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Download your certificate</h4>
            <p class="mini-note" style="margin-top:8px;">Save a PNG or PDF certificate for your car design.</p>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button id="carDownloadPng" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PNG</span>
                <span class="acc-icon">⬇</span>
              </button>
              <button id="carDownloadPdf" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PDF</span>
                <span class="acc-icon">⬇</span>
              </button>
            </div>
          </div>
        `;

        lastCarCanvas = buildCarCard(best, scores, selections, overallScore);
        resultsBox.querySelector("#carDownloadPng")?.addEventListener("click", () => downloadPng(lastCarCanvas));
        resultsBox.querySelector("#carDownloadPdf")?.addEventListener("click", () => downloadPdf(lastCarCanvas));
        resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      function resetAll() {
        optionsWrap.querySelectorAll("input[type=\"checkbox\"]").forEach((input) => {
          input.checked = false;
        });
        resultsBox.innerHTML = "";
      }

      if (shareApplyBtn) {
        shareApplyBtn.addEventListener("click", () => {
          const code = shareInput ? shareInput.value.trim() : "";
          if (!code) {
            shareStatus.textContent = "Please paste a share code first.";
            return;
          }
          if (shareCode && shareApply) {
            shareCode.value = code;
            shareApply.click();
            cachedName = (fullNameOut && fullNameOut.textContent && fullNameOut.textContent !== "—") ? fullNameOut.textContent : "";
            shareStatus.textContent = cachedName ? "Code loaded ✅" : "Code loaded (name not found).";
          } else {
            shareStatus.textContent = "Share system not available.";
          }
        });
      }

      if (shareClearBtn) {
        shareClearBtn.addEventListener("click", () => {
          if (shareInput) shareInput.value = "";
          cachedName = "";
          shareStatus.textContent = "No code loaded.";
        });
      }

      generateBtn.addEventListener("click", generateResults);
      resetBtn.addEventListener("click", resetAll);

      renderOptions();
    })();

    // ===== Create: Kopahor Quest =====
    (function () {
      const chapterOut = document.getElementById("questChapter");
      const sceneOut = document.getElementById("questSceneText");
      const choicesWrap = document.getElementById("questChoices");
      const outcomeBox = document.getElementById("questOutcome");
      const continueBtn = document.getElementById("questContinue");
      const metersWrap = document.getElementById("questMeters");
      const resultsBox = document.getElementById("questResults");
      const guideWrap = document.getElementById("questGuideList");
      const shareInput = document.getElementById("questShareCode");
      const shareApplyBtn = document.getElementById("questShareApply");
      const shareClearBtn = document.getElementById("questShareClear");
      const shareStatus = document.getElementById("questShareStatus");
      const shareCode = document.getElementById("shareCode");
      const shareApply = document.getElementById("shareApply");
      const fullNameOut = document.getElementById("fullNameOut");

      if (!chapterOut || !sceneOut || !choicesWrap || !metersWrap || !resultsBox) return;

      const TRAITS = [
        { id: "bold", label: "Bold" },
        { id: "cautious", label: "Cautious" },
        { id: "diplomatic", label: "Diplomatic" },
        { id: "strategic", label: "Strategic" },
        { id: "compassionate", label: "Compassionate" },
        { id: "innovative", label: "Innovative" }
      ];

      const STATS = [
        { id: "supplies", label: "Supplies" },
        { id: "health", label: "Health" },
        { id: "morale", label: "Morale" },
        { id: "diplomacy", label: "Diplomacy" },
        { id: "force", label: "Force" },
        { id: "tech", label: "Tech" },
        { id: "economy", label: "Economy" }
      ];

      const SCENES = [
        { chapter: "Phase 0 — League Summit", text: "Kopahor, Whereland, Onia, and Pesimura meet as one Spertz League. Onia is the economic center. You must negotiate what Onia is willing to fund.", choices: [
          { label: "Present a full budget and accept strict audits.", effects: { coins: 120, diplomacy: 3, economy: 2, morale: -2, time: 2 }, traits: { strategic: 1 }, outcome: "You lay out the full budget in public session, letting Onia’s auditors trace every line. The economic council approves a large grant, but their clerks now monitor your decisions. Your own ministers feel the pressure of scrutiny and speak more cautiously." },
          { label: "Offer shared risk and partial repayment.", effects: { coins: 90, diplomacy: 2, economy: 1, morale: -1, time: 1 }, traits: { diplomatic: 1 }, outcome: "You propose a shared-risk plan that splits the burden across the league. Onia agrees to steady funding, expecting repayment after the crystal is secured. The compromise keeps the room calm, though no one leaves fully satisfied." },
          { label: "Reject strings and seek a small, independent grant.", effects: { coins: 55, morale: 1, diplomacy: -2, economy: -1 }, traits: { bold: 1 }, outcome: "You refuse conditions and ask only for a modest, clean grant. The smaller sum is approved quickly, and Kopahor keeps full control. Some partners read the move as stubborn, while your core supporters feel relieved." }
        ]},
        { chapter: "Phase 0 — League Summit", text: "Transportation must be chosen for the southern journey. Advanced tech is available.", choices: [
          { label: "Armored caravan cars with spare parts.", effects: { coins: -35, supplies: 3, health: 2, time: 3 }, traits: { strategic: 1 }, outcome: "You choose armored caravan cars and load extra parts. The convoy becomes durable and disciplined, but the fuel and maintenance strain your treasury. The team feels safer, though the convoy’s weight limits quick detours." },
          { label: "Ice-cap ship through dangerous waters.", effects: { coins: -20, supplies: 2, time: 7, morale: -2, health: -1 }, traits: { cautious: 1 }, outcome: "You commission an ice-cap ship and route the expedition along the southern waters. The sea is slower but reliable for cargo, and the crew adjusts to harsh winds. The long crossing wears on morale, yet the supplies arrive intact." },
          { label: "Sky-rail convoy with Whereland engines.", effects: { coins: -50, tech: 4, time: 1, morale: 1, economy: -2 }, traits: { innovative: 1 }, outcome: "You commit to the sky-rail with Whereland engines, buying speed and altitude. The convoy lifts above hazards, and engineers document valuable performance data. The cost is immense, and every mechanical failure now feels like a crisis." }
        ]},
        { chapter: "Phase 0 — League Summit", text: "How many people do you bring on the quest?", choices: [
          { label: "Small elite team for speed.", effects: { force: 2, supplies: -2, coins: -5, people: -40, morale: -1 }, traits: { strategic: 1 }, outcome: "You assemble a lean expedition of specialists and veterans. The small team moves fast and takes decisive action without delay. Families at home worry about the lack of backup, but the leaders value precision." },
          { label: "Balanced expedition force.", effects: { force: 2, morale: 2, supplies: -4, coins: -10, people: 0, time: 1 }, traits: { diplomatic: 1 }, outcome: "You select a balanced force that can endure long travel and hold ground. The mix of soldiers, engineers, and medics reassures the league. The expedition feels steady rather than bold, and expectations rise." },
          { label: "Large public expedition to inspire citizens.", effects: { morale: 4, force: 1, supplies: -6, coins: -20, people: 60, time: 2 }, traits: { compassionate: 1 }, outcome: "You call for a large public expedition and invite volunteers. The crowds cheer and the nation feels united behind the quest. The caravan grows heavy, and feeding so many mouths becomes a daily strain." }
        ]},
        { chapter: "Phase 0 — League Summit", text: "Clothing for harsh climates must be purchased.", choices: [
          { label: "Standard winter gear.", effects: { health: 2, coins: -8, economy: -1 }, traits: { cautious: 1 }, outcome: "You buy standard winter gear in bulk and distribute it evenly. The supply is reliable, if not exceptional, and the march stabilizes. The treasury loses some flexibility, but the team stays warm." },
          { label: "Whereland thermal tech suits.", effects: { health: 4, tech: 2, coins: -18, morale: -1 }, traits: { innovative: 1 }, outcome: "You invest in Whereland thermal suits that adapt to climate shifts. The crew becomes noticeably more resilient in cold zones, and the tech logs prove valuable. The expense is steep, and skeptics call it indulgent." },
          { label: "Minimal gear to save coins.", effects: { coins: 5, health: -6, morale: -2 }, traits: { bold: 1 }, outcome: "You cut gear orders to conserve coins and reduce load. The caravan moves lighter, but cold nights cut deeper. Grumbles spread through the ranks as the weather turns against you." }
        ]},
        { chapter: "Phase 0 — League Summit", text: "How much food supplies do you bring?", choices: [
          { label: "Heavy rations for long safety.", effects: { supplies: 12, coins: -15, time: 2, morale: 1 }, traits: { cautious: 1 }, outcome: "You fill the cargo modules with heavy rations to secure the march. The camp feels safe, and planning becomes easier. The extra weight slows departures and makes the convoy harder to maneuver." },
          { label: "Balanced rations with periodic resupply.", effects: { supplies: 7, coins: -8, time: 1 }, traits: { strategic: 1 }, outcome: "You choose balanced rations and plan for resupply points. The caravan keeps momentum and still has reserves. The gamble rests on reliable trade routes and timely markets." },
          { label: "Light rations for speed.", effects: { supplies: 3, coins: -2, health: -2, morale: -1 }, traits: { bold: 1 }, outcome: "You take light rations to keep the convoy fast. The march accelerates, but hunger becomes a real threat during delays. The decision feels daring, and not everyone agrees." }
        ]},
        { chapter: "Phase 0 — League Summit", text: "Whereland (tech center) offers a field kit for survival analytics.", choices: [
          { label: "Purchase the full kit.", effects: { tech: 4, coins: -12, economy: -1 }, traits: { innovative: 1 }, outcome: "You purchase the full analytics kit and assign an expert team to it. The sensors begin mapping risk, weather, and terrain in real time. The kit becomes a strategic advantage, though its cost is felt everywhere." },
          { label: "Buy a lighter version.", effects: { tech: 2, coins: -6, time: 1 }, traits: { strategic: 1 }, outcome: "You buy the compact kit and focus it on high-risk zones. The data helps, but gaps remain in coverage. The team appreciates the balance between cost and utility." },
          { label: "Decline to keep budget flexible.", effects: { economy: 2, coins: 4, tech: -2 }, traits: { cautious: 1 }, outcome: "You decline the kit to preserve liquidity. The budget stays flexible, and local scouts gain more responsibility. Some engineers worry you are walking blind into the south." }
        ]},
        { chapter: "Phase I — The Southern March", text: "Your coalition departs into harsh climates; delays mean harsher seasons. Citizens watch closely. How do you start the march?", choices: [
          { label: "Hold a public sendoff to raise morale.", effects: { morale: 4, coins: -6, time: 2 }, traits: { compassionate: 1 }, outcome: "You stage a public sendoff in the capital square. Cheers and songs echo behind the convoy, lifting spirits. The ceremony costs time and coin, but the nation watches with pride." },
          { label: "Leave quietly to save time.", effects: { time: 1, diplomacy: 1, morale: -1 }, traits: { strategic: 1 }, outcome: "You depart before dawn to conserve time and avoid ceremony. The convoy moves quickly, and officials fall into a steady rhythm. Some citizens feel left behind by the sudden silence." },
          { label: "Launch with a show of force to deter attacks.", effects: { force: 2, morale: 1, coins: -4 }, traits: { bold: 1 }, outcome: "You lead a forceful departure with banners and armored guards. Predators and raiders keep their distance as the march begins. The display costs coin and raises expectations of strength." }
        ]},
        { chapter: "Phase I — The Southern March", text: "A mountain storm forms at the pass.", choices: [
          { label: "Push through to keep schedule.", effects: { health: -6, morale: 3, supplies: -3 }, traits: { bold: 1 } },
          { label: "Camp and ration carefully.", effects: { supplies: -2, health: 2 }, traits: { cautious: 1 } },
          { label: "Use heat sigils and experimental tech.", effects: { tech: 4, supplies: -4 }, traits: { innovative: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A herd of wild beasts circles your convoy.", choices: [
          { label: "Scare them off with fireworks.", effects: { supplies: -2, morale: 4 }, traits: { bold: 1 } },
          { label: "Offer food to avoid conflict.", effects: { supplies: -4, health: 2 }, traits: { compassionate: 1 } },
          { label: "Set a silent detour through ravines.", effects: { health: -2, supplies: -1, diplomacy: 1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Early Phase I, a riverside settlement offers fish and clean water (shop available).", choices: [
          { label: "Buy fresh supplies for the camp.", effects: { supplies: 7, health: 1, coins: -10 }, traits: { compassionate: 1 } },
          { label: "Buy a small ration boost.", effects: { supplies: 3, coins: -4 }, traits: { strategic: 1 } },
          { label: "Skip the stop to keep moving.", effects: { morale: -1, economy: 1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Your scouts spot hostile beasts on the ice lake.", choices: [
          { label: "Cross fast and light, leaving heavy carts.", effects: { supplies: -6, health: 4 }, traits: { bold: 1 } },
          { label: "Build a temporary bridge and move safely.", effects: { tech: 3, supplies: -3 }, traits: { strategic: 1 } },
          { label: "Wait for the beasts to move on.", effects: { morale: -2, health: 2 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A sudden sickness spreads in the camp.", choices: [
          { label: "Quarantine and slow down.", effects: { health: 6, morale: -2 }, traits: { compassionate: 1 } },
          { label: "Continue marching and trust resilience.", effects: { health: -6, morale: 3 }, traits: { bold: 1 } },
          { label: "Use experimental remedies from the archives.", effects: { tech: 3, health: 2, morale: -1 }, traits: { innovative: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A convoy leader asks for better weather gear.", choices: [
          { label: "Redistribute supplies evenly.", effects: { supplies: -2, morale: 4 }, traits: { compassionate: 1 } },
          { label: "Keep elite units prioritized.", effects: { morale: -3, force: 3 }, traits: { strategic: 1 } },
          { label: "Purchase gear from traveling artisans.", effects: { economy: -3, morale: 2 }, traits: { diplomatic: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A river floods the supply trail.", choices: [
          { label: "Risk the crossing to save time.", effects: { supplies: -4, health: -2, morale: 3 }, traits: { bold: 1 } },
          { label: "Construct a ferry system.", effects: { tech: 2, supplies: -2 }, traits: { strategic: 1 } },
          { label: "Reroute through the forest.", effects: { supplies: -2, morale: -1, diplomacy: 1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Your guards suggest training local hunters for protection.", choices: [
          { label: "Accept and pay them well.", effects: { force: 3, economy: -2, diplomacy: 2 }, traits: { diplomatic: 1 } },
          { label: "Use only royal troops.", effects: { force: 2, morale: -2 }, traits: { bold: 1 } },
          { label: "Train a mixed squad with new tactics.", effects: { tech: 2, force: 2, supplies: -1 }, traits: { innovative: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A rockslide blocks the main pass.", choices: [
          { label: "Dig through to avoid delay.", effects: { health: -3, supplies: -2, morale: 2 }, traits: { bold: 1 } },
          { label: "Set up a base camp until safe.", effects: { morale: -2, health: 2 }, traits: { cautious: 1 } },
          { label: "Search for an alternate tunnel route.", effects: { tech: 2, supplies: -2 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A convoy transport unit breaks down.", choices: [
          { label: "Salvage parts to reinforce other carts.", effects: { supplies: -2, tech: 2 }, traits: { strategic: 1 } },
          { label: "Send a rescue party to the nearest town.", effects: { diplomacy: 2, economy: -2 }, traits: { diplomatic: 1 } },
          { label: "Leave the unit behind to keep moving.", effects: { supplies: -3, morale: -1, force: 1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Night predators stalk the camp.", choices: [
          { label: "Set loud deterrents and perimeter lights.", effects: { supplies: -2, morale: 2 }, traits: { innovative: 1 } },
          { label: "Quietly relocate to higher ground.", effects: { health: 2, morale: -1 }, traits: { cautious: 1 } },
          { label: "Lead a counter-hunt.", effects: { force: 2, health: -2, morale: 2 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Mid Phase I, a desert caravan offers supplies at a crossroads (shop available).", choices: [
          { label: "Trade for sun-dried provisions.", effects: { supplies: 8, coins: -11 }, traits: { diplomatic: 1 } },
          { label: "Purchase a smaller reserve and move on.", effects: { supplies: 4, coins: -5 }, traits: { cautious: 1 } },
          { label: "Decline the trade and keep speed.", effects: { morale: -1, economy: 1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "A storm ruins a portion of food stores.", choices: [
          { label: "Ration tightly and continue.", effects: { supplies: -4, morale: -2, economy: 1 }, traits: { cautious: 1 } },
          { label: "Organize a foraging sweep.", effects: { supplies: 2, health: -2 }, traits: { bold: 1 } },
          { label: "Trade with nomads for replacement.", effects: { economy: -2, diplomacy: 3 }, traits: { diplomatic: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Early in the march, a trading outpost offers rare rations at a high cost (shop available).", choices: [
          { label: "Buy enough for weeks of travel.", effects: { supplies: 10, coins: -18, economy: -4 }, traits: { cautious: 1 } },
          { label: "Negotiate for a fairer price.", effects: { diplomacy: 4, supplies: 6, coins: -10 }, traits: { diplomatic: 1 } },
          { label: "Decline and press on with existing stock.", effects: { morale: -2, economy: 2 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Your scientist proposes mapping energy vents for heat.", choices: [
          { label: "Approve the survey immediately.", effects: { tech: 4, supplies: -2 }, traits: { innovative: 1 } },
          { label: "Delay until the camp stabilizes.", effects: { health: 2, tech: -1 }, traits: { cautious: 1 } },
          { label: "Assign a small team to test the idea.", effects: { tech: 2, supplies: -1 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Midway through Phase I, a roadside market appears (shop available).", choices: [
          { label: "Buy compact rations for quick travel.", effects: { supplies: 6, coins: -9 }, traits: { strategic: 1 } },
          { label: "Buy only a small emergency stash.", effects: { supplies: 3, coins: -4 }, traits: { cautious: 1 } },
          { label: "Skip the market to save coins.", effects: { economy: 1, morale: -1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "Late Phase I, a mountain pass trading post opens a brief supply window (shop available).", choices: [
          { label: "Buy heated rations and blankets.", effects: { supplies: 7, health: 2, coins: -12 }, traits: { cautious: 1 } },
          { label: "Buy only fuel and water.", effects: { supplies: 4, coins: -6 }, traits: { strategic: 1 } },
          { label: "Skip to avoid the inflated prices.", effects: { economy: 1, morale: -1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase I — The Southern March", text: "The southern council refuses the crystal; they want it for their own wealth. The Spertz League stays united. Your response?", choices: [
          { label: "Offer a treaty of shared energy research.", effects: { diplomacy: 6, economy: -2, coins: -4 }, traits: { diplomatic: 1 } },
          { label: "Demand the crystal on behalf of the league.", effects: { force: 2, diplomacy: -4, morale: 2 }, traits: { bold: 1 } },
          { label: "Withdraw to regroup and plan with allies.", effects: { morale: -1, diplomacy: 1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "You call the league centers: Pesimura (army), Whereland (tech), and Onia (economy). How do you frame the alliance plan?", choices: [
          { label: "Promise logistics routes to Pesimura in exchange for troop training.", effects: { diplomacy: 3, force: 1, economy: -1 }, traits: { diplomatic: 1 } },
          { label: "Offer a joint research pact to Whereland.", effects: { tech: 3, diplomacy: 1, coins: -4 }, traits: { innovative: 1 } },
          { label: "Ask Onia for emergency markets and strict discipline.", effects: { economy: 2, force: 2, morale: -1 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "You must train the army quickly.", choices: [
          { label: "Focus on rapid drills and morale chants.", effects: { force: 2, morale: 2, tech: -1 }, traits: { bold: 1 } },
          { label: "Train elite units with new tactics.", effects: { force: 3, tech: 1, morale: -1 }, traits: { strategic: 1 } },
          { label: "Keep training safe and inclusive.", effects: { morale: 3, force: -1 }, traits: { compassionate: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Whereland offers prototype shield tech.", choices: [
          { label: "Deploy immediately despite risks.", effects: { tech: 4, morale: -2 }, traits: { bold: 1 } },
          { label: "Test in controlled drills first.", effects: { tech: 2, force: 1, morale: -1 }, traits: { cautious: 1 } },
          { label: "Integrate only with elite squads.", effects: { tech: 2, force: 1, morale: -2 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "The economy strains under war prep.", choices: [
          { label: "Increase taxes temporarily.", effects: { economy: 3, morale: -2 }, traits: { strategic: 1 } },
          { label: "Rally donations with public ceremonies.", effects: { economy: 2, diplomacy: 1, force: -1 }, traits: { diplomatic: 1 } },
          { label: "Reduce non-military spending.", effects: { economy: 2, morale: -1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Pesimura asks for a cultural exchange as payment.", choices: [
          { label: "Agree and host a grand summit.", effects: { diplomacy: 4, economy: -1 }, traits: { diplomatic: 1 } },
          { label: "Decline to keep focus on the war.", effects: { force: 2, diplomacy: -2 }, traits: { bold: 1 } },
          { label: "Offer limited exchange with strict terms.", effects: { diplomacy: 2, economy: 1, morale: -1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "A new technology could reduce casualties.", choices: [
          { label: "Invest heavily in it.", effects: { tech: 4, economy: -3 }, traits: { innovative: 1 } },
          { label: "Use it only for defense.", effects: { tech: 2, force: 1, diplomacy: -1 }, traits: { cautious: 1 } },
          { label: "Reject and focus on training.", effects: { force: 2, tech: -1 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Onia proposes a decisive strike.", choices: [
          { label: "Approve and lead from the front.", effects: { force: 3, morale: 2, economy: -1 }, traits: { bold: 1 } },
          { label: "Negotiate a ceasefire instead.", effects: { diplomacy: 4, morale: 1, force: -2 }, traits: { diplomatic: 1 } },
          { label: "Delay until supplies are stable.", effects: { force: 1, economy: 1, morale: -1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Supply lines are threatened by southern scouts.", choices: [
          { label: "Fortify routes with patrols.", effects: { force: 2, economy: -1, morale: -1 }, traits: { strategic: 1 } },
          { label: "Move supplies at night with stealth.", effects: { supplies: 2, morale: -1 }, traits: { cautious: 1 } },
          { label: "Deploy decoy convoys to mislead.", effects: { tech: 2, diplomacy: -1, economy: -1 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "A southern envoy offers compromise: shared crystal control.", choices: [
          { label: "Accept shared control to avoid war.", effects: { diplomacy: 5, force: -1 }, traits: { compassionate: 1 } },
          { label: "Reject and push for full control.", effects: { force: 2, diplomacy: -3 }, traits: { bold: 1 } },
          { label: "Request a staged trial period.", effects: { diplomacy: 3, economy: -1, morale: -1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Tech researchers need rare minerals for upgrades.", choices: [
          { label: "Open the royal reserves.", effects: { tech: 3, economy: -2 }, traits: { innovative: 1 } },
          { label: "Trade with Pesimura.", effects: { diplomacy: 2, economy: -1 }, traits: { diplomatic: 1 } },
          { label: "Delay upgrades until after conflict.", effects: { tech: -1, economy: 1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Morale drops after a skirmish.", choices: [
          { label: "Hold a victory ceremony for the fallen.", effects: { morale: 3, diplomacy: 1, economy: -1 }, traits: { compassionate: 1 } },
          { label: "Offer bonus pay to soldiers.", effects: { economy: -2, morale: 3 }, traits: { strategic: 1 } },
          { label: "Push for a decisive battle to end it.", effects: { force: 2, morale: 1, health: -2 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Your engineers propose a crystal containment device.", choices: [
          { label: "Fund full prototype development.", effects: { tech: 4, economy: -3 }, traits: { innovative: 1 } },
          { label: "Partner with Whereland for safer rollout.", effects: { tech: 2, diplomacy: 2, economy: -1 }, traits: { diplomatic: 1 } },
          { label: "Reject and focus on classic tactics.", effects: { force: 2, tech: -1 }, traits: { cautious: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "The southern council invites you to a last negotiation.", choices: [
          { label: "Attend with an open hand and gifts.", effects: { diplomacy: 5, economy: -2 }, traits: { compassionate: 1 } },
          { label: "Attend with a display of force.", effects: { force: 2, diplomacy: -2 }, traits: { bold: 1 } },
          { label: "Send a trusted envoy to negotiate.", effects: { diplomacy: 3, force: -1, morale: -1 }, traits: { strategic: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Your advisors argue about final action.", choices: [
          { label: "Choose a diplomatic resolution.", effects: { diplomacy: 4, morale: 1, force: -2 }, traits: { diplomatic: 1 } },
          { label: "Choose a precision strike on supply depots.", effects: { force: 3, tech: 1, diplomacy: -2 }, traits: { strategic: 1 } },
          { label: "Choose a full assault to end the conflict.", effects: { force: 4, health: -3 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "The army requests relief rotations.", choices: [
          { label: "Grant rotations and medical rest.", effects: { morale: 2, force: -1, economy: -1 }, traits: { compassionate: 1 } },
          { label: "Grant only to elite units.", effects: { force: 1, morale: -1 }, traits: { strategic: 1 } },
          { label: "Deny to keep pressure.", effects: { force: 2, morale: -3 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "Economic advisors warn of inflation.", choices: [
          { label: "Stabilize currency with reserves.", effects: { economy: 3, morale: -1 }, traits: { cautious: 1 } },
          { label: "Encourage local production.", effects: { economy: 2, tech: 1, morale: -1 }, traits: { innovative: 1 } },
          { label: "Ignore and focus on victory.", effects: { force: 2, economy: -2 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "A final clash seems unavoidable.", choices: [
          { label: "Offer a shared crystal treaty one last time.", effects: { diplomacy: 4, force: -1 }, traits: { diplomatic: 1 } },
          { label: "Deploy elite units with tech advantage.", effects: { force: 3, tech: 2, health: -2 }, traits: { strategic: 1 } },
          { label: "Lead a bold charge to end it quickly.", effects: { force: 4, health: -4, morale: 2 }, traits: { bold: 1 } }
        ]},
        { chapter: "Phase II — The Crystal Conflict", text: "You stand before the crystal vault. How do you proceed?", choices: [
          { label: "Negotiate the final handoff with respect.", effects: { diplomacy: 4, morale: 1, force: -2 }, traits: { compassionate: 1 } },
          { label: "Activate containment tech to secure it safely.", effects: { tech: 4, supplies: -2 }, traits: { innovative: 1 } },
          { label: "Seize it with overwhelming force.", effects: { force: 4, diplomacy: -3, health: -2 }, traits: { bold: 1 } }
        ]}
      ];

      const DEFAULT_TIME = 2;
      let cachedName = "";
      let index = 0;
      let lastCanvas = null;
      let guideFollowed = true;
      const state = {
        supplies: 80,
        health: 100,
        morale: 60,
        diplomacy: 40,
        force: 45,
        tech: 35,
        economy: 50,
        coins: 90,
        timeDays: 0,
        people: 120,
        casualties: 15,
        startedMarch: false,
        phase: 0,
        lockResources: false
      };
      const traitScore = {
        bold: 0,
        cautious: 0,
        diplomatic: 0,
        strategic: 0,
        compassionate: 0,
        innovative: 0
      };

      function clamp(val, min, max) {
        return Math.max(min, Math.min(max, val));
      }

      function applyEffects(effects) {
        Object.entries(effects).forEach(([key, val]) => {
          if (key === "coins") {
            if (state.lockResources) return;
            state.coins += val;
            return;
          }
          if (key === "time") {
            state.timeDays = Math.max(0, state.timeDays + val);
            return;
          }
          if (key === "people") {
            if (state.lockResources) return;
            state.people = Math.max(20, state.people + val);
            return;
          }
          if (key === "health" && !state.startedMarch) return;
          if (state.lockResources && (key === "supplies" || key === "health")) return;
          if (key === "supplies" && !state.lockResources && val > 0) {
            state[key] = clamp(state[key] + val + 5, 0, 100);
            return;
          }
          if (key in state) state[key] = clamp(state[key] + val, 0, 100);
        });
        state.morale = clamp(state.morale + 1, 0, 100);
        if (state.startedMarch) {
          const dailyFood = Math.max(1, Math.round(state.people / 110));
          const dayCost = Math.max(1, effects.time || DEFAULT_TIME);
          const foodUsed = dailyFood * dayCost;
          if (!state.lockResources) {
            state.supplies = clamp(state.supplies - foodUsed, 0, 100);
          }
          if (state.supplies === 0) {
            state.health = clamp(state.health - 6, 0, 100);
            state.morale = clamp(state.morale - 4, 0, 100);
          }
        }
        if (state.startedMarch && !state.lockResources) {
          const season = seasonFromTime(state.timeDays);
          if (season === "Winter") {
            state.health = clamp(state.health - 3, 0, 100);
            state.supplies = clamp(state.supplies - 2, 0, 100);
            state.morale = clamp(state.morale - 2, 0, 100);
          } else if (season === "Autumn") {
            state.health = clamp(state.health - 1, 0, 100);
            state.supplies = clamp(state.supplies - 1, 0, 100);
          } else if (season === "Summer") {
            state.health = clamp(state.health - 1, 0, 100);
          }
          const randomRisk = clamp((60 - state.health) / 120 + (20 - state.supplies) / 120 + (season === "Winter" ? 0.06 : 0), 0, 0.18);
          if (Math.random() < randomRisk) {
            const loss = Math.max(1, Math.round(state.people / 45));
            state.people = Math.max(20, state.people - loss);
            state.morale = clamp(state.morale - 2, 0, 100);
            state.casualties = clamp(state.casualties + 2, 0, 100);
            state.lastEvent = `A sudden accident in the ${season.toLowerCase()} claimed ${loss} lives.`;
          } else {
            state.lastEvent = "";
          }
        } else {
          state.lastEvent = "";
        }
        const risk = Math.max(0, 3 - (state.tech + state.diplomacy) / 60);
        state.casualties = clamp(state.casualties + Math.round(risk), 0, 100);
      }

      function applyTraits(traits) {
        Object.entries(traits).forEach(([key, val]) => {
          if (traitScore[key] !== undefined) traitScore[key] += val;
        });
      }

      function seasonFromTime() {
        return "Spring";
      }

      function citizenMood() {
        if (state.phase === 2 && state.lockResources) {
          const timeStrain = Math.min(25, Math.round(state.timeDays / 10));
          const pressure = (100 - state.morale) + (60 - state.economy) + timeStrain;
          if (pressure > 95) return "Citizens are worried again as war rumors spread.";
          if (pressure > 70) return "Citizens are uneasy but hoping the league prevails.";
          return "Citizens are calm after Phase I, watching carefully.";
        }
        if (state.phase >= 2) return "Citizens are calm after Phase I, watching carefully.";
        const minPhaseDays = Math.min(30, SCENES.filter(s => s.chapter.startsWith("Phase I")).length);
        if (state.timeDays <= minPhaseDays) return "Citizens are calm; the journey is moving as fast as hoped.";
        const timeStrain = Math.min(25, Math.round(state.timeDays / 8));
        const pressure = (100 - state.morale) + (60 - state.economy) + timeStrain;
        if (pressure > 100) return "Citizens are fearful and exhausted by the long wait.";
        if (pressure > 78) return "Citizens are worried as the days drag on.";
        if (pressure > 58) return "Citizens are uneasy but still holding faith.";
        return "Citizens are steady and hopeful.";
      }

      function renderMeters() {
        const statsHtml = STATS.map((s) => {
          const value = state[s.id];
          return `
            <div class="quest-meter-row">
              <div>
                <b>${s.label}</b>
                <div class="quest-bar"><span style="width:${value}%;"></span></div>
              </div>
              <span class="mini-note">${value}%</span>
            </div>
          `;
        }).join("");
        const coinBar = Math.max(0, Math.min(100, Math.round((state.coins / 200) * 100)));
        const timeBar = Math.max(0, Math.min(100, Math.round((state.timeDays / 120) * 100)));
        metersWrap.innerHTML = `
          ${statsHtml}
          <div class="quest-meter-row">
            <div>
              <b>People</b>
              <div class="quest-bar"><span style="width:${Math.min(100, Math.round((state.people / 300) * 100))}%;"></span></div>
            </div>
            <span class="mini-note">${state.people}</span>
          </div>
          <div class="quest-meter-row">
            <div>
              <b>Coins</b>
              <div class="quest-bar"><span style="width:${coinBar}%;"></span></div>
            </div>
            <span class="mini-note">${state.coins}</span>
          </div>
          <div class="quest-meter-row">
            <div>
              <b>Time</b>
              <div class="quest-bar"><span style="width:${timeBar}%;"></span></div>
            </div>
            <span class="mini-note">Day ${state.timeDays}</span>
          </div>
          <div class="rule-note" style="margin-top:8px;">
            <p style="margin:0;"><b>Citizens:</b> ${citizenMood()}</p>
          </div>
        `;
      }

      const GUIDE_PATH = [
        "Present a full budget and accept strict audits.",
        "Sky-rail convoy with Whereland engines.",
        "Balanced expedition force.",
        "Whereland thermal tech suits.",
        "Heavy rations for long safety.",
        "Purchase the full kit.",
        "Hold a public sendoff to raise morale.",
        "Camp and ration carefully.",
        "Scare them off with fireworks.",
        "Buy fresh supplies for the camp.",
        "Build a temporary bridge and move safely.",
        "Quarantine and slow down.",
        "Redistribute supplies evenly.",
        "Construct a ferry system.",
        "Train a mixed squad with new tactics.",
        "Set up a base camp until safe.",
        "Send a rescue party to the nearest town.",
        "Set loud deterrents and perimeter lights.",
        "Trade for sun-dried provisions.",
        "Trade with nomads for replacement.",
        "Negotiate for a fairer price.",
        "Approve the survey immediately.",
        "Buy compact rations for quick travel.",
        "Buy heated rations and blankets.",
        "Offer a treaty of shared energy research.",
        "Offer a joint research pact to Whereland.",
        "Train elite units with new tactics.",
        "Test in controlled drills first.",
        "Rally donations with public ceremonies.",
        "Offer limited exchange with strict terms.",
        "Invest heavily in it.",
        "Negotiate a ceasefire instead.",
        "Fortify routes with patrols.",
        "Accept shared control to avoid war.",
        "Open the royal reserves.",
        "Hold a victory ceremony for the fallen.",
        "Partner with Whereland for safer rollout.",
        "Attend with an open hand and gifts.",
        "Choose a diplomatic resolution.",
        "Grant rotations and medical rest.",
        "Encourage local production.",
        "Offer a shared crystal treaty one last time.",
        "Negotiate the final handoff with respect."
      ];

      function renderGuide() {
        if (!guideWrap) return;
        const rows = SCENES.map((scene, idx) => {
          const guideLabel = GUIDE_PATH[idx] || scene.choices[0]?.label;
          const best = scene.choices.find((c) => c.label === guideLabel) || scene.choices[0];
          return `
            <div class="rule-note" style="margin:8px 0;">
              <p style="margin:0;"><b>Chapter ${idx + 1}:</b> ${scene.text}</p>
              <p style="margin:6px 0 0 0;"><b>Recommended:</b> ${best.label}</p>
            </div>
          `;
        }).join("");
        guideWrap.innerHTML = rows;
      }

      function inferTime(label) {
        const text = (label || "").toLowerCase();
        if (text.includes("ship") || text.includes("sea") || text.includes("ice-cap")) return 7;
        if (text.includes("reroute") || text.includes("detour") || text.includes("tunnel")) return 6;
        if (text.includes("build") || text.includes("construct") || text.includes("bridge") || text.includes("ferry")) return 5;
        if (text.includes("train") || text.includes("drills")) return 5;
        if (text.includes("wait") || text.includes("delay") || text.includes("camp")) return 4;
        if (text.includes("negotiate") || text.includes("summit") || text.includes("treaty")) return 3;
        if (text.includes("push") || text.includes("fast") || text.includes("quick") || text.includes("rush")) return 1;
        return DEFAULT_TIME;
      }

      function resolveEffects(choice) {
        const eff = { ...(choice.effects || {}) };
        if (!("time" in eff)) eff.time = inferTime(choice.label || "");
        if (eff.time < 0) eff.time = Math.abs(eff.time);
        return eff;
      }

      function effectsText(effects) {
        const parts = [];
        const order = ["time", "coins", "supplies", "health", "morale", "diplomacy", "force", "tech", "economy", "people"];
        order.forEach((key) => {
          const val = effects[key];
          if (!val) return;
          const sign = val > 0 ? "+" : "";
          if (key === "time") parts.push(`${sign}${val} days`);
          else if (key === "coins") parts.push(`${sign}${val} coins`);
          else parts.push(`${sign}${val} ${key}`);
        });
        return parts.join(", ");
      }

      const OUTCOME_BY_LABEL = {
        "Present a full budget and accept strict audits.": "You deliver a detailed budget and invite Onia’s auditors into the room. Their approval is swift, but the oversight feels heavy. The league senses your discipline and watches your next move closely.",
        "Offer shared risk and partial repayment.": "You outline a shared-risk plan that spreads responsibility across the league. Onia agrees to fund you, but only with clear repayment terms. The council leaves cautious yet cooperative.",
        "Reject strings and seek a small, independent grant.": "You refuse conditions and request only a clean, smaller grant. Onia relents, but several allies question the choice. Your inner circle feels relieved to keep full control.",
        "Armored caravan cars with spare parts.": "You order armored caravan cars and stock them with spare parts. The convoy feels secure and disciplined. The weight and maintenance slow your flexibility on the road.",
        "Ice-cap ship through dangerous waters.": "You send the expedition by ice-cap ship along the southern waters. The voyage protects cargo but stretches the timeline. Sailors and soldiers brace against harsh winds and long nights.",
        "Sky-rail convoy with Whereland engines.": "You commit to Whereland’s sky-rail engines to leap over hazards. The convoy glides above danger and morale spikes briefly. The price is steep and the tech must not fail.",
        "Small elite team for speed.": "You select a lean elite team built for speed and precision. The march becomes sharper and quieter. Families at home worry about the risk of such a small force.",
        "Balanced expedition force.": "You assemble a balanced expedition with soldiers, medics, and engineers. The group can handle most threats without excess burden. The pace is steady, and expectations grow.",
        "Large public expedition to inspire citizens.": "You invite a large public expedition to unify the nation. Cheers follow the caravan and morale rises. Feeding and protecting the larger group becomes a daily strain.",
        "Standard winter gear.": "You buy standard winter gear for the full caravan. The team stays warm and the order feels fair. The supplies are reliable but unremarkable.",
        "Whereland thermal tech suits.": "You purchase Whereland thermal suits for the expedition. The tech keeps the cold at bay and boosts confidence. The cost draws critical eyes from Onia’s accountants.",
        "Minimal gear to save coins.": "You cut the clothing budget to preserve coins. The caravan moves lighter, but the cold bites harder. Complaints rise quietly around the fires.",
        "Heavy rations for long safety.": "You load heavy rations to secure the journey. The caravan feels protected against long delays. The extra weight drags on speed and flexibility.",
        "Balanced rations with periodic resupply.": "You choose balanced rations and plan for resupply points. The caravan keeps a steady pace without overloading. The risk now depends on reliable markets.",
        "Light rations for speed.": "You carry light rations to push speed. The convoy accelerates and feels nimble. Hunger shadows the march whenever delays appear.",
        "Purchase the full kit.": "You buy Whereland’s full survival analytics kit. Sensors begin mapping hazards and improving decisions. The purchase is powerful but costly.",
        "Buy a lighter version.": "You buy a lighter analytics kit and prioritize key routes. The data is helpful but incomplete. The team accepts the tradeoff as practical.",
        "Decline to keep budget flexible.": "You decline the kit to keep money flexible. Scouts take on more responsibility without technological support. Engineers whisper about avoidable risks.",
        "Hold a public sendoff to raise morale.": "You stage a public sendoff and lift spirits with speeches. The nation sends you forward with pride. The ceremony takes time and coin.",
        "Leave quietly to save time.": "You depart quietly before dawn to save time. The convoy keeps a sharp pace and avoids attention. Some citizens feel uneasy about the silence.",
        "Launch with a show of force to deter attacks.": "You leave with a show of force and banners raised. Predators and raiders keep their distance. The display reinforces strength but costs resources.",
        "Push through to keep schedule.": "You force the convoy through harsh conditions to keep the schedule. The decision buys speed, but it drains health. The camp grows tense as the cold bites.",
        "Camp and ration carefully.": "You order a careful camp and strict rations. The caravan rests and stabilizes, even if spirits dip. The delay feels safer but costly in time.",
        "Use heat sigils and experimental tech.": "You deploy experimental heat sigils against the cold. The tech works, but the camp watches for failures. Confidence rises, yet supplies thin out.",
        "Scare them off with fireworks.": "You launch fireworks to scatter the beasts. The camp cheers and a panic turns to relief. Supplies take a small hit for the spectacle.",
        "Offer food to avoid conflict.": "You offer rations to avoid a fight. The beasts drift away and injuries are avoided. The loss of food weighs on everyone afterward.",
        "Set a silent detour through ravines.": "You choose a silent detour through ravines. The convoy avoids conflict but the route is punishing. The terrain slows the march and strains morale.",
        "Buy enough for weeks of travel.": "You purchase weeks of rations at the outpost. The caravan breathes easier and plans become steadier. The price is high and the treasury tightens.",
        "Negotiate for a fairer price.": "You negotiate patiently for better prices. The merchant yields, though time is lost in bargaining. The camp respects the careful stewardship.",
        "Decline and press on with existing stock.": "You decline the offer and keep moving. The convoy saves coin but leans on limited stock. Some worry the road ahead will punish the choice.",
        "Buy compact rations for quick travel.": "You buy compact rations meant for speed. The caravan moves lighter and faster. The food is less satisfying and morale dips.",
        "Buy only a small emergency stash.": "You buy a small emergency stash and keep most coin. The expedition feels prepared but not secure. Officers debate whether you cut too close.",
        "Skip the market to save coins.": "You skip the market to save coin. The convoy keeps its pace but loses a chance to strengthen supplies. The decision feels risky to many.",
        "Cross fast and light, leaving heavy carts.": "You cross fast and abandon heavy carts to the lake. The move saves lives but sacrifices supplies. The convoy remembers the loss as it marches on.",
        "Build a temporary bridge and move safely.": "You order a temporary bridge to cross safely. The work slows the march but keeps supplies intact. The crew respects the steady leadership.",
        "Wait for the beasts to move on.": "You wait for the beasts to pass before crossing. The camp grows impatient but avoids direct danger. Time slips away as the ice creaks.",
        "Quarantine and slow down.": "You quarantine the sick and slow the pace. Health improves but the caravan feels constrained. Some fear the delay will invite harsher seasons.",
        "Continue marching and trust resilience.": "You push forward and trust the group’s resilience. The march stays quick, but illness spreads. Confidence fades as more falter.",
        "Use experimental remedies from the archives.": "You deploy experimental remedies from the archives. Some recover quickly, others suffer side effects. The camp debates the risk you took.",
        "Redistribute supplies evenly.": "You redistribute gear across the convoy. Morale rises as fairness spreads. The best-equipped units lose their edge.",
        "Keep elite units prioritized.": "You keep elite units prioritized for survival. The frontline stays strong, but resentment grows. The convoy feels divided afterward.",
        "Purchase gear from traveling artisans.": "You buy gear from traveling artisans. The equipment lifts morale and adds comfort. The expense draws attention from the treasury.",
        "Risk the crossing to save time.": "You risk a direct river crossing to save time. The convoy makes it, but losses sting. The team remembers the gamble.",
        "Construct a ferry system.": "You build a ferry system and move in stages. The crossing is controlled, though slower than hoped. The engineers gain confidence in their work.",
        "Reroute through the forest.": "You reroute through the forest and avoid the flood. The detour brings new hazards and delays. The caravan emerges tired but intact.",
        "Accept and pay them well.": "You hire the hunters and pay them well. Their knowledge improves security and local ties. The cost is heavy but the path feels safer.",
        "Use only royal troops.": "You rely solely on royal troops. The chain of command is clear, but local knowledge is lost. The guards feel proud yet stretched thin.",
        "Train a mixed squad with new tactics.": "You form a mixed squad and test new tactics. Coordination improves and morale shifts. The experiments cost time and patience.",
        "Dig through to avoid delay.": "You order the convoy to dig through the debris. The effort saves time but exhausts the team. Injuries and fatigue rise.",
        "Set up a base camp until safe.": "You set a base camp and wait for safety. The pause restores strength but drains urgency. The caravan grows restless as days pass.",
        "Search for an alternate tunnel route.": "You search for a tunnel route through the mountains. The discovery keeps supplies moving but costs time. Scouts return battered but successful.",
        "Salvage parts to reinforce other carts.": "You salvage the broken cart for parts. The convoy becomes more durable, but capacity shrinks. The loss is accepted as necessary.",
        "Send a rescue party to the nearest town.": "You send a rescue party to the nearest town. Help arrives, but the delay extends the march. The town watches your strength closely.",
        "Leave the unit behind to keep moving.": "You abandon the transport unit to keep moving. The convoy saves time but loses supplies. The decision divides the team.",
        "Set loud deterrents and perimeter lights.": "You set loud deterrents and ring the camp with light. Predators keep distance, but the noise frays nerves. Supplies are burned to fuel the defense.",
        "Quietly relocate to higher ground.": "You move the camp quietly to higher ground. The shift reduces attacks but tires the caravan. The move is effective, not inspiring.",
        "Lead a counter-hunt.": "You lead a counter-hunt to remove the threat. The predators scatter, and morale lifts briefly. The risk leaves scars among the hunters.",
        "Ration tightly and continue.": "You tighten rations to stretch supplies. The march continues, but hunger wears on morale. The convoy grows quiet and focused.",
        "Organize a foraging sweep.": "You organize a foraging sweep in the wilds. Extra food is found, but injuries occur. The decision feels bold yet costly.",
        "Trade with nomads for replacement.": "You trade with nomads for replacement stores. Diplomacy improves and supplies recover. The trade costs coin and leverage.",
        "Approve the survey immediately.": "You approve the energy-vent survey immediately. The team gains valuable heat maps and new confidence. The detour costs time and supplies.",
        "Delay until the camp stabilizes.": "You delay the survey to stabilize the camp. The decision reduces risk but misses immediate opportunities. The scientists are disappointed yet comply.",
        "Assign a small team to test the idea.": "You send a small team to test the vents. They return with partial data and stories of strange heat. The results are useful but limited.",
        "Offer a treaty of shared energy research.": "You offer a treaty for shared research. The council listens, and tension cools. The league gains a moral foothold but no immediate crystal.",
        "Demand the crystal on behalf of the league.": "You demand the crystal as league property. The south stiffens and refuses. The stance strengthens unity but risks open conflict.",
        "Withdraw to regroup and plan with allies.": "You withdraw and regroup with your allies. The retreat preserves resources and opens planning time. Some perceive the move as weakness.",
        "Promise logistics routes to Pesimura in exchange for troop training.": "You promise Pesimura new routes in return for training support. Their generals agree, and drill schedules begin. The deal helps the army but burdens your supply planning.",
        "Offer a joint research pact to Whereland.": "You offer Whereland a joint research pact. Their engineers commit resources and share prototypes. The pact deepens trust but adds costs.",
        "Ask Onia for emergency markets and strict discipline.": "You ask Onia to stabilize markets and enforce discipline. Supplies start flowing again and order tightens. Citizens fear austerity measures.",
        "Focus on rapid drills and morale chants.": "You push rapid drills with morale chants. The ranks grow loud and energetic. The haste leaves gaps in technique.",
        "Train elite units with new tactics.": "You train elite units in new tactics. Their effectiveness rises and confidence grows. The rest of the army feels sidelined.",
        "Keep training safe and inclusive.": "You keep training safe and inclusive. Injury rates drop and morale lifts. The training is slower and less aggressive.",
        "Deploy immediately despite risks.": "You deploy prototype shields immediately. The tech intimidates rivals but malfunctions appear. Some units lose trust in the devices.",
        "Test in controlled drills first.": "You test the shields in controlled drills. Failures are caught early and confidence grows. The delay frustrates frontline commanders.",
        "Integrate only with elite squads.": "You integrate the shields only with elite squads. The elite grow stronger, but inequality spreads. The rest of the force demands parity.",
        "Increase taxes temporarily.": "You raise taxes to fund the war. The treasury stabilizes, but citizens complain. Public trust dips as costs rise.",
        "Rally donations with public ceremonies.": "You rally donations through public ceremonies. Coins flow in and civic pride rises. The events consume precious time and resources.",
        "Reduce non-military spending.": "You reduce non-military spending. The war effort gains support, but civilian services weaken. Discontent grows among the towns.",
        "Agree and host a grand summit.": "You host a grand summit for Pesimura’s cultural exchange. Relations warm and coordination improves. The cost and time are significant.",
        "Decline to keep focus on the war.": "You decline the exchange to keep focus on war. The army stays sharp, but Pesimura feels slighted. Cooperation becomes more conditional.",
        "Offer limited exchange with strict terms.": "You offer a limited exchange under strict terms. The gesture keeps relations intact without full commitment. The compromise satisfies no one fully.",
        "Invest heavily in it.": "You invest heavily in the new technology. The labs accelerate, and casualties may drop. The economy strains under the expense.",
        "Use it only for defense.": "You restrict the technology to defensive use. Troops feel safer, but offensive potential is lost. Commanders debate the restraint.",
        "Reject and focus on training.": "You reject the technology and focus on training. The army hardens through discipline. Scientists feel ignored and innovation slows.",
        "Approve and lead from the front.": "You approve the strike and lead from the front. The army surges with you, but the risk is severe. Your presence inspires and endangers at once.",
        "Negotiate a ceasefire instead.": "You propose a ceasefire and open direct talks. The battlefield quiets and diplomacy rises. Some commanders fear you are losing momentum.",
        "Delay until supplies are stable.": "You delay the strike until supplies stabilize. The army regains footing and confidence. The south strengthens defenses during the pause.",
        "Fortify routes with patrols.": "You fortify supply routes with patrols and checkpoints. Lines become safer, though manpower spreads thin. The effort slows offensive operations.",
        "Move supplies at night with stealth.": "You move supplies at night and avoid open paths. Losses drop, but crews grow exhausted. The secrecy feeds rumors in camp.",
        "Deploy decoy convoys to mislead.": "You deploy decoy convoys to mislead scouts. The trick works and real supplies pass safely. The decoys pay a heavy price.",
        "Accept shared control to avoid war.": "You accept shared control of the crystal. Tension drops and lives are spared. The league gains security but not full power.",
        "Reject and push for full control.": "You reject shared control and push for full access. The stance hardens resolve but inflames the south. Conflict escalates quickly.",
        "Request a staged trial period.": "You request a staged trial period for shared control. The south agrees cautiously, and trust grows slowly. The league gains time to prepare.",
        "Open the royal reserves.": "You open the royal reserves for tech upgrades. The labs surge forward, but the treasury thins. Critics warn of long-term costs.",
        "Trade with Pesimura.": "You trade with Pesimura for rare minerals. The alliance strengthens and supplies arrive. The price is higher than expected.",
        "Delay upgrades until after conflict.": "You delay upgrades until after the conflict. The budget steadies, but tech lags behind. Engineers complain about missed windows.",
        "Hold a victory ceremony for the fallen.": "You hold a victory ceremony for the fallen. Morale lifts and the nation grieves together. The ceremony consumes time and coin.",
        "Offer bonus pay to soldiers.": "You offer bonus pay to raise morale. Soldiers respond with renewed loyalty. The treasury tightens under the cost.",
        "Push for a decisive battle to end it.": "You push for a decisive battle. The army braces and moves with purpose. The risk of heavy losses rises.",
        "Fund full prototype development.": "You fund full prototype development of the containment device. Innovation accelerates and hope rises. The project consumes the budget quickly.",
        "Partner with Whereland for safer rollout.": "You partner with Whereland for a safer rollout. The device improves under shared oversight. Progress slows but reliability increases.",
        "Reject and focus on classic tactics.": "You reject the device and focus on classic tactics. The army relies on proven methods. Scientists feel sidelined and momentum fades.",
        "Attend with an open hand and gifts.": "You attend the negotiation with gifts and humility. The south listens more openly and tempers cool. Allies see your compassion as strength.",
        "Attend with a display of force.": "You arrive with a strong display of force. The south is cautious and talks remain tense. The show of power risks escalation.",
        "Send a trusted envoy to negotiate.": "You send a trusted envoy in your place. The envoy negotiates carefully and preserves your safety. Some leaders feel your absence.",
        "Choose a diplomatic resolution.": "You choose diplomacy as the final path. The council calms and channels open. The army feels restrained but preserves lives.",
        "Choose a precision strike on supply depots.": "You authorize precision strikes on supply depots. The enemy’s logistics falter and momentum shifts. The risk of retaliation grows.",
        "Choose a full assault to end the conflict.": "You choose a full assault to end the conflict. The battlefield roars with decisive force. Victory is possible, but losses are likely.",
        "Grant rotations and medical rest.": "You grant rotations and medical rest. The army recovers and morale lifts. The slower pace gives the south time to prepare.",
        "Grant only to elite units.": "You grant rotations only to elite units. The elite stay sharp, but others feel neglected. Resentment simmers in the ranks.",
        "Deny to keep pressure.": "You deny rotations to keep pressure high. The army remains aggressive, but exhaustion spreads. Morale drops in silence.",
        "Stabilize currency with reserves.": "You stabilize the currency with reserves. Markets calm and prices level. The reserves thin, leaving little cushion later.",
        "Encourage local production.": "You encourage local production and innovation. The economy adapts and citizens feel involved. Results take time to mature.",
        "Ignore and focus on victory.": "You ignore inflation warnings to focus on victory. The war effort stays strong, but prices spike at home. Citizens grow uneasy.",
        "Offer a shared crystal treaty one last time.": "You offer a last shared treaty to avoid bloodshed. The south considers the offer seriously. Your army waits in tense restraint.",
        "Deploy elite units with tech advantage.": "You deploy elite units with a tech advantage. The assault gains precision and speed. Failure would be costly and public.",
        "Lead a bold charge to end it quickly.": "You lead a bold charge to end the conflict quickly. The act inspires courage across the line. The risk to you and the army is extreme.",
        "Negotiate the final handoff with respect.": "You negotiate the final handoff with calm respect. The south responds with cautious cooperation. The crystal changes hands without immediate bloodshed.",
        "Activate containment tech to secure it safely.": "You activate the containment device to secure the crystal. The chamber stabilizes and the tech team cheers. The device drains resources and demands careful monitoring.",
        "Seize it with overwhelming force.": "You seize the crystal by force. The vault falls, but the cost is heavy. The victory is decisive and deeply scarred."
      };

      function outcomeText(choice) {
        const story = choice.outcome || OUTCOME_BY_LABEL[choice.label] || `You choose ${choice.label.toLowerCase()}. The caravan adjusts to your decision. The road ahead shifts in response.`;
        const deathNote = state.lastEvent ? `${state.lastEvent} ` : "";
        return `${story} ${deathNote}${citizenMood()}`;
      }

      function renderScene() {
        if (state.phase < 2 && state.startedMarch && (state.supplies <= 0 || state.health <= 0)) {
          renderEnding({
            title: "Expedition Collapse (Death)",
            summary: "Your expedition collapses under losses. With supplies, health, or treasury depleted, the quest ends in tragedy."
          });
          return;
        }
        const scene = SCENES[index];
        if (!scene) {
          renderEnding();
          return;
        }
        if (scene.chapter.startsWith("Phase II")) {
          scene.choices.forEach((c) => {
            if (c.effects) {
              delete c.effects.supplies;
              delete c.effects.health;
              delete c.effects.people;
              delete c.effects.coins;
            }
          });
        }
        if (!state.startedMarch && (scene.chapter.startsWith("Phase I") || scene.chapter.startsWith("Phase II"))) {
          state.startedMarch = true;
          state.health = 100;
        }
        if (scene.chapter.startsWith("Phase I")) state.phase = 1;
        if (scene.chapter.startsWith("Phase II")) {
          if (state.phase !== 2) {
            state.phase = 2;
            state.lockResources = true;
            state.supplies = 0;
            state.health = 0;
            state.people = 0;
            state.coins = 0;
          }
        }
        chapterOut.textContent = `Chapter ${index + 1} of ${SCENES.length} — ${scene.chapter} (Day ${state.timeDays})`;
        sceneOut.textContent = scene.text;
        choicesWrap.innerHTML = scene.choices.map((c, i) => {
          const eff = resolveEffects(c);
          const effText = effectsText(eff);
          return `
          <button class="quest-choice" data-choice="${i}" type="button">
            <div>${c.label}</div>
            <span>${effText || `Choice ${i + 1}`}</span>
          </button>
        `;
        }).join("");
        if (outcomeBox) outcomeBox.style.display = "none";
        if (continueBtn) continueBtn.style.display = "none";
        renderMeters();
      }

      function pickTraitsTop() {
        return Object.entries(traitScore)
          .map(([k, v]) => ({ key: k, value: v }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 3)
          .map((t) => TRAITS.find((x) => x.id === t.key)?.label || t.key);
      }

      function determineEnding() {
        if (guideFollowed) {
          return {
            title: "Crystal Accord (Best Outcome)",
            summary: "By following the perfect path, you secure the crystal with minimal loss and forge a lasting alliance across the Spertz League."
          };
        }
        const best =
          state.diplomacy >= 75 &&
          state.tech >= 70 &&
          state.force >= 60 &&
          state.health >= 60 &&
          state.supplies >= 50 &&
          state.casualties <= 25;
        if (best) {
          return {
            title: "Crystal Accord (Best Outcome)",
            summary: "You secure the crystal through a strong alliance and minimal losses. Kopahor enters a new golden era."
          };
        }
        if (state.health <= 30 || state.morale <= 25 || state.supplies <= 20) {
          return {
            title: "Broken March",
            summary: "The campaign collapses under pressure. The crystal remains out of reach and the nation must recover."
          };
        }
        if (state.diplomacy >= 65) {
          return {
            title: "Shared Crystal Treaty",
            summary: "You broker a peaceful agreement and share the crystal. Progress is steady, though not absolute."
          };
        }
        if (state.force >= 70 && state.tech >= 60) {
          return {
            title: "Decisive Victory",
            summary: "You win through force and innovation, but the cost is significant and recovery will be long."
          };
        }
        return {
          title: "Stalemate Horizon",
          summary: "You secure limited access to the crystal, but the region remains tense and unstable."
        };
      }

      function getThemeVar(name, fallback) {
        const val = getComputedStyle(document.body).getPropertyValue(name).trim();
        return val || fallback;
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const words = text.split(" ");
        let line = "";
        let yy = y;
        for (let i = 0; i < words.length; i++) {
          const testLine = line + words[i] + " ";
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && i > 0) {
            ctx.fillText(line, x, yy);
            line = words[i] + " ";
            yy += lineHeight;
          } else {
            line = testLine;
          }
        }
        ctx.fillText(line, x, yy);
        return yy + lineHeight;
      }

      function concatBytes(chunks) {
        let total = 0;
        chunks.forEach((c) => { total += c.length; });
        const out = new Uint8Array(total);
        let offset = 0;
        chunks.forEach((c) => {
          out.set(c, offset);
          offset += c.length;
        });
        return out;
      }

      function buildPdfFromJpeg(jpegBytes, width, height) {
        const enc = new TextEncoder();
        const chunks = [];
        let offset = 0;
        const xref = [];

        function pushStr(s) {
          const b = enc.encode(s);
          chunks.push(b);
          offset += b.length;
        }
        function pushBytes(b) {
          chunks.push(b);
          offset += b.length;
        }

        pushStr("%PDF-1.3\n");
        xref.push(offset); pushStr("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
        xref.push(offset); pushStr("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n");
        xref.push(offset); pushStr(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${width} ${height}] /Resources << /XObject << /Im0 4 0 R >> >> /Contents 5 0 R >>\nendobj\n`);
        xref.push(offset); pushStr(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${width} /Height ${height} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${jpegBytes.length} >>\nstream\n`);
        pushBytes(jpegBytes);
        pushStr("\nendstream\nendobj\n");
        const content = `q\n${width} 0 0 ${height} 0 0 cm\n/Im0 Do\nQ\n`;
        const contentBytes = enc.encode(content);
        xref.push(offset); pushStr(`5 0 obj\n<< /Length ${contentBytes.length} >>\nstream\n`);
        pushBytes(contentBytes);
        pushStr("\nendstream\nendobj\n");

        const xrefStart = offset;
        pushStr("xref\n0 6\n0000000000 65535 f \n");
        xref.forEach((pos) => {
          const line = String(pos).padStart(10, "0") + " 00000 n \n";
          pushStr(line);
        });
        pushStr(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`);
        return concatBytes(chunks);
      }

      function buildCertificate(ending, traits) {
        const canvas = document.createElement("canvas");
        canvas.width = 900;
        canvas.height = 560;
        const ctx = canvas.getContext("2d");

        const bg = getThemeVar("--bg-2", "#15182a");
        const surface = getThemeVar("--surface", "rgba(255,255,255,0.06)");
        const text = getThemeVar("--text", "#e8e8e8");
        const heading = getThemeVar("--heading", "#ffffff");
        const accent = getThemeVar("--accent", "#c6a664");
        const accent2 = getThemeVar("--accent-2", "#9bc1ff");

        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = surface;
        ctx.fillRect(24, 24, canvas.width - 48, canvas.height - 48);

        ctx.fillStyle = heading;
        ctx.font = "700 26px serif";
        ctx.fillText("Kopahor Leadership Certificate", 48, 70);

        ctx.fillStyle = accent2;
        ctx.font = "700 32px serif";
        ctx.fillText(ending.title, 48, 118);

        ctx.fillStyle = text;
        ctx.font = "16px sans-serif";
        let yy = wrapText(ctx, ending.summary, 48, 150, 520, 22);

        if (cachedName) {
          ctx.fillStyle = accent;
          ctx.font = "600 14px sans-serif";
          ctx.fillText("Leader", 48, yy + 16);
          ctx.fillStyle = text;
          ctx.font = "16px sans-serif";
          ctx.fillText(cachedName, 48, yy + 40);
          yy += 42;
        }

        ctx.fillStyle = accent;
        ctx.font = "600 14px sans-serif";
        ctx.fillText("Leadership traits", 48, yy + 12);
        ctx.fillStyle = text;
        ctx.font = "14px sans-serif";
        ctx.fillText(traits.join(" · "), 48, yy + 36);

        const startX = 580;
        let barY = 120;
        const barW = 260;
        const barH = 12;

        ctx.fillStyle = heading;
        ctx.font = "600 13px sans-serif";
        STATS.filter((s) => s.id !== "supplies" && s.id !== "health").forEach((s) => {
          const val = state[s.id];
          ctx.fillText(`${s.label}: ${val}%`, startX, barY - 6);
          ctx.fillStyle = "rgba(0,0,0,0.25)";
          ctx.fillRect(startX, barY, barW, barH);
          ctx.fillStyle = accent;
          ctx.fillRect(startX, barY, barW * (val / 100), barH);
          barY += 30;
          ctx.fillStyle = heading;
        });

        return canvas;
      }

      function downloadPng(canvas) {
        const link = document.createElement("a");
        link.download = "kopahor-quest-certificate.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      function downloadPdf(canvas) {
        const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const pdfBytes = buildPdfFromJpeg(bytes, canvas.width, canvas.height);
        const blob = new Blob([pdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "kopahor-quest-certificate.pdf";
        link.click();
        URL.revokeObjectURL(url);
      }

      function renderEnding(forcedEnding) {
        const ending = forcedEnding || determineEnding();
        const traits = pickTraitsTop();
        resultsBox.innerHTML = `
          <div class="personality-card">
            <h3 style="margin:0;">Final Ending: ${ending.title}</h3>
            <p class="mini-note" style="margin-top:8px;">${ending.summary}</p>
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              ${traits.map((t) => `<span class="car-tag">${t}</span>`).join("")}
              <span class="car-tag">Casualties: ${state.casualties}%</span>
            </div>
          </div>
          <div class="personality-card">
            <h4 style="margin:0;">Download your certificate</h4>
            <p class="mini-note" style="margin-top:8px;">Save a PNG or PDF of your ending and leadership traits.</p>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
              <button id="questDownloadPng" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PNG</span>
                <span class="acc-icon">⬇</span>
              </button>
              <button id="questDownloadPdf" class="accordion-btn" type="button" style="max-width: 220px;">
                <span>Download PDF</span>
                <span class="acc-icon">⬇</span>
              </button>
            </div>
          </div>
        `;
        lastCanvas = buildCertificate(ending, traits);
        resultsBox.querySelector("#questDownloadPng")?.addEventListener("click", () => downloadPng(lastCanvas));
        resultsBox.querySelector("#questDownloadPdf")?.addEventListener("click", () => downloadPdf(lastCanvas));
        resultsBox.scrollIntoView({ behavior: "smooth", block: "start" });
        choicesWrap.innerHTML = "";
      }

      choicesWrap.addEventListener("click", (e) => {
        const btn = e.target.closest(".quest-choice");
        if (!btn) return;
        const scene = SCENES[index];
        const choiceIdx = parseInt(btn.dataset.choice, 10);
        const choice = scene.choices[choiceIdx];
        if (!choice) return;
        if (GUIDE_PATH[index] && choice.label !== GUIDE_PATH[index]) {
          guideFollowed = false;
        }
        const effects = resolveEffects(choice);
        applyEffects(effects);
        applyTraits(choice.traits || {});
        if (outcomeBox) {
          outcomeBox.style.display = "";
          outcomeBox.innerHTML = `<p style="margin:0;"><b>Result:</b> ${outcomeText(choice)}</p>`;
        }
        choicesWrap.querySelectorAll("button").forEach((b) => (b.disabled = true));
        if (continueBtn) continueBtn.style.display = "";
      });

      if (continueBtn) {
        continueBtn.addEventListener("click", () => {
          index += 1;
          renderScene();
        });
      }

      if (shareApplyBtn) {
        shareApplyBtn.addEventListener("click", () => {
          const code = shareInput ? shareInput.value.trim() : "";
          if (!code) {
            shareStatus.textContent = "Please paste a share code first.";
            return;
          }
          if (shareCode && shareApply) {
            shareCode.value = code;
            shareApply.click();
            cachedName = (fullNameOut && fullNameOut.textContent && fullNameOut.textContent !== "—") ? fullNameOut.textContent : "";
            shareStatus.textContent = cachedName ? "Code loaded ✅" : "Code loaded (name not found).";
          } else {
            shareStatus.textContent = "Share system not available.";
          }
        });
      }

      if (shareClearBtn) {
        shareClearBtn.addEventListener("click", () => {
          if (shareInput) shareInput.value = "";
          cachedName = "";
          shareStatus.textContent = "No code loaded.";
        });
      }

      renderGuide();
      renderScene();
    })();

    document.querySelectorAll(".accordion .accordion-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const panel = btn.nextElementSibling;
        const icon = btn.querySelector(".acc-icon");

        if (!panel) return;

        const isOpen = panel.style.maxHeight && panel.style.maxHeight !== "0px";

        document.querySelectorAll(".accordion-panel").forEach((p) => (p.style.maxHeight = "0px"));
        document.querySelectorAll(".acc-icon").forEach((i) => (i.textContent = "+"));

        if (!isOpen) {
          panel.style.maxHeight = panel.scrollHeight + "px";
          icon.textContent = "−";
        }
      });
    });

    document.querySelectorAll(".story-card .story-toggle").forEach((btn) => {
      btn.addEventListener("click", () => {
        const panel = btn.nextElementSibling;
        const icon = btn.querySelector(".acc-icon");
        if (!panel) return;

        const isOpen = panel.style.maxHeight && panel.style.maxHeight !== "0px";
        panel.style.maxHeight = isOpen ? "0px" : panel.scrollHeight + "px";
        btn.setAttribute("aria-expanded", String(!isOpen));
        if (icon) icon.textContent = isOpen ? "+" : "−";
      });
    });

    // ===== Numbers Converter =====

    const DIGITS_BASE10 = {
      0: "zu", 1: "ta", 2: "re", 3: "ki", 4: "vo",
      5: "me", 6: "dal", 7: "zai", 8: "fiu", 9: "no"
    };

    const DIGITS_BASE8 = {
      0: "zu", 1: "ta", 2: "re", 3: "ki", 4: "vo",
      5: "me", 6: "dal", 7: "zai"
    };

    const DIGITS_BASE16 = {
      0: "zu", 1: "ta", 2: "re", 3: "ki", 4: "vo",
      5: "me", 6: "dal", 7: "zai", 8: "fiu", 9: "pita",
      10: "pire", 11: "piki", 12: "pivo", 13: "pime",
      14: "pidal", 15: "pizai"
    };

    function getDigitMap(base) {
      if (base === 8) return DIGITS_BASE8;
      if (base === 16) return DIGITS_BASE16;
      return DIGITS_BASE10;
    }

    function digitWord(value, base) {
      const map = getDigitMap(base);
      return map[value];
    }

    function exponentWord(n, base) {

      const map = getDigitMap(base);
      if (map[n]) return map[n];

      let x = n;
      const digits = [];
      while (x > 0) {
        digits.push(x % base);
        x = Math.floor(x / base);
      }
      digits.reverse();
      return digits.map(d => digitWord(d, base)).join("");
    }

    function toSpertzNumber(n, base) {
      const MAX_N = Math.pow(8, 7); // 8^7 = 2097152

      if (!Number.isFinite(n)) return "—";
      if (!Number.isInteger(n)) return "Please input an integer.";
      if (n < 0) return "Please input a non-negative integer.";
      if (n > MAX_N) return "Too large. Max allowed is 8^7 = 2097152.";
      if (n === 0) return digitWord(0, base);

      const digits = [];
      let x = n;
      while (x > 0) {
        digits.push(x % base);
        x = Math.floor(x / base);
      }
      digits.reverse();

      const parts = [];
      for (let i = 0; i < digits.length; i++) {
        const d = digits[i];
        const pos = digits.length - 1 - i;

        if (d === 0) continue;

        if (pos === 0) {
          parts.push(digitWord(d, base));
        } else {
          const place = exponentWord(pos, base) + "zu";
          parts.push(digitWord(d, base) + place);
        }
      }

      return parts.join("-");
    }

    const numInput = document.getElementById("numInput");
    const numRegion = document.getElementById("numRegion");
    const numOutput = document.getElementById("numOutput");

    function updateNumberOutput() {
      const base = parseInt(numRegion.value, 10);
      const raw = numInput.value;

      if (raw === "" || raw === null) {
        numOutput.textContent = "—";
        return;
      }

      const n = Number(raw);
      numOutput.textContent = toSpertzNumber(n, base);
    }

    if (numInput && numRegion && numOutput) {
      numInput.addEventListener("input", updateNumberOutput);
      numRegion.addEventListener("change", updateNumberOutput);
      updateNumberOutput();
    }

    // ===== Spertz IPA Converter =====
    (function () {
      const ipaInput = document.getElementById("ipaInput");
      const ipaOutput = document.getElementById("ipaOutput");
      const ipaStatus = document.getElementById("ipaStatus");

      if (!ipaInput || !ipaOutput || !ipaStatus) return;

      const VOWEL_MAP = {
        "yi": "iː",
        "ye": "ɛː",
        "ai": "ɑi",
        "iu": "ju",
        "au": "ɑu",
        "ua": "wɑ",
        "ei": "e",
        "ae": "æ",
        "oe": "ʊ",
        "i": "i",
        "e": "ɛ",
        "u": "u",
        "o": "o",
        "a": "ɑ",
      };

      const CONS_MAP = {
        "sh": "ʃ",
        "ch": "ʧ",
        "ng": "ŋ",
        "p": "p",
        "b": "b",
        "t": "t",
        "d": "d",
        "k": "k",
        "g": "g",
        "f": "f",
        "v": "v",
        "s": "s",
        "z": "z",
        "h": "h",
        "m": "m",
        "n": "n",
        "r": "ɹ",
        "l": "l",
        "w": "w",
        "y": "j",   // only when NOT part of yi/ye
        "x": "ks",  // [ks]
      };

      const VOWEL_KEYS = Object.keys(VOWEL_MAP).sort((a, b) => b.length - a.length);
      const CONS_KEYS = Object.keys(CONS_MAP).sort((a, b) => b.length - a.length);
      const ALLOWED_PATTERNS = new Set(["V", "CV", "VC", "CCV", "CCCV", "CVC", "VCC", "VCCC", "CVCC", "CVCCC", "CCVC", "CCCVC", "CCVCC"]);
      const ONSET_ORDER = ["stop", "affricate_fricative", "nasal", "liquid"];
      const CODA_ORDER = ["liquid", "nasal", "affricate_fricative", "stop"];
      const CLASS_BY_RAW = {
        "p": "stop", "b": "stop", "t": "stop", "d": "stop", "k": "stop", "g": "stop",
        "ch": "affricate_fricative",
        "f": "affricate_fricative", "v": "affricate_fricative", "s": "affricate_fricative", "z": "affricate_fricative", "sh": "affricate_fricative", "h": "affricate_fricative", "x": "affricate_fricative",
        "m": "nasal", "n": "nasal", "ng": "nasal",
        "r": "liquid", "l": "liquid",
      };

      function isLetter(ch) {
        return ch >= "a" && ch <= "z";
      }

      function tokenizeSpertz(word) {
        const s = word.toLowerCase();
        const tokens = [];

        let i = 0;
        while (i < s.length) {
          const ch = s[i];

          if (ch === "-" || ch === " " || ch === "\t" || ch === "\n") {
            if (ch === "-") tokens.push({ type: "sep", ipa: "." });
            i++;
            continue;
          }

          if (!isLetter(ch)) throw new Error(`Invalid character: "${ch}"`);

          if (s.startsWith("ch", i)) {
            tokens.push({ type: "cons", ipa: "ʧ", raw: "ch" });
            i += 2;
            continue;
          }

          if (ch === "c") {
            const next2 = s.slice(i + 1, i + 3);
            const next1 = s.slice(i + 1, i + 2);
            const isSoft = next1 === "i" || next2 === "yi";
            tokens.push({ type: "cons", ipa: isSoft ? "s" : "k", raw: "c", cls: isSoft ? "affricate_fricative" : "stop" });
            i += 1;
            continue;
          }

          let matched = false;
          for (const vk of VOWEL_KEYS) {
            if (s.startsWith(vk, i)) {
              tokens.push({ type: "vowel", ipa: VOWEL_MAP[vk], raw: vk });
              i += vk.length;
              matched = true;
              break;
            }
          }
          if (matched) continue;

          for (const ck of CONS_KEYS) {
            if (s.startsWith(ck, i)) {
              tokens.push({ type: "cons", ipa: CONS_MAP[ck], raw: ck });
              i += ck.length;
              matched = true;
              break;
            }
          }
          if (matched) continue;

          throw new Error(`Unsupported spelling at: "${s.slice(i, i + 3)}..."`);
        }

        return tokens;
      }

      function consonantClass(token) {
        if (token.cls) return token.cls;
        const cls = CLASS_BY_RAW[token.raw];
        if (!cls) throw new Error(`Unknown consonant class: "${token.raw}"`);
        return cls;
      }

      function checkClusterOrder(cluster, order, label) {
        if (cluster.length <= 1) return;
        let prevIndex = -1;
        for (const t of cluster) {
          const idx = order.indexOf(consonantClass(t));
          if (idx === -1 || idx <= prevIndex) {
            const clusterText = cluster.map((x) => x.raw || "?").join("");
            throw new Error(`Consonant cluster violates ${label} order: "${clusterText}"`);
          }
          prevIndex = idx;
        }
      }

      function onsetHasNg(cluster) {
        return cluster.some((t) => t.raw === "ng" || t.ipa === "ŋ");
      }

      function onsetLengthFromScoped(scopedArr) {
        let count = 0;
        for (let i = scopedArr.length - 2; i >= 0; i--) {
          const t = scopedArr[i];
          if (t.type === "sep" || t.type === "vowel") break;
          if (t.type === "cons") count++;
        }
        return count;
      }

      function splitBetweenVowels(cluster, onsetLenCurrent) {
        for (let s = 0; s <= cluster.length; s++) {
          const coda = cluster.slice(0, s);
          const onsetNext = cluster.slice(s);
          if (coda.length > 3 || onsetNext.length > 3) continue;
          if (onsetHasNg(onsetNext)) continue;

          try {
            checkClusterOrder(coda, CODA_ORDER, "coda");
            checkClusterOrder(onsetNext, ONSET_ORDER, "onset");
          } catch {
            continue;
          }

          const currentPattern = (onsetLenCurrent > 0 ? "C".repeat(onsetLenCurrent) : "") + "V" + (coda.length > 0 ? "C".repeat(coda.length) : "");
          if (!ALLOWED_PATTERNS.has(currentPattern)) continue;

          const nextPattern = (onsetNext.length > 0 ? "C".repeat(onsetNext.length) : "") + "V";
          if (onsetNext.length > 0 && !ALLOWED_PATTERNS.has(nextPattern)) continue;

          return s;
        }
        return cluster.length;
      }

      function buildScopedTokens(tokens) {
        const scoped = [];

        for (let i = 0; i < tokens.length; i++) {
          const t = tokens[i];
          if (t.type === "sep") {
            scoped.push(t);
            continue;
          }

          if (t.type === "vowel") {
            scoped.push(t);

            if (i + 1 < tokens.length && tokens[i + 1].type === "vowel") {
              scoped.push({ type: "sep", ipa: "." });
              continue;
            }

            const cluster = [];
            let j = i + 1;
            while (j < tokens.length && tokens[j].type !== "sep" && tokens[j].type !== "vowel") {
              cluster.push(tokens[j]);
              j++;
            }

            if (cluster.length && j < tokens.length && tokens[j].type === "vowel") {
              const onsetLenCurrent = onsetLengthFromScoped(scoped);
              const splitAt = splitBetweenVowels(cluster, onsetLenCurrent);
              for (let k = 0; k < splitAt; k++) scoped.push(cluster[k]);
              if (splitAt < cluster.length) scoped.push({ type: "sep", ipa: "." });
              for (let k = splitAt; k < cluster.length; k++) scoped.push(cluster[k]);
            } else {
              for (const c of cluster) scoped.push(c);
            }

            i = j - 1;
            continue;
          }

          scoped.push(t);
        }
        return scoped;
      }

      function validateScoped(scoped) {
        const vowelPositions = [];
        for (let i = 0; i < scoped.length; i++) {
          if (scoped[i].type === "vowel") vowelPositions.push(i);
        }
        if (!vowelPositions.length) throw new Error("No vowel found.");

        for (const vIdx of vowelPositions) {
          const onset = [];
          for (let j = vIdx - 1; j >= 0; j--) {
            if (scoped[j].type === "sep" || scoped[j].type === "vowel") break;
            if (scoped[j].type === "cons") onset.push(scoped[j]);
          }
          onset.reverse();

          const coda = [];
          for (let j = vIdx + 1; j < scoped.length; j++) {
            if (scoped[j].type === "sep" || scoped[j].type === "vowel") break;
            if (scoped[j].type === "cons") coda.push(scoped[j]);
          }

          const pattern = (onset.length ? "C".repeat(onset.length) : "") + "V" + (coda.length ? "C".repeat(coda.length) : "");
          if (!ALLOWED_PATTERNS.has(pattern)) throw new Error(`Invalid syllable pattern: ${pattern}`);
          if (onsetHasNg(onset)) throw new Error("ng cannot appear in onset.");

          checkClusterOrder(onset, ONSET_ORDER, "onset");
          checkClusterOrder(coda, CODA_ORDER, "coda");
        }
      }

      function applyPenultimateStressFromScoped(scoped) {
        const syllableNuclei = [];
        for (let i = 0; i < scoped.length; i++) {
          if (scoped[i].type !== "vowel") continue;
          if (!syllableNuclei.length) {
            syllableNuclei.push(i);
            continue;
          }

          let separated = false;
          for (let j = syllableNuclei[syllableNuclei.length - 1] + 1; j < i; j++) {
            if (scoped[j].type === "sep") {
              separated = true;
              break;
            }
          }
          if (separated) syllableNuclei.push(i);
        }

        if (!syllableNuclei.length) throw new Error("No vowel found (cannot assign stress).");

        const stressIndex = syllableNuclei.length >= 2 ? syllableNuclei[syllableNuclei.length - 2] : syllableNuclei[0];

        const out = [];
        for (let idx = 0; idx < scoped.length; idx++) {
          const t = scoped[idx];
          if (t.type === "sep") {
            continue;
          } else if (idx === stressIndex) {
            out.push("ˈ" + t.ipa);
          } else {
            out.push(t.ipa);
          }
        }
        return out.join("");
      }

      function convertToIPA(input) {
        const trimmed = input.trim();
        if (!trimmed) return { ipa: "—", status: "Waiting for input…" };

        if (trimmed.length > 80) {
          return { ipa: "—", status: "Error: input too long (max 80 characters)." };
        }

        try {
          const tokens = tokenizeSpertz(trimmed);
          const scoped = buildScopedTokens(tokens);
          validateScoped(scoped);
          const ipa = applyPenultimateStressFromScoped(scoped);
          return { ipa: `[${ipa}]`, status: "OK ✅" };
        } catch (err) {
          const msg = err && err.message ? err.message : "Unknown conversion error.";
          if (msg.includes("Consonant cluster violates")) {
            return {
              ipa: "—",
              status: `Error: ${msg} Hint: onset = Stops→Affricates/Fricatives→Nasals→Liquids; coda is the reverse.`,
            };
          }
          return { ipa: "—", status: `Error: ${msg}` };
        }
      }

      function updateIPA() {
        const res = convertToIPA(ipaInput.value);
        ipaOutput.textContent = res.ipa;
        ipaStatus.textContent = res.status;
      }

      ipaInput.addEventListener("input", updateIPA);
      updateIPA();
    })();

    // ===== Spertz Syllable Splitter =====
    (function () {
      const splitInput = document.getElementById("splitInput");
      const splitOutput = document.getElementById("splitOutput");
      const splitStatus = document.getElementById("splitStatus");

      if (!splitInput || !splitOutput || !splitStatus) return;

      const VOWEL_KEYS = ["yi", "ye", "ai", "iu", "au", "ua", "ei", "ae", "oe", "i", "e", "u", "o", "a"];
      const CONS_KEYS = ["sh", "ch", "ng", "p", "b", "t", "d", "k", "g", "f", "v", "s", "z", "h", "m", "n", "r", "l", "w", "y", "x"];

      const ALLOWED_PATTERNS = new Set(["V", "CV", "VC", "CCV", "CCCV", "CVC", "VCC", "VCCC", "CVCC", "CVCCC", "CCVC", "CCCVC", "CCVCC"]);
      const ONSET_ORDER = ["stop", "affricate_fricative", "nasal", "liquid"];
      const CODA_ORDER = ["liquid", "nasal", "affricate_fricative", "stop"];

      const CLASS_BY_RAW = {
        "p": "stop", "b": "stop", "t": "stop", "d": "stop", "k": "stop", "g": "stop",
        "ch": "affricate_fricative",
        "f": "affricate_fricative", "v": "affricate_fricative", "s": "affricate_fricative", "z": "affricate_fricative", "sh": "affricate_fricative", "h": "affricate_fricative", "x": "affricate_fricative",
        "m": "nasal", "n": "nasal", "ng": "nasal",
        "r": "liquid", "l": "liquid",
      };

      function isLetter(ch) {
        return ch >= "a" && ch <= "z";
      }

      function tokenizeSpertz(word) {
        const s = word.toLowerCase();
        const tokens = [];
        let i = 0;

        while (i < s.length) {
          const ch = s[i];

          if (ch === "-" || ch === " " || ch === "\t" || ch === "\n") {
            if (ch === "-") tokens.push({ type: "sep", raw: "." });
            i++;
            continue;
          }

          if (!isLetter(ch)) throw new Error(`Invalid character: "${ch}"`);

          if (s.startsWith("ch", i) || s.startsWith("sh", i) || s.startsWith("ng", i)) {
            const digraph = s.slice(i, i + 2);
            tokens.push({ type: "cons", raw: digraph });
            i += 2;
            continue;
          }

          if (ch === "c") {
            const next2 = s.slice(i + 1, i + 3);
            const next1 = s.slice(i + 1, i + 2);
            const cls = next1 === "i" || next2 === "yi" ? "affricate_fricative" : "stop";
            tokens.push({ type: "cons", raw: "c", cls: cls });
            i += 1;
            continue;
          }

          let matched = false;
          for (const vk of VOWEL_KEYS) {
            if (s.startsWith(vk, i)) {
              tokens.push({ type: "vowel", raw: vk });
              i += vk.length;
              matched = true;
              break;
            }
          }
          if (matched) continue;

          for (const ck of CONS_KEYS) {
            if (s.startsWith(ck, i)) {
              tokens.push({ type: "cons", raw: ck });
              i += ck.length;
              matched = true;
              break;
            }
          }
          if (matched) continue;

          throw new Error(`Unsupported spelling at: "${s.slice(i, i + 3)}..."`);
        }

        return tokens;
      }

      function consonantClass(token) {
        if (token.cls) return token.cls;
        const cls = CLASS_BY_RAW[token.raw];
        if (!cls) throw new Error(`Unknown consonant class: "${token.raw}"`);
        return cls;
      }

      function checkClusterOrder(cluster, order) {
        if (cluster.length <= 1) return;
        let prevIndex = -1;
        for (const t of cluster) {
          const idx = order.indexOf(consonantClass(t));
          if (idx === -1 || idx <= prevIndex) throw new Error("Consonant cluster violates order rule.");
          prevIndex = idx;
        }
      }

      function onsetHasNg(cluster) {
        return cluster.some((t) => t.raw === "ng" || t.ipa === "ŋ");
      }

      function onsetLengthFromScoped(scopedArr) {
        let count = 0;
        for (let i = scopedArr.length - 2; i >= 0; i--) {
          const t = scopedArr[i];
          if (t.type === "sep" || t.type === "vowel") break;
          if (t.type === "cons") count++;
        }
        return count;
      }

      function splitBetweenVowels(cluster, onsetLenCurrent) {
        for (let s = 0; s <= cluster.length; s++) {
          const coda = cluster.slice(0, s);
          const onsetNext = cluster.slice(s);

          if (coda.length > 3 || onsetNext.length > 3) continue;
          if (onsetHasNg(onsetNext)) continue;

          try {
            checkClusterOrder(coda, CODA_ORDER);
            checkClusterOrder(onsetNext, ONSET_ORDER);
          } catch {
            continue;
          }

          const currentPattern = (onsetLenCurrent > 0 ? "C".repeat(onsetLenCurrent) : "") + "V" + (coda.length > 0 ? "C".repeat(coda.length) : "");
          if (!ALLOWED_PATTERNS.has(currentPattern)) continue;

          const nextPattern = (onsetNext.length > 0 ? "C".repeat(onsetNext.length) : "") + "V";
          if (onsetNext.length > 0 && !ALLOWED_PATTERNS.has(nextPattern)) continue;

          return s;
        }
        return cluster.length;
      }

      function buildScopedTokens(tokens) {
        const scoped = [];

        for (let i = 0; i < tokens.length; i++) {
          const t = tokens[i];
          if (t.type === "sep") {
            scoped.push(t);
            continue;
          }

          if (t.type === "vowel") {
            scoped.push(t);

            // Adjacent vowel tokens are separate syllables (hiatus).
            // True diphthongs are already tokenized as one vowel token.
            if (i + 1 < tokens.length && tokens[i + 1].type === "vowel") {
              scoped.push({ type: "sep", raw: "." });
              continue;
            }

            const cluster = [];
            let j = i + 1;
            while (j < tokens.length && tokens[j].type !== "sep" && tokens[j].type !== "vowel") {
              cluster.push(tokens[j]);
              j++;
            }

            if (cluster.length && j < tokens.length && tokens[j].type === "vowel") {
              const onsetLenCurrent = onsetLengthFromScoped(scoped);
              const splitAt = splitBetweenVowels(cluster, onsetLenCurrent);
              for (let k = 0; k < splitAt; k++) scoped.push(cluster[k]);
              if (splitAt < cluster.length) scoped.push({ type: "sep", raw: "." });
              for (let k = splitAt; k < cluster.length; k++) scoped.push(cluster[k]);
            } else {
              for (const c of cluster) scoped.push(c);
            }

            i = j - 1;
            continue;
          }

          scoped.push(t);
        }

        return scoped;
      }

      function validateScoped(scoped) {
        const vowelPositions = [];
        for (let i = 0; i < scoped.length; i++) {
          if (scoped[i].type === "vowel") vowelPositions.push(i);
        }
        if (!vowelPositions.length) throw new Error("No vowel found.");

        for (const vIdx of vowelPositions) {
          const onset = [];
          for (let j = vIdx - 1; j >= 0; j--) {
            if (scoped[j].type === "sep" || scoped[j].type === "vowel") break;
            if (scoped[j].type === "cons") onset.push(scoped[j]);
          }
          onset.reverse();

          const coda = [];
          for (let j = vIdx + 1; j < scoped.length; j++) {
            if (scoped[j].type === "sep" || scoped[j].type === "vowel") break;
            if (scoped[j].type === "cons") coda.push(scoped[j]);
          }

          const pattern = (onset.length ? "C".repeat(onset.length) : "") + "V" + (coda.length ? "C".repeat(coda.length) : "");
          if (!ALLOWED_PATTERNS.has(pattern)) throw new Error(`Invalid syllable pattern: ${pattern}`);
          if (onsetHasNg(onset)) throw new Error("ng cannot appear in onset.");

          checkClusterOrder(onset, ONSET_ORDER);
          checkClusterOrder(coda, CODA_ORDER);
        }
      }

      function splitWord(input) {
        const trimmed = input.trim();
        if (!trimmed) return { out: "—", status: "Waiting for input…" };
        if (trimmed.length > 80) return { out: "—", status: "Error: input too long (max 80 characters)." };

        try {
          const tokens = tokenizeSpertz(trimmed);
          const scoped = buildScopedTokens(tokens);
          validateScoped(scoped);

          const out = scoped
            .map((t) => (t.type === "sep" ? "." : t.raw))
            .join("")
            .replace(/\.{2,}/g, ".")
            .replace(/^\./, "")
            .replace(/\.$/, "");

          return { out: out || "—", status: out ? "OK ✅" : "Error: no valid syllable split." };
        } catch (err) {
          return { out: "—", status: `Error: ${err.message}` };
        }
      }

      function updateSplit() {
        const res = splitWord(splitInput.value);
        splitOutput.textContent = res.out;
        splitStatus.textContent = res.status;
      }

      splitInput.addEventListener("input", updateSplit);
      updateSplit();
    })();

    // ===== Create: Get Your Spertz Archive (Name Generator + IPA + Pronoun) =====
  (function () {
    const firstSyl = document.getElementById("firstSyl");
    const lastSyl = document.getElementById("lastSyl");
    const middleMode = document.getElementById("middleMode");
    const middleSylWrap = document.getElementById("middleSylWrap");
    const middleSyl = document.getElementById("middleSyl");
    const customMiddleWrap = document.getElementById("customMiddleWrap");
    const customMiddle = document.getElementById("customMiddle");

    const genderSelect = document.getElementById("genderSelect");
    const pronounOut = document.getElementById("pronounOut");
    const nameStyle = document.getElementById("nameStyle");

    const regenBtn = document.getElementById("regenNameBtn");
    const copyBtn = document.getElementById("copyNameBtn");

    const fullNameOut = document.getElementById("fullNameOut");
    const nameIpaOut = document.getElementById("nameIpaOut");
    const nameStatusOut = document.getElementById("nameStatusOut");

    if (!firstSyl || !lastSyl || !middleMode || !middleSyl || !genderSelect) return;

    const VOWEL_MAP = {
      "yi": "iː",
      "ye": "ɛː",
      "ai": "ɑi",
      "iu": "ju",
      "au": "ɑu",
      "ua": "wɑ",
      "ei": "e",
      "ae": "æ",
      "oe": "ʊ",
      "i": "i",
      "e": "ɛ",
      "u": "u",
      "o": "o",
      "a": "ɑ",
    };

    const CONS_MAP = {
      "sh": "ʃ",
      "ch": "ʧ",
      "ng": "ŋ",
      "p": "p",
      "b": "b",
      "t": "t",
      "d": "d",
      "k": "k",
      "g": "g",
      "f": "f",
      "v": "v",
      "s": "s",
      "z": "z",
      "h": "h",
      "m": "m",
      "n": "n",
      "r": "ɹ",
      "l": "l",
      "w": "w",
      "y": "j",
      "x": "ks",
    };

    const VOWEL_KEYS = Object.keys(VOWEL_MAP).sort((a, b) => b.length - a.length);
    const CONS_KEYS = Object.keys(CONS_MAP).sort((a, b) => b.length - a.length);

    function isLetter(ch) {
      return ch >= "a" && ch <= "z";
    }

    function tokenizeSpertz(word) {
      const s = word.toLowerCase();
      const tokens = [];
      let i = 0;

      while (i < s.length) {
        const ch = s[i];

        if (ch === "-" || ch === " " || ch === "\t" || ch === "\n") {
          if (ch === "-") tokens.push({ type: "sep", ipa: "." });
          i++;
          continue;
        }

        if (!isLetter(ch)) {
          throw new Error(`Invalid character: "${ch}"`);
        }

        if (s.startsWith("ch", i)) {
          tokens.push({ type: "cons", ipa: "ʧ", raw: "ch" });
          i += 2;
          continue;
        }

        if (ch === "c") {
          const next2 = s.slice(i + 1, i + 3);
          const next1 = s.slice(i + 1, i + 2);
          if (next1 === "i" || next2 === "yi") tokens.push({ type: "cons", ipa: "s" });
          else tokens.push({ type: "cons", ipa: "k" });
          i += 1;
          continue;
        }

        let matched = false;
        for (const vk of VOWEL_KEYS) {
          if (s.startsWith(vk, i)) {
            tokens.push({ type: "vowel", ipa: VOWEL_MAP[vk], raw: vk });
            i += vk.length;
            matched = true;
            break;
          }
        }
        if (matched) continue;

        for (const ck of CONS_KEYS) {
          if (s.startsWith(ck, i)) {
            tokens.push({ type: "cons", ipa: CONS_MAP[ck], raw: ck });
            i += ck.length;
            matched = true;
            break;
          }
        }
        if (matched) continue;

        throw new Error(`Unsupported spelling at: "${s.slice(i, i + 3)}..."`);
      }

      return tokens;
    }

    function validateSyllableStructure(tokens) {
      const allowed = new Set(["V", "CV", "VC", "CCV", "CVC", "VCC", "CVCC", "CCVC", "CCVCC"]);

      const ONSET_ORDER = ["stop", "affricate_fricative", "nasal", "liquid"];
      const CODA_ORDER = ["liquid", "nasal", "affricate_fricative", "stop"];

      const CLASS_BY_RAW = {

        "p": "stop",
        "b": "stop",
        "t": "stop",
        "d": "stop",
        "k": "stop",
        "g": "stop",

        "ch": "affricate_fricative",

        "f": "affricate_fricative",
        "v": "affricate_fricative",
        "s": "affricate_fricative",
        "z": "affricate_fricative",
        "sh": "affricate_fricative",
        "h": "affricate_fricative",

        "m": "nasal",
        "n": "nasal",
        "ng": "nasal",

        "r": "liquid",
        "l": "liquid",
      };

      const CLASS_BY_IPA = {
        "p": "stop",
        "b": "stop",
        "t": "stop",
        "d": "stop",
        "k": "stop",
        "g": "stop",
        "ʧ": "affricate_fricative",
        "f": "affricate_fricative",
        "v": "affricate_fricative",
        "s": "affricate_fricative",
        "z": "affricate_fricative",
        "ʃ": "affricate_fricative",
        "h": "affricate_fricative",
        "m": "nasal",
        "n": "nasal",
        "ŋ": "nasal",
        "ɹ": "liquid",
        "l": "liquid",
      };

      function consClass(t) {
        if (t.raw && CLASS_BY_RAW[t.raw]) return CLASS_BY_RAW[t.raw];
        if (t.ipa && CLASS_BY_IPA[t.ipa]) return CLASS_BY_IPA[t.ipa];
        throw new Error("Unknown consonant class.");
      }

      function checkClusterOrder(cluster, order) {
        if (cluster.length <= 1) return;
        let prevIndex = -1;
        for (const t of cluster) {
          const cls = consClass(t);
          const idx = order.indexOf(cls);
          if (idx === -1) throw new Error(`Consonant class not allowed: ${cls}`);
          if (idx <= prevIndex) {
            throw new Error("Consonant cluster violates order rule.");
          }
          prevIndex = idx;
        }
      }

      function onsetHasNg(cluster) {
        return cluster.some((t) => t.raw === "ng" || t.ipa === "ŋ");
      }

      function onsetLengthFromScoped(scopedArr) {
        let count = 0;
        for (let i = scopedArr.length - 2; i >= 0; i--) {
          const t = scopedArr[i];
          if (t.type === "sep" || t.type === "vowel") break;
          if (t.type === "cons") count++;
        }
        return count;
      }

      function splitBetweenVowels(cluster, onsetLenCurrent) {
        for (let s = 0; s <= cluster.length; s++) {
          const coda = cluster.slice(0, s);
          const onsetNext = cluster.slice(s);

          if (coda.length > 3 || onsetNext.length > 3) continue;
          if (onsetHasNg(onsetNext)) continue;

          try {
            checkClusterOrder(coda, CODA_ORDER);
            checkClusterOrder(onsetNext, ONSET_ORDER);
          } catch {
            continue;
          }

          const pattern =
            (onsetLenCurrent > 0 ? "C".repeat(onsetLenCurrent) : "") +
            "V" +
            (coda.length > 0 ? "C".repeat(coda.length) : "");

          if (!allowed.has(pattern)) continue;

          const nextPattern =
            (onsetNext.length > 0 ? "C".repeat(onsetNext.length) : "") + "V";
          if (onsetNext.length > 0 && !allowed.has(nextPattern)) continue;

          return s; // valid split found
        }
        return cluster.length; // fallback: all to coda
      }

      const scoped = [];
      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t.type === "sep") {
          scoped.push(t);
          continue;
        }

        if (t.type === "vowel") {
          scoped.push(t);

          const cluster = [];
          let j = i + 1;
          while (j < tokens.length && tokens[j].type !== "sep" && tokens[j].type !== "vowel") {
            cluster.push(tokens[j]);
            j++;
          }

          if (cluster.length && j < tokens.length && tokens[j].type === "vowel") {
            const onsetLenCurrent = onsetLengthFromScoped(scoped);
            const splitAt = splitBetweenVowels(cluster, onsetLenCurrent);

            for (let k = 0; k < splitAt; k++) scoped.push(cluster[k]);
            if (splitAt < cluster.length) scoped.push({ type: "sep", ipa: "." });
            for (let k = splitAt; k < cluster.length; k++) scoped.push(cluster[k]);
          } else {
            for (let k = 0; k < cluster.length; k++) scoped.push(cluster[k]);
          }

          i = j - 1;
          continue;
        }

        scoped.push(t);
      }

      const vowelPositions = [];
      for (let i = 0; i < scoped.length; i++) {
        if (scoped[i].type === "vowel") vowelPositions.push(i);
      }
      if (vowelPositions.length === 0) throw new Error("No vowel found.");

      for (let vi = 0; vi < vowelPositions.length; vi++) {
        const vIdx = vowelPositions[vi];

        const onsetTokens = [];
        for (let j = vIdx - 1; j >= 0; j--) {
          if (scoped[j].type === "sep") break;
          if (scoped[j].type === "vowel") break;
          if (scoped[j].type === "cons") onsetTokens.push(scoped[j]);
        }
        onsetTokens.reverse();

        const codaTokens = [];
        for (let j = vIdx + 1; j < scoped.length; j++) {
          if (scoped[j].type === "sep") break;
          if (scoped[j].type === "vowel") break;
          if (scoped[j].type === "cons") codaTokens.push(scoped[j]);
        }

        let pattern = "";
        if (onsetTokens.length === 0) pattern += "";
        else pattern += "C".repeat(onsetTokens.length);
        pattern += "V";
        if (codaTokens.length > 0) pattern += "C".repeat(codaTokens.length);

        if (!allowed.has(pattern)) {
          throw new Error(`Invalid syllable pattern: ${pattern}`);
        }
        if (onsetHasNg(onsetTokens)) {
          throw new Error("ng cannot appear in onset.");
        }

        checkClusterOrder(onsetTokens, ONSET_ORDER);
        checkClusterOrder(codaTokens, CODA_ORDER);
      }
    }

    function applyPenultimateStress(tokens) {
      const vowelIndexes = [];
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type === "vowel") vowelIndexes.push(i);
      }
      if (vowelIndexes.length === 0) throw new Error("No vowel found (cannot assign stress).");

      const stressIndex = vowelIndexes.length >= 2 ? vowelIndexes[vowelIndexes.length - 2] : vowelIndexes[0];

      const out = [];
      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        if (i === stressIndex) out.push("ˈ" + t.ipa);
        else out.push(t.ipa);
      }
      return out.join("");
    }

    function toIPA(text) {
      const tokens = tokenizeSpertz(text);
      validateSyllableStructure(tokens);
      const ipa = applyPenultimateStress(tokens);
      return `[${ipa}]`;
    }

    const VOWEL_SPELLINGS = ["i", "ei", "e", "ae", "u", "oe", "o", "a", "ai", "iu", "au", "ua"];

    const CONSONANT_CLASSES = {
      stop: ["p", "b", "t", "d", "k", "g"],
      affricate_fricative: ["ch", "f", "v", "s", "z", "sh", "h"],
      nasal: ["m", "n", "ng"],
      liquid: ["r", "l"],
    };

    const ONSET_ORDER = ["stop", "affricate_fricative", "nasal", "liquid"];
    const CODA_ORDER = ["liquid", "nasal", "affricate_fricative", "stop"];

    const TEMPLATES = ["V", "CV", "VC", "CCV", "CVC", "VCC", "CVCC", "CCVC", "CCVCC"];

    const STYLE_PRESETS = {
      none: {
        vowels: VOWEL_SPELLINGS,
        templates: TEMPLATES,
        classWeights: { stop: 1, affricate: 0.6, fricative: 1, nasal: 1, liquid: 1 },
        templateWeights: { V: 0.5, CV: 2.5, VC: 1.1, CCV: 0.4, CVC: 2, VCC: 0.25, CVCC: 0.45, CCVC: 0.4, CCVCC: 0.15 },
      },
      international: {
        vowels: ["a", "e", "i", "o", "u", "ae", "ei", "oe"],
        templates: ["V", "CV", "CVC", "VC", "CCV", "VCC", "CVCC"],
        classWeights: { stop: 1, affricate: 0.2, fricative: 0.8, nasal: 1.2, liquid: 1.3 },
        templateWeights: { V: 0.8, CV: 3, VC: 1.1, CCV: 0.3, CVC: 2.2, VCC: 0.22, CVCC: 0.35 },
      },
      north: {
        vowels: ["a", "o", "u", "ae", "au"],
        templates: ["CV", "CCV", "CVC", "VCC", "CVCC", "CCVC"],
        classWeights: { stop: 1.6, affricate: 0.7, fricative: 1.2, nasal: 0.8, liquid: 0.7 },
        templateWeights: { CV: 1.6, CCV: 0.45, CVC: 2, VCC: 0.3, CVCC: 0.5, CCVC: 0.45 },
      },
      east: {
        vowels: ["i", "e", "ei", "ae", "iu", "oe", "a"],
        templates: ["V", "CV", "CVC", "CCV", "VCC", "CVCC"],
        classWeights: { stop: 0.7, affricate: 0.4, fricative: 0.9, nasal: 1.3, liquid: 1.4 },
        templateWeights: { V: 1.1, CV: 3, CVC: 1.4, CCV: 0.3, VCC: 0.22, CVCC: 0.35 },
      },
      west: {
        vowels: ["o", "u", "oe", "au", "a", "ei"],
        templates: ["CV", "CCV", "CVC", "VCC", "CVCC", "VC"],
        classWeights: { stop: 1.1, affricate: 0.5, fricative: 1.4, nasal: 0.9, liquid: 1.1 },
        templateWeights: { CV: 2, CCV: 0.45, CVC: 2, VCC: 0.3, CVCC: 0.45, VC: 0.9 },
      },
      south: {
        vowels: ["a", "ae", "ai", "au", "ua", "o"],
        templates: ["V", "CV", "CCV", "CVC", "VCC", "CVCC", "CCVC"],
        classWeights: { stop: 0.9, affricate: 0.6, fricative: 0.8, nasal: 1, liquid: 1.5 },
        templateWeights: { V: 1, CV: 2.2, CCV: 0.4, CVC: 1.6, VCC: 0.28, CVCC: 0.45, CCVC: 0.4 },
      },
    };

    function rand(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function weightedPick(items, weights) {
      const total = items.reduce((sum, item) => sum + (weights[item] || 0), 0);
      let r = Math.random() * total;
      for (const item of items) {
        r -= (weights[item] || 0);
        if (r <= 0) return item;
      }
      return items[items.length - 1];
    }

    function normalizeClassWeights(classWeights) {
      return {
        stop: classWeights.stop || 0,
        affricate_fricative: (classWeights.affricate || 0) + (classWeights.fricative || 0),
        nasal: classWeights.nasal || 0,
        liquid: classWeights.liquid || 0,
      };
    }

    function pickOrderedClasses(order, count, classWeights) {
      const picked = [];
      let lastIndex = -1;
      for (let i = 0; i < count; i++) {
        const min = lastIndex + 1;
        const max = order.length - (count - i);
        const slice = order.slice(min, max + 1);
        const cls = weightedPick(slice, classWeights);
        const idx = order.indexOf(cls);
        picked.push(cls);
        lastIndex = idx;
      }
      return picked;
    }

    function buildCluster(order, count, classWeights, isOnset) {
      if (count === 0) return "";
      const classes = pickOrderedClasses(order, count, classWeights);
      return classes
        .map((cls) => {
          if (isOnset && cls === "nasal") return rand(["m", "n"]);
          return rand(CONSONANT_CLASSES[cls]);
        })
        .join("");
    }

    function buildSyllable(styleKey) {
      const preset = STYLE_PRESETS[styleKey] || STYLE_PRESETS.none;
      const vowel = rand(preset.vowels);
      const template = weightedPick(preset.templates, preset.templateWeights);
      const mergedClassWeights = normalizeClassWeights(preset.classWeights);

      let onsetCount = 0;
      let codaCount = 0;

      if (template === "V") {
        onsetCount = 0; codaCount = 0;
      } else if (template === "CV") {
        onsetCount = 1; codaCount = 0;
      } else if (template === "VC") {
        onsetCount = 0; codaCount = 1;
      } else if (template === "CCV") {
        onsetCount = 2; codaCount = 0;
      } else if (template === "CCCV") {
        onsetCount = 3; codaCount = 0;
      } else if (template === "CVC") {
        onsetCount = 1; codaCount = 1;
      } else if (template === "VCC") {
        onsetCount = 0; codaCount = 2;
      } else if (template === "VCCC") {
        onsetCount = 0; codaCount = 3;
      } else if (template === "CVCC") {
        onsetCount = 1; codaCount = 2;
      } else if (template === "CVCCC") {
        onsetCount = 1; codaCount = 3;
      } else if (template === "CCVC") {
        onsetCount = 2; codaCount = 1;
      } else if (template === "CCCVC") {
        onsetCount = 3; codaCount = 1;
      } else if (template === "CCVCC") {
        onsetCount = 2; codaCount = 2;
      }

      const onset = buildCluster(ONSET_ORDER, onsetCount, mergedClassWeights, true);
      const coda = buildCluster(CODA_ORDER, codaCount, mergedClassWeights, false);
      return onset + vowel + coda;
    }

    function generateNamePart(syllableCount, styleKey) {
      let out = "";
      for (let i = 0; i < syllableCount; i++) out += buildSyllable(styleKey);

      for (let tries = 0; tries < 20; tries++) {
        try {
          const tokens = tokenizeSpertz(out);
          validateSyllableStructure(tokens);
          return out;
        } catch {
          out = "";
          for (let i = 0; i < syllableCount; i++) out += buildSyllable(styleKey);
        }
      }
      return out;
    }

    function pronounFromGender(key) {
      if (key === "male") return "Sperte";
      if (key === "female") return "Sie";
      if (key === "nb") return "Spite";
      return "Tatie";
    }

    function updatePronoun() {
      pronounOut.textContent = pronounFromGender(genderSelect.value);
    }

    const firstMode = document.getElementById("firstMode");
const lastMode = document.getElementById("lastMode");

const firstSylWrap = document.getElementById("firstSylWrap");
const lastSylWrap = document.getElementById("lastSylWrap");

const customFirstWrap = document.getElementById("customFirstWrap");
const customLastWrap = document.getElementById("customLastWrap");

const customFirst = document.getElementById("customFirst");
const customLast = document.getElementById("customLast");

    function setFirstUI() {
  if (firstMode.value === "custom") {
    firstSylWrap.style.display = "none";
    customFirstWrap.style.display = "";
  } else {
    firstSylWrap.style.display = "";
    customFirstWrap.style.display = "none";
  }
}

function setLastUI() {
  if (lastMode.value === "custom") {
    lastSylWrap.style.display = "none";
    customLastWrap.style.display = "";
  } else {
    lastSylWrap.style.display = "";
    customLastWrap.style.display = "none";
  }
}

    function setMiddleUI() {
      if (middleMode.value === "random") {
        middleSylWrap.style.display = "";
        customMiddleWrap.style.display = "none";
      } else if (middleMode.value === "custom") {
        middleSylWrap.style.display = "none";
        customMiddleWrap.style.display = "";
      } else {
        middleSylWrap.style.display = "none";
        customMiddleWrap.style.display = "none";
      }
    }

    function buildFullName() {

  let first = "";
  if (firstMode.value === "custom") {
    first = (customFirst.value || "").trim();
    if (!first) throw new Error("Custom first name is empty.");

    const tokens = tokenizeSpertz(first);
    validateSyllableStructure(tokens);
  } else {
    const fCount = parseInt(firstSyl.value, 10);
    first = generateNamePart(fCount, nameStyle ? nameStyle.value : "none");
  }

  let last = "";
  if (lastMode.value === "custom") {
    last = (customLast.value || "").trim();
    if (!last) throw new Error("Custom last name is empty.");

    const tokens = tokenizeSpertz(last);
    validateSyllableStructure(tokens);
  } else {
    const lCount = parseInt(lastSyl.value, 10);
    last = generateNamePart(lCount, nameStyle ? nameStyle.value : "none");
  }

  let middle = "";
  if (middleMode.value === "random") {
    const mCount = parseInt(middleSyl.value, 10);
    middle = generateNamePart(mCount, nameStyle ? nameStyle.value : "none");
  } else if (middleMode.value === "custom") {
    middle = (customMiddle.value || "").trim();
    if (!middle) throw new Error("Custom middle name is empty.");

    const tokens = tokenizeSpertz(middle);
    validateSyllableStructure(tokens);
  }

  const parts = [first];
  if (middleMode.value !== "none") parts.push(middle);
  parts.push(last);

  return parts;
}

    function refreshAll(regenerate) {
      try {
        updatePronoun();
        setFirstUI();
        setLastUI();
        setMiddleUI();

        const parts = buildFullName();
        const fullName = parts.join(" ");
        fullNameOut.textContent = fullName;

        const ipaParts = parts.map(p => `${p} ${toIPA(p)}`);
        nameIpaOut.textContent = ipaParts.join("   |   ");

        nameStatusOut.textContent = "OK ✅";
      } catch (e) {
        fullNameOut.textContent = "—";
        nameIpaOut.textContent = "—";
        nameStatusOut.textContent = `Error: ${e.message}`;
      }

    }

    async function copyResult() {
      const text = `${fullNameOut.textContent}\nPronoun: ${pronounOut.textContent}\nIPA: ${nameIpaOut.textContent}`;
      try {
        await navigator.clipboard.writeText(text);
        nameStatusOut.textContent = "Copied ✅";
      } catch {
        nameStatusOut.textContent = "Copy failed (browser blocked clipboard).";
      }
    }

    middleMode.addEventListener("change", () => refreshAll(true));
    firstMode.addEventListener("change", () => refreshAll(true));
lastMode.addEventListener("change", () => refreshAll(true));

    firstSyl.addEventListener("change", () => refreshAll(true));
    lastSyl.addEventListener("change", () => refreshAll(true));
    middleSyl.addEventListener("change", () => refreshAll(true));
    genderSelect.addEventListener("change", () => refreshAll(false));
    if (nameStyle) nameStyle.addEventListener("change", () => refreshAll(true));

    if (customMiddle) customMiddle.addEventListener("input", () => refreshAll(false));
if (customFirst) customFirst.addEventListener("input", () => refreshAll(false));
if (customLast) customLast.addEventListener("input", () => refreshAll(false));

    regenBtn.addEventListener("click", () => refreshAll(true));
    copyBtn.addEventListener("click", copyResult);

    setFirstUI();
setLastUI();
setMiddleUI();
refreshAll(true);
  })();

      // ===== Verb Conjugation Lab =====
  (function () {
    const verbSelect = document.getElementById("verbSelect");
    const verbMeaning = document.getElementById("verbMeaning");

    const subjAgree = document.getElementById("subjAgree");
    const objMarker = document.getElementById("objMarker");
    const humanObj = document.getElementById("humanObj");
    const tenseSel = document.getElementById("tenseSel");
    const aspectSel = document.getElementById("aspectSel");
    const moodSel = document.getElementById("moodSel");
    const dynSel = document.getElementById("dynSel");

    const previewOut = document.getElementById("previewOut");
    const ipaOutVerb = document.getElementById("ipaOutVerb");
    const glossOut = document.getElementById("glossOut");
    const statusOut = document.getElementById("verbLabStatus");

    if (!verbSelect || !subjAgree || !previewOut) return;

    const VERBS = [
      ["ampi","believe"],
      ["ampiria","hope"],
      ["aye","have"],
      ["beya","need, want"],
      ["dara","dance"],
      ["daresu","understand"],
      ["daro","suppose; assume"],
      ["davi","lose"],
      ["daze","close"],
      ["dezu","explain"],
      ["doye","cause; make"],
      ["dravo","arrive"],
      ["fane","end; finish"],
      ["fireno","request"],
      ["folo","forget"],
      ["fure","rest"],
      ["fureyi","continue"],
      ["gavu","eat"],
      ["golu","drink"],
      ["heta","speak; say"],
      ["heti","listen"],
      ["hodape","open"],
      ["jion","like"],
      ["kame","consider"],
      ["kampi","keep"],
      ["kamu","think"],
      ["korati","challenge"],
      ["krei","do; make"],
      ["krechei","decision"],
      ["lanko","belong to"],
      ["lavi","love"],
      ["laza","play"],
      ["liguria","shine; illuminate"],
      ["lika","read"],
      ["lume","research; study"],
      ["lure","talk; converse"],
      ["meli","remember"],
      ["melu","miss"],
      ["mezu","write"],
      ["mie","meet"],
      ["miori","participate"],
      ["mire","describe"],
      ["mura","marry"],
      ["namu","be called; be named"],
      ["nata","put; place"],
      ["navine","walk"],
      ["nelu","search; look for"],
      ["novi","follow"],
      ["oio","regard as; treat as"],
      ["paraya","leave"],
      ["petra","rise"],
      ["poso","occupy"],
      ["pozo","prove"],
      ["praisa","aim at"],
      ["praise","guide"],
      ["quino","ask"],
      ["quma","choose"],
      ["rake","get; obtain"],
      ["raku","prepare"],
      ["reni","answer"],
      ["revo","run"],
      ["revu","return"],
      ["sela","tell"],
      ["sire","paint"],
      ["sola","sleep"],
      ["solvia","sing"],
      ["soraye","study; learn"],
      ["sorae","teach"],
      ["sumi","count"],
      ["su","live; exist"],
      ["suri","live"],
      ["tamu","work"],
      ["tira","come"],
      ["tiru","bring"],
      ["tori","carry"],
      ["trake","begin; start"],
      ["tra","stand"],
      ["trepsa","oppose"],
      ["trive","share"],
      ["vayi","want"],
      ["veli","wait"],
      ["veska","travel"],
      ["veskari","please"],
      ["vese","see"],
      ["vire","receive"],
      ["vona","watch"],
      ["zanu","appreciate; admire"],
      ["zeyo","go"],
      ["zeyu","should"],
      ["zima","buy"],
    ];

    const verbToMeaning = Object.fromEntries(VERBS);

    function fillVerbSelect() {
      verbSelect.innerHTML = "";
      for (const [v, m] of VERBS) {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        verbSelect.appendChild(opt);
      }

      verbSelect.value = "krei";
    }

    const SUBJECT_SUFFIX = {
      "omit": "",
      "1sg": "t",
      "1pl": "wen",
      "2sg": "ya",
      "2pl": "yen",
      "3sg": "se",
      "3pl": "ten",
    };

    const ASPECT_SUFFIX = {
      "none": "",
      "ok": "ok",
      "im": "im",
      "ul": "ul",
      "en": "en",
    };

    const MOOD_SUFFIX = {
      "none": "",
      "or": "or",
      "el": "el",
    };

    const VOWEL_MAP = {
      "yi": "iː",
      "ye": "ɛː",
      "ai": "ɑi",
      "iu": "ju",
      "au": "ɑu",
      "ua": "wɑ",
      "ei": "e",
      "ae": "æ",
      "oe": "ʊ",
      "i": "i",
      "e": "ɛ",
      "u": "u",
      "o": "o",
      "a": "ɑ",
    };

    const CONS_MAP = {
      "sh": "ʃ",
      "ch": "ʧ",
      "ng": "ŋ",
      "p": "p",
      "b": "b",
      "t": "t",
      "d": "d",
      "k": "k",
      "g": "g",
      "f": "f",
      "v": "v",
      "s": "s",
      "z": "z",
      "h": "h",
      "m": "m",
      "n": "n",
      "r": "ɹ",
      "l": "l",
      "w": "w",
      "y": "j",
      "x": "ks",
    };

    const VOWEL_KEYS = Object.keys(VOWEL_MAP).sort((a, b) => b.length - a.length);
    const CONS_KEYS = Object.keys(CONS_MAP).sort((a, b) => b.length - a.length);

    function isLetter(ch) {
      return ch >= "a" && ch <= "z";
    }

    function tokenizeSpertz(s) {
      const text = s.toLowerCase();
      const tokens = [];
      let i = 0;

      while (i < text.length) {
        const ch = text[i];

        if (ch === "-" || ch === " " || ch === "\t" || ch === "\n") {
          if (ch === "-") tokens.push({ type: "sep", ipa: "." });
          i++;
          continue;
        }

        if (!isLetter(ch)) throw new Error(`Invalid character: "${ch}"`);

        if (text.startsWith("ch", i)) {
          tokens.push({ type: "cons", ipa: "ʧ" });
          i += 2;
          continue;
        }

        if (ch === "c") {
          const next2 = text.slice(i + 1, i + 3);
          const next1 = text.slice(i + 1, i + 2);
          tokens.push({ type: "cons", ipa: (next1 === "i" || next2 === "yi") ? "s" : "k" });
          i += 1;
          continue;
        }

        let matched = false;

        for (const vk of VOWEL_KEYS) {
          if (text.startsWith(vk, i)) {
            tokens.push({ type: "vowel", ipa: VOWEL_MAP[vk] });
            i += vk.length;
            matched = true;
            break;
          }
        }
        if (matched) continue;

        for (const ck of CONS_KEYS) {
          if (text.startsWith(ck, i)) {
            tokens.push({ type: "cons", ipa: CONS_MAP[ck] });
            i += ck.length;
            matched = true;
            break;
          }
        }
        if (matched) continue;

        throw new Error("Unsupported spelling.");
      }

      return tokens;
    }

    function applyPenultimateStress(tokens) {
      const vIdxs = [];
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type === "vowel") vIdxs.push(i);
      }
      if (vIdxs.length === 0) throw new Error("No vowel found.");

      const stressIdx = vIdxs.length >= 2 ? vIdxs[vIdxs.length - 2] : vIdxs[0];

      const out = [];
      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        if (i === stressIdx) out.push("ˈ" + t.ipa);
        else out.push(t.ipa);
      }
      return out.join("");
    }

    function toIPA(form) {
      const tokens = tokenizeSpertz(form);
      return `[${applyPenultimateStress(tokens)}]`;
    }

    function buildVerbForm() {
      const verb = verbSelect.value;

      const subj = SUBJECT_SUFFIX[subjAgree.value] || "";
      const obj = objMarker.value; // none/ta/te
      let human = humanObj.value; // none/sa/x

      if (obj === "none") human = "none";
      if (obj === "te") human = "none";

      const tense = tenseSel.value;

      const asp = ASPECT_SUFFIX[aspectSel.value] || "";
      const mood = MOOD_SUFFIX[moodSel.value] || "";
      const dyn = dynSel.value === "og" ? "og" : "";

      let base = verb;
      if (tense === "future") base = `i-${verb}`;

      let out = base;

      if (subj) out += subj;
      if (obj !== "none") out += obj;
      if (human !== "none") out += human;

      if (tense === "past") out += "et";
      if (asp) out += asp;
      if (mood) out += mood;
      if (dyn) out += dyn;

      return { form: out, humanResolved: human };
    }

    function roughGloss(formInfo) {
      const meaning = verbToMeaning[verbSelect.value] || "—";

      const subjKey = subjAgree.value;
      const subjEn =
        subjKey === "1sg" ? "I" :
        subjKey === "1pl" ? "we" :
        subjKey === "2sg" ? "you" :
        subjKey === "2pl" ? "you (pl)" :
        subjKey === "3sg" ? "they/he/she" :
        subjKey === "3pl" ? "they" :
        "(someone)";

      const tense = tenseSel.value;
      const aspect = aspectSel.value;
      const mood = moodSel.value;

      const obj = objMarker.value;
      const human = formInfo.humanResolved;

      let objPhrase = "";
      if (obj === "ta") {
        if (human === "sa") objPhrase = " someone";
        else if (human === "x") objPhrase = " (a royal person)";
        else objPhrase = " something";
      } else if (obj === "te") {
        objPhrase = " (oneself)";
      }

      let aux = "";
      if (mood === "el") aux += "might ";
      if (tense === "future") aux += "will ";
      if (tense === "past") aux += "did ";

      let aspectNote = "";
      if (aspect === "ok") aspectNote = " (ongoing)";
      if (aspect === "im") aspectNote = " (completed)";
      if (aspect === "ul") aspectNote = " (habitually)";
      if (aspect === "en") aspectNote = " (repeatedly)";

      const dyn = dynSel.value === "og" ? " (dynamic)" : "";

      return `${subjEn} ${aux}${meaning}${objPhrase}${aspectNote}${dyn}`.replace(/\s+/g, " ").trim();
    }

    function update() {
      try {

        const obj = objMarker.value;
        if (obj === "none" || obj === "te") {
          humanObj.value = "none";
          humanObj.disabled = true;
        } else {
          humanObj.disabled = false;
        }

        verbMeaning.textContent = verbToMeaning[verbSelect.value] || "—";

        const built = buildVerbForm();
        previewOut.textContent = built.form;

        ipaOutVerb.textContent = toIPA(built.form);

        glossOut.textContent = roughGloss(built);

        statusOut.textContent = "OK ✅";
      } catch (e) {
        previewOut.textContent = "—";
        ipaOutVerb.textContent = "—";
        glossOut.textContent = "—";
        statusOut.textContent = `Error: ${e.message}`;
      }
    }

    fillVerbSelect();

    [
      verbSelect, subjAgree, objMarker, humanObj,
      tenseSel, aspectSel, moodSel, dynSel
    ].forEach(el => el.addEventListener("change", update));

    update();
  })();

   // ===== Create: Birthday System  =====
(function () {
  const birthYear = document.getElementById("birthYear");
  const birthMonth = document.getElementById("birthMonth");
  const birthDay = document.getElementById("birthDay");
  const randomBirthBtn = document.getElementById("randomBirthBtn");

  const birthSpertzOut = document.getElementById("birthSpertzOut");
  const birthIpaOut = document.getElementById("birthIpaOut");
  const birthEngOut = document.getElementById("birthEngOut");
  const birthStatusOut = document.getElementById("birthStatusOut");

  if (!birthYear || !birthMonth || !birthDay || !randomBirthBtn) return;

  const MONTHS = [
    { en: "January",   sp: "tarul",  days: 31 },
    { en: "February",  sp: "resur",  days: 30 },
    { en: "March",     sp: "kilup",  days: 30 },
    { en: "April",     sp: "votir",  days: 30 },
    { en: "May",       sp: "meka",   days: 30 },
    { en: "June",      sp: "xisata", days: 31 },
    { en: "July",      sp: "xisere", days: 31 },
    { en: "August",    sp: "xisiki", days: 31 },
    { en: "September", sp: "dalur",  days: 30 },
    { en: "October",   sp: "zaivim", days: 30 },
    { en: "November",  sp: "fiurua", days: 30 },
    { en: "December",  sp: "xisovo", days: 31 },
  ];

  const UNIT_MONTH = "taris";
  const UNIT_DAY = "davir";
  const UNIT_YEAR = "zalu";

  const DIGITS = {
    0: "zu", 1: "ta", 2: "re", 3: "ki", 4: "vo",
    5: "me", 6: "dal", 7: "zai", 8: "fiu", 9: "no"
  };

  function numToSpertz(n) {
    if (!Number.isFinite(n) || !Number.isInteger(n)) throw new Error("Number must be an integer.");
    if (n < 0) throw new Error("Number must be non-negative.");
    if (n === 0) return DIGITS[0];

    const digits = String(n).split("").map(d => parseInt(d, 10));
    const parts = [];

    for (let i = 0; i < digits.length; i++) {
      const d = digits[i];
      const pos = digits.length - 1 - i; // 0 = ones, 1 = tens, 2 = hundreds...

      if (d === 0) continue;

      if (pos === 0) {
        parts.push(DIGITS[d]);
      } else {
        const exponentWord = DIGITS[pos]; // pos < 10 for our use (year <= 2099)
        const place = exponentWord + "zu"; // e.g. 10^2 => rezu, 10^3 => kizu
        parts.push(DIGITS[d] + place);
      }
    }

    return parts.join("-");
  }

  const VOWEL_MAP = {
    "yi": "iː",
    "ye": "ɛː",
    "ai": "ɑi",
    "iu": "ju",
    "au": "ɑu",
    "ua": "wɑ",
    "ei": "e",
    "ae": "æ",
    "oe": "ʊ",
    "i": "i",
    "e": "ɛ",
    "u": "u",
    "o": "o",
    "a": "ɑ",
  };

  const CONS_MAP = {
    "sh": "ʃ",
    "ch": "ʧ",
    "ng": "ŋ",
    "p": "p",
    "b": "b",
    "t": "t",
    "d": "d",
    "k": "k",
    "g": "g",
    "f": "f",
    "v": "v",
    "s": "s",
    "z": "z",
    "h": "h",
    "m": "m",
    "n": "n",
    "r": "ɹ",
    "l": "l",
    "w": "w",
    "y": "j",
    "x": "ks",
  };

  const VOWEL_KEYS = Object.keys(VOWEL_MAP).sort((a, b) => b.length - a.length);
  const CONS_KEYS = Object.keys(CONS_MAP).sort((a, b) => b.length - a.length);

  function isLetter(ch) {
    return ch >= "a" && ch <= "z";
  }

  function tokenizeSpertz(text) {
    const s = text.toLowerCase();
    const tokens = [];
    let i = 0;

    while (i < s.length) {
      const ch = s[i];

      if (ch === "-" || ch === " " || ch === "\t" || ch === "\n") {
        if (ch === "-") tokens.push({ type: "sep", ipa: "." });
        i++;
        continue;
      }

      if (!isLetter(ch)) throw new Error(`Invalid character: "${ch}"`);

      if (s.startsWith("ch", i)) {
        tokens.push({ type: "cons", ipa: "ʧ" });
        i += 2;
        continue;
      }

      if (ch === "c") {
        const next2 = s.slice(i + 1, i + 3);
        const next1 = s.slice(i + 1, i + 2);
        tokens.push({ type: "cons", ipa: (next1 === "i" || next2 === "yi") ? "s" : "k" });
        i += 1;
        continue;
      }

      let matched = false;

      for (const vk of VOWEL_KEYS) {
        if (s.startsWith(vk, i)) {
          tokens.push({ type: "vowel", ipa: VOWEL_MAP[vk] });
          i += vk.length;
          matched = true;
          break;
        }
      }
      if (matched) continue;

      for (const ck of CONS_KEYS) {
        if (s.startsWith(ck, i)) {
          tokens.push({ type: "cons", ipa: CONS_MAP[ck] });
          i += ck.length;
          matched = true;
          break;
        }
      }
      if (matched) continue;

      throw new Error("Unsupported spelling.");
    }

    return tokens;
  }

  function applyPenultimateStress(tokens) {
    const vIdxs = [];
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].type === "vowel") vIdxs.push(i);
    }
    if (vIdxs.length === 0) throw new Error("No vowel found.");

    const stressIdx = vIdxs.length >= 2 ? vIdxs[vIdxs.length - 2] : vIdxs[0];

    const out = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];
      if (i === stressIdx) out.push("ˈ" + t.ipa);
      else out.push(t.ipa);
    }
    return out.join("");
  }

  function toIPA(text) {
    const tokens = tokenizeSpertz(text);
    return `[${applyPenultimateStress(tokens)}]`;
  }

  function fillMonthSelect() {
    birthMonth.innerHTML = "";
    MONTHS.forEach((m, idx) => {
      const opt = document.createElement("option");
      opt.value = String(idx); // 0-based
      opt.textContent = `${m.en} (${m.sp})`;
      birthMonth.appendChild(opt);
    });
    birthMonth.value = "0";
  }

  function clampDayToMonth() {
    const mi = parseInt(birthMonth.value, 10);
    const maxDay = MONTHS[mi].days;

    birthDay.max = String(maxDay);
    const d = Number(birthDay.value);
    if (Number.isFinite(d) && d > maxDay) birthDay.value = String(maxDay);
    if (Number.isFinite(d) && d < 1) birthDay.value = "1";
  }

  function formatSpertzBirthday(y, mIndex, d) {
    const monthObj = MONTHS[mIndex];

    const dayWord = numToSpertz(d);
    const yearWord = numToSpertz(y);

    return `${dayWord} ${UNIT_DAY} ${monthObj.sp} ${UNIT_MONTH} ${yearWord} ${UNIT_YEAR}`;
  }

  function formatEnglishBirthday(y, mIndex, d) {
    const monthObj = MONTHS[mIndex];
    return `${monthObj.en} ${d}, ${y}`;
  }

  function updateBirthday() {
    try {
      const yRaw = birthYear.value;
      const dRaw = birthDay.value;
      const mi = parseInt(birthMonth.value, 10);

      clampDayToMonth();

      if (!yRaw || !dRaw) {
        birthSpertzOut.textContent = "—";
        birthIpaOut.textContent = "—";
        birthEngOut.textContent = "—";
        birthStatusOut.textContent = "Waiting for input…";
        return;
      }

      const y = Number(yRaw);
      const d = Number(dRaw);

      if (!Number.isInteger(y) || y < 1920 || y > 2099) {
        throw new Error("Year must be an integer between 1920 and 2099.");
      }

      const maxDay = MONTHS[mi].days;
      if (!Number.isInteger(d) || d < 1 || d > maxDay) {
        throw new Error(`Day must be 1–${maxDay} for ${MONTHS[mi].en}.`);
      }

      const spertzStr = formatSpertzBirthday(y, mi, d);
      birthSpertzOut.textContent = spertzStr;
      birthEngOut.textContent = formatEnglishBirthday(y, mi, d);
      birthIpaOut.textContent = toIPA(spertzStr);

      birthStatusOut.textContent = "OK ✅";
    } catch (e) {
      birthSpertzOut.textContent = "—";
      birthIpaOut.textContent = "—";
      birthEngOut.textContent = "—";
      birthStatusOut.textContent = `Error: ${e.message}`;
    }
  }

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function randomBirthday() {
    const y = randomInt(1920, 2099);
    const mi = randomInt(0, 11);
    const d = randomInt(1, MONTHS[mi].days);

    birthYear.value = String(y);
    birthMonth.value = String(mi);
    birthDay.value = String(d);

    updateBirthday();
  }

  fillMonthSelect();

  birthYear.value = "2001";
  birthMonth.value = "0";
  birthDay.value = "1";
  clampDayToMonth();
  updateBirthday();

  birthYear.addEventListener("input", updateBirthday);
  birthMonth.addEventListener("change", updateBirthday);
  birthDay.addEventListener("input", updateBirthday);
  randomBirthBtn.addEventListener("click", randomBirthday);
})();

    // ===== Create: Pixel Portrait Maker =====
    (function () {
      const canvas = document.getElementById("portraitCanvas");
      const skinColor = document.getElementById("skinColor");
      const hairColor = document.getElementById("hairColor");
      const hairHighlight = document.getElementById("hairHighlight");
      const leftEyeColor = document.getElementById("leftEyeColor");
      const rightEyeColor = document.getElementById("rightEyeColor");
      const leftEyeTop = document.getElementById("leftEyeTop");
      const leftEyeBottom = document.getElementById("leftEyeBottom");
      const rightEyeTop = document.getElementById("rightEyeTop");
      const rightEyeBottom = document.getElementById("rightEyeBottom");
      const eyeSpecialToggle = document.getElementById("eyeSpecialToggle");
      const pupilToggle = document.getElementById("pupilToggle");
      const browShape = document.getElementById("browShape");
      const hairBack = document.getElementById("hairBack");
      const hairBackLength = document.getElementById("hairBackLength");
      const hairBackOther = document.getElementById("hairBackOther");
      const hairFront = document.getElementById("hairFront");
      const hairFrontSide = document.getElementById("hairFrontSide");
      const hairTemples = document.getElementById("hairTemples");
      const hairBraids = document.getElementById("hairBraids");
      const hairSingleBraidPos = document.getElementById("hairSingleBraidPos");
      const hairSingleBraidLen = document.getElementById("hairSingleBraidLen");
      const hairDoubleBraidStyle = document.getElementById("hairDoubleBraidStyle");
      const hairDoubleBraidSide = document.getElementById("hairDoubleBraidSide");
      const hairDoubleBraidLen = document.getElementById("hairDoubleBraidLen");
      const hairLowTwinLen = document.getElementById("hairLowTwinLen");
      const eyeShape = document.getElementById("eyeShape");
      const eyeWinkSide = document.getElementById("eyeWinkSide");
      const eyeWinkSecond = document.getElementById("eyeWinkSecond");
      const eyeClosedSide = document.getElementById("eyeClosedSide");
      const noseShape = document.getElementById("noseShape");
      const mouthShape = document.getElementById("mouthShape");
      const mouthSize = document.getElementById("mouthSize");
      const outfitStyle = document.getElementById("outfitStyle");
      const blazerStyle = document.getElementById("blazerStyle");
      const outfitColor = document.getElementById("outfitColor");
      const bgStyle = document.getElementById("bgStyle");
      const bgColor = document.getElementById("bgColor");
      const genderStyle = document.getElementById("genderStyle");
      const randomBtn = document.getElementById("portraitRandom");
      const downloadBtn = document.getElementById("portraitDownload");
      const portraitTabs = document.querySelectorAll(".portrait-tab");
      const portraitViewPixel = document.getElementById("portraitViewPixel");
      const portraitViewIllustrated = document.getElementById("portraitViewIllustrated");
      const illustratedPortrait = document.getElementById("illustratedPortrait");
      const drawBody = document.getElementById("drawBody");
      const drawNose = document.getElementById("drawNose");
      const drawEyes = document.getElementById("drawEyes");
      const drawEyeTint = document.getElementById("drawEyeTint");
      const drawPupil = document.getElementById("drawPupil");
      const drawBrows = document.getElementById("drawBrows");
      const drawMouth = document.getElementById("drawMouth");
      const drawFrontHair = document.getElementById("drawFrontHair");
      const drawTemples = document.getElementById("drawTemples");
      const drawBraids = document.getElementById("drawBraids");
      const drawBackHair = document.getElementById("drawBackHair");
      const drawOutfit = document.getElementById("drawOutfit");
      const drawAccessory = document.getElementById("drawAccessory");

      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const size = 128;
      const BASE = 64;
      const DRAW_SCALE = 2;
      const SCALE = 4;
      const OFFSET = Math.floor((size - BASE * DRAW_SCALE) / 2);
      canvas.width = size * SCALE;
      canvas.height = size * SCALE;
      ctx.imageSmoothingEnabled = false;
      const ILLUSTRATED_BASE = "/Users/bxh0608elrykw/Library/Mobile Documents/com~apple~CloudDocs/html/images for stvn.world/";

      const COLORS = {
        skin: [
          { name: "Porcelain", hex: "#f2d6c9" },
          { name: "Sand", hex: "#e6c39b" },
          { name: "Honey", hex: "#d7a76b" },
          { name: "Umber", hex: "#b57b4a" },
          { name: "Cedar", hex: "#8c5b3c" },
          { name: "Ebony", hex: "#5a3a2e" },
        ],
        hair: [
          { name: "Inkveil", hex: "#1c1a22" },
          { name: "Midnight Ash", hex: "#2c2b36" },
          { name: "Chestnut Ember", hex: "#5b3a2e" },
          { name: "Copper Glow", hex: "#8a4b2c" },
          { name: "Golden Haze", hex: "#c7a04e" },
          { name: "Silver Mist", hex: "#8e8a86" },
          { name: "Plum Noir", hex: "#4b2c3b" },
          { name: "Teal Tide", hex: "#2f5a5a" },
          { name: "Rose Quartz", hex: "#f3a7c9" },
          { name: "Skyglass", hex: "#6aa7ff" },
          { name: "Violet Crown", hex: "#9a7bff" },
          { name: "Crimson Flame", hex: "#cc4b4b" },
          { name: "Abyss Blue", hex: "#1f2f6b" },
          { name: "Nocturne Purple", hex: "#2f1b4d" },
          { name: "Garnet Ember", hex: "#7b1f2a" },
          { name: "Carrot Glow", hex: "#e06a2b" },
        ],
        eyes: [
          { name: "Skyfall", hex: "#6ab3ff" },
          { name: "Leaflight", hex: "#6fcf97" },
          { name: "Amberglow", hex: "#f2b94f" },
          { name: "Violet Bloom", hex: "#9b8cff" },
          { name: "Roseflare", hex: "#ff7fb0" },
          { name: "Slate Ice", hex: "#9bb1c9" },
          { name: "Onyx", hex: "#1a1a1f" },
          { name: "Crimson", hex: "#d34a4a" },
          { name: "Orchid", hex: "#c26bff" },
          { name: "Deep Ocean", hex: "#2f4fa7" },
        ],
        outfit: [
          { name: "Ivory", hex: "#f5efe6" },
          { name: "Rose", hex: "#f2c2d6" },
          { name: "Sky", hex: "#cbe2ff" },
          { name: "Lilac", hex: "#e3d1ff" },
          { name: "Mint", hex: "#c9f0df" },
          { name: "Sun", hex: "#ffe1a8" },
          { name: "Ink", hex: "#2b2b36" },
        ],
        background: [
          { name: "Snow", hex: "#ffffff" },
          { name: "Powder Pink", hex: "#ffe6f0" },
          { name: "Mist Blue", hex: "#e6f2ff" },
          { name: "Lavender", hex: "#efe6ff" },
          { name: "Mint Fog", hex: "#e6fff5" },
          { name: "Peach", hex: "#ffe9d6" },
        ],
      };
      window.PORTRAIT_COLORS = COLORS;

      const OPTIONS = {
        hairBack: ["Base Style", "Straight", "Curly", "Other"],
        hairBackLength: ["Short", "Medium", "Long"],
        hairBackOther: ["Shoulder-Length Layered", "Messy Curly Crop", "Pixie Bob", "Low Sleek Ponytail", "Soft Wavy Shag"],
        hairFront: ["Blocky Bangs", "Feathery Strands", "Cat Ear Fringe", "Zigzag Fringe", "Asymmetrical Cat Bangs", "Heart Peak Fringe", "Thick Block Fringe", "Single Cat Ear Fringe", "Asymmetrical Block Fringe", "Simplified Asymmetrical Fringe", "One-Sided Swept Fringe"],
        hairFrontSide: ["Left", "Right"],
        hairTemples: ["None", "Soft", "Sharp", "Long"],
        hairBraids: ["None", "Single", "Double"],
        hairSingleBraidPos: ["High", "Low", "Ponytail"],
        hairSingleBraidLen: ["Short", "Medium", "Long"],
        hairDoubleBraidStyle: ["Twin ponytails", "Braided pigtails 1", "Braided pigtails 2", "Low twin ponytails", "High twin ponytails", "Four ponytails", "Roman roll"],
        hairDoubleBraidSide: ["Both", "Left", "Right"],
        hairDoubleBraidLen: ["Short", "Medium", "Long"],
        hairLowTwinLen: ["Short", "Medium", "Thin"],
        eyeShape: ["Normal", "Upturned", "Sleepy", "Wink", "Closed"],
        eyeWinkSide: ["Both", "Left", "Right"],
        eyeWinkSecond: ["Normal", "Upturned", "Sleepy"],
        eyeClosedSide: ["Both", "Left", "Right"],
        browShape: ["Bean", "Angry", "Calm", "Normal", "Curious"],
        noseShape: ["Dot", "Bridge", "Normal"],
        mouthShape: ["Smile", "Normal", "Happy"],
        mouthSize: ["Small", "Big"],
        outfitStyle: ["Standard Collar Shirt", "Button-Down Collar Shirt", "Mandarin Collar Shirt", "Crew Neck T-Shirt", "Turtleneck Top", "Turtleneck Sweater"],
        blazerStyle: ["None", "Notched Lapel Blazer"],
        bgStyle: ["White", "Solid", "Hearts", "Stars"],
        genderStyle: ["Neutral", "Masculine", "Feminine"],
      };
      window.PORTRAIT_OPTIONS = OPTIONS;

      function fillSelect(select, list, getLabel) {
        select.innerHTML = "";
        list.forEach((item, idx) => {
          const opt = document.createElement("option");
          opt.value = String(idx);
          opt.textContent = getLabel ? getLabel(item) : item;
          select.appendChild(opt);
        });
      }

      fillSelect(skinColor, COLORS.skin, (c) => c.name);
      fillSelect(hairColor, COLORS.hair, (c) => c.name);
      fillSelect(hairHighlight, [{ name: "None", hex: "" }].concat(COLORS.hair), (c) => c.name);
      fillSelect(leftEyeColor, COLORS.eyes, (c) => c.name);
      fillSelect(rightEyeColor, COLORS.eyes, (c) => c.name);
      fillSelect(leftEyeTop, COLORS.eyes, (c) => c.name);
      fillSelect(leftEyeBottom, COLORS.eyes, (c) => c.name);
      fillSelect(rightEyeTop, COLORS.eyes, (c) => c.name);
      fillSelect(rightEyeBottom, COLORS.eyes, (c) => c.name);
      fillSelect(outfitColor, COLORS.outfit, (c) => c.name);
      fillSelect(hairBack, OPTIONS.hairBack);
      fillSelect(hairBackLength, OPTIONS.hairBackLength);
      fillSelect(hairBackOther, OPTIONS.hairBackOther);
      fillSelect(hairFront, OPTIONS.hairFront);
      fillSelect(hairFrontSide, OPTIONS.hairFrontSide);
      fillSelect(hairTemples, OPTIONS.hairTemples);
      fillSelect(hairBraids, OPTIONS.hairBraids);
      fillSelect(hairSingleBraidPos, OPTIONS.hairSingleBraidPos);
      fillSelect(hairSingleBraidLen, OPTIONS.hairSingleBraidLen);
      fillSelect(hairDoubleBraidStyle, OPTIONS.hairDoubleBraidStyle);
      fillSelect(hairDoubleBraidSide, OPTIONS.hairDoubleBraidSide);
      fillSelect(hairDoubleBraidLen, OPTIONS.hairDoubleBraidLen);
      fillSelect(hairLowTwinLen, OPTIONS.hairLowTwinLen);
      fillSelect(eyeShape, OPTIONS.eyeShape);
      fillSelect(eyeWinkSide, OPTIONS.eyeWinkSide);
      fillSelect(eyeWinkSecond, OPTIONS.eyeWinkSecond);
      fillSelect(eyeClosedSide, OPTIONS.eyeClosedSide);
      fillSelect(browShape, OPTIONS.browShape);
      fillSelect(noseShape, OPTIONS.noseShape);
      fillSelect(mouthShape, OPTIONS.mouthShape);
      fillSelect(mouthSize, OPTIONS.mouthSize);
      fillSelect(outfitStyle, OPTIONS.outfitStyle);
      fillSelect(blazerStyle, OPTIONS.blazerStyle);
      fillSelect(bgStyle, OPTIONS.bgStyle);
      fillSelect(bgColor, COLORS.background, (c) => c.name);
      fillSelect(genderStyle, OPTIONS.genderStyle);

      function randIdx(arr) {
        return Math.floor(Math.random() * arr.length);
      }

      function pixRaw(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);
      }

      function pix(x, y, color) {
        pixRaw(x * DRAW_SCALE + OFFSET, y * DRAW_SCALE + OFFSET, color);
      }

      function drawEllipse(cx, cy, rx, ry, color) {
        const scx = cx * DRAW_SCALE + OFFSET;
        const scy = cy * DRAW_SCALE + OFFSET;
        const srx = rx * DRAW_SCALE;
        const sry = ry * DRAW_SCALE;
        for (let y = Math.floor(scy - sry); y <= Math.ceil(scy + sry); y++) {
          for (let x = Math.floor(scx - srx); x <= Math.ceil(scx + srx); x++) {
            const dx = (x - scx) / srx;
            const dy = (y - scy) / sry;
            if (dx * dx + dy * dy <= 1) pixRaw(x, y, color);
          }
        }
      }

      function drawRectRaw(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * SCALE, y * SCALE, w * SCALE, h * SCALE);
      }

      function drawRect(x, y, w, h, color) {
        drawRectRaw(x * DRAW_SCALE + OFFSET, y * DRAW_SCALE + OFFSET, w * DRAW_SCALE, h * DRAW_SCALE, color);
      }

      function shade(hex, amt) {
        const n = parseInt(hex.slice(1), 16);
        let r = (n >> 16) + amt;
        let g = ((n >> 8) & 0xff) + amt;
        let b = (n & 0xff) + amt;
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        b = Math.max(0, Math.min(255, b));
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
      }

      function drawPortrait() {
        ctx.clearRect(0, 0, size * SCALE, size * SCALE);
        const bgHex = COLORS.background[parseInt(bgColor.value, 10)]?.hex || "#ffffff";
        const bgMode = OPTIONS.bgStyle[parseInt(bgStyle.value, 10)] || "White";
        if (bgMode === "White") {
          drawRectRaw(0, 0, size, size, "#ffffff");
        } else {
          drawRectRaw(0, 0, size, size, bgHex);
          if (bgMode === "Hearts") {
            for (let y = 6; y < size; y += 12) {
              for (let x = 6; x < size; x += 12) {
                pixRaw(x, y, "#ffffff");
                pixRaw(x + 1, y, "#ffffff");
                pixRaw(x - 1, y, "#ffffff");
                pixRaw(x, y + 1, "#ffffff");
                pixRaw(x, y + 2, "#ffffff");
                pixRaw(x - 1, y + 1, "#ffffff");
                pixRaw(x + 1, y + 1, "#ffffff");
              }
            }
          } else if (bgMode === "Stars") {
            for (let y = 4; y < size; y += 10) {
              for (let x = 4; x < size; x += 10) {
                pixRaw(x, y, "#ffffff");
                pixRaw(x + 1, y, "#ffffff");
                pixRaw(x - 1, y, "#ffffff");
                pixRaw(x, y + 1, "#ffffff");
                pixRaw(x, y - 1, "#ffffff");
              }
            }
          }
        }

        const skin = COLORS.skin[parseInt(skinColor.value, 10)]?.hex || COLORS.skin[0].hex;
        const hair = COLORS.hair[parseInt(hairColor.value, 10)]?.hex || COLORS.hair[0].hex;
        const highlightIndex = parseInt(hairHighlight.value, 10);
        const highlight = highlightIndex > 0 ? COLORS.hair[highlightIndex - 1]?.hex : "";
        const specialEyesOn = !!eyeSpecialToggle?.checked;
        const baseEye = COLORS.eyes[parseInt(leftEyeColor.value, 10)]?.hex || COLORS.eyes[0].hex;
        const leftEye = COLORS.eyes[parseInt(leftEyeColor.value, 10)]?.hex || baseEye;
        const rightEyeRaw = COLORS.eyes[parseInt(rightEyeColor.value, 10)]?.hex || leftEye;
        const rightEye = specialEyesOn ? rightEyeRaw : leftEye;
        const leftTopRaw = COLORS.eyes[parseInt(leftEyeTop.value, 10)]?.hex || leftEye;
        const leftBottomRaw = COLORS.eyes[parseInt(leftEyeBottom.value, 10)]?.hex || leftEye;
        const rightTopRaw = COLORS.eyes[parseInt(rightEyeTop.value, 10)]?.hex || rightEye;
        const rightBottomRaw = COLORS.eyes[parseInt(rightEyeBottom.value, 10)]?.hex || rightEye;
        const leftTop = specialEyesOn ? leftTopRaw : leftEye;
        const leftBottom = specialEyesOn ? leftBottomRaw : leftEye;
        const rightTop = specialEyesOn ? rightTopRaw : rightEye;
        const rightBottom = specialEyesOn ? rightBottomRaw : rightEye;
        const outfit = COLORS.outfit[parseInt(outfitColor.value, 10)]?.hex || COLORS.outfit[0].hex;
        const outfitShade = shade(outfit, -18);
        const outfitLight = shade(outfit, 18);
        const hairLight = shade(hair, 28);
        const hairDark = shade(hair, -20);

        const backType = OPTIONS.hairBack[parseInt(hairBack.value, 10)] || "Straight";
        const backLength = OPTIONS.hairBackLength[parseInt(hairBackLength.value, 10)] || "Short";
        const backOther = OPTIONS.hairBackOther[parseInt(hairBackOther.value, 10)] || "Shoulder-Length Layered";
        const front = OPTIONS.hairFront[parseInt(hairFront.value, 10)] || "Blocky Bangs";
        const frontSide = OPTIONS.hairFrontSide[parseInt(hairFrontSide?.value || "0", 10)] || "Left";
        const temples = OPTIONS.hairTemples[parseInt(hairTemples.value, 10)] || "None";
        const braids = OPTIONS.hairBraids[parseInt(hairBraids.value, 10)] || "None";
        const singlePos = OPTIONS.hairSingleBraidPos[parseInt(hairSingleBraidPos.value, 10)] || "High";
        const singleLen = OPTIONS.hairSingleBraidLen[parseInt(hairSingleBraidLen.value, 10)] || "Short";
        const doubleStyle = OPTIONS.hairDoubleBraidStyle[parseInt(hairDoubleBraidStyle.value, 10)] || "Twin ponytails";
        const doubleSide = OPTIONS.hairDoubleBraidSide[parseInt(hairDoubleBraidSide.value, 10)] || "Both";
        const doubleLen = OPTIONS.hairDoubleBraidLen[parseInt(hairDoubleBraidLen.value, 10)] || "Short";
        const lowTwinLen = OPTIONS.hairLowTwinLen[parseInt(hairLowTwinLen.value, 10)] || "Short";

        function drawBackHairAndBraids() {
          if (backType === "Base Style") {
            drawRect(11, 24, 7, 16, hair);
            drawRect(46, 24, 7, 16, hair);
            drawRect(10, 38, 8, 4, hair);
            drawRect(46, 38, 8, 4, hair);
            drawRect(13, 26, 2, 10, hairLight);
            drawRect(49, 26, 2, 10, hairLight);
            drawRect(16, 36, 4, 6, hairDark);
            drawRect(42, 36, 4, 6, hairDark);
          } else if (backType === "Straight") {
            if (backLength === "Short") {
              drawRect(12, 24, 7, 9, hair);
              drawRect(45, 24, 7, 9, hair);
              drawRect(12, 32, 7, 2, hairDark);
              drawRect(45, 32, 7, 2, hairDark);
              drawRect(14, 25, 2, 6, hairLight);
              drawRect(48, 25, 2, 6, hairLight);
            } else if (backLength === "Medium") {
              drawRect(10, 24, 8, 18, hair);
              drawRect(46, 24, 8, 18, hair);
              drawRect(9, 40, 9, 4, hairDark);
              drawRect(46, 40, 9, 4, hairDark);
              drawRect(12, 26, 2, 12, hairLight);
              drawRect(50, 26, 2, 12, hairLight);
            } else if (backLength === "Long") {
              drawRect(8, 22, 10, 32, hair);
              drawRect(46, 22, 10, 32, hair);
              drawRect(16, 46, 10, 10, hair);
              drawRect(38, 46, 10, 10, hair);
              drawRect(10, 24, 2, 20, hairLight);
              drawRect(52, 24, 2, 20, hairLight);
              drawRect(16, 52, 8, 4, hairDark);
              drawRect(40, 52, 8, 4, hairDark);
            }
          } else if (backType === "Curly") {
            if (backLength === "Short") {
              for (let y = 24; y <= 30; y += 3) {
                drawRect(12, y, 6, 3, hair);
                drawRect(46, y, 6, 3, hair);
              }
            } else if (backLength === "Medium") {
              for (let y = 24; y <= 40; y += 4) {
                drawRect(10, y, 8, 3, hair);
                drawRect(46, y, 8, 3, hair);
              }
            } else if (backLength === "Long") {
              for (let y = 22; y <= 48; y += 4) {
                drawRect(8, y, 10, 3, hair);
                drawRect(46, y, 10, 3, hair);
              }
              drawRect(14, 46, 10, 4, hair);
              drawRect(40, 46, 10, 4, hair);
            }
          } else if (backType === "Other") {
            if (backOther === "Shoulder-Length Layered") {
              drawRect(10, 24, 8, 18, hair);
              drawRect(46, 24, 8, 18, hair);
              drawRect(14, 34, 6, 4, hairLight);
              drawRect(44, 34, 6, 4, hairLight);
              drawRect(16, 40, 6, 6, hairDark);
              drawRect(42, 40, 6, 6, hairDark);
            } else if (backOther === "Messy Curly Crop") {
              drawRect(9, 24, 9, 20, hair);
              drawRect(46, 24, 9, 20, hair);
              drawRect(20, 40, 6, 8, hairDark);
              drawRect(38, 40, 6, 8, hairDark);
            } else if (backOther === "Pixie Bob") {
              drawRect(12, 24, 6, 12, hair);
              drawRect(46, 24, 6, 12, hair);
              drawRect(16, 34, 6, 6, hairDark);
              drawRect(40, 34, 6, 6, hairDark);
            } else if (backOther === "Low Sleek Ponytail") {
              drawRect(12, 24, 6, 10, hair);
              drawRect(46, 24, 6, 10, hair);
              drawRect(28, 36, 8, 20, hair);
              drawRect(30, 54, 4, 4, hairDark);
            } else if (backOther === "Soft Wavy Shag") {
              drawRect(10, 24, 8, 18, hair);
              drawRect(46, 24, 8, 18, hair);
              drawRect(18, 38, 8, 8, hairDark);
              drawRect(38, 38, 8, 8, hairDark);
            } else {
              drawRect(12, 24, 6, 18, hair);
              drawRect(46, 24, 6, 18, hair);
              drawRect(18, 38, 8, 10, hairDark);
              drawRect(38, 38, 8, 10, hairDark);
            }
          }

          if (braids === "Single") {
            if (singlePos === "High") {
              drawRect(47, 22, 4, 18, hair);
              drawRect(48, 40, 2, 6, hairDark);
            } else if (singlePos === "Low") {
              drawRect(47, 30, 4, 18, hair);
              drawRect(48, 48, 2, 6, hairDark);
            } else {
              if (singleLen === "Short") {
                drawRect(47, 24, 4, 12, hair);
                drawRect(48, 36, 2, 4, hairDark);
              } else if (singleLen === "Medium") {
                drawRect(47, 24, 4, 18, hair);
                drawRect(48, 42, 2, 6, hairDark);
              } else {
                drawRect(47, 24, 4, 26, hair);
                drawRect(48, 50, 2, 6, hairDark);
              }
            }
          } else if (braids === "Double") {
            const ponyLen = (len) => {
              if (len === "Long") return 26;
              if (len === "Medium") return 18;
              if (len === "Thin") return 14;
              return 12;
            };
            const drawTwin = (yStart, width, len, side) => {
              const h = ponyLen(len);
              if (side !== "Right") {
                drawRect(10, yStart, width, h, hair);
                drawRect(10 + Math.floor(width / 2), yStart + h, 2, 6, hairDark);
              }
              if (side !== "Left") {
                drawRect(50, yStart, width, h, hair);
                drawRect(50 + Math.floor(width / 2), yStart + h, 2, 6, hairDark);
              }
            };
            if (doubleStyle === "Twin ponytails") {
              drawTwin(24, 4, doubleLen, doubleSide);
            } else if (doubleStyle === "Low twin ponytails") {
              drawTwin(30, lowTwinLen === "Thin" ? 3 : 4, lowTwinLen, doubleSide);
            } else if (doubleStyle === "High twin ponytails") {
              drawTwin(20, 4, "Short", doubleSide);
            } else if (doubleStyle === "Braided pigtails 1") {
              drawTwin(26, 4, "Medium", doubleSide);
              if (doubleSide !== "Right") drawRect(12, 36, 2, 8, hairDark);
              if (doubleSide !== "Left") drawRect(52, 36, 2, 8, hairDark);
            } else if (doubleStyle === "Braided pigtails 2") {
              drawTwin(28, 3, "Short", doubleSide);
              if (doubleSide !== "Right") drawRect(12, 38, 1, 8, hairDark);
              if (doubleSide !== "Left") drawRect(52, 38, 1, 8, hairDark);
            } else if (doubleStyle === "Four ponytails") {
              if (doubleSide !== "Right") {
                drawRect(8, 24, 3, 12, hair);
                drawRect(14, 24, 3, 12, hair);
              }
              if (doubleSide !== "Left") {
                drawRect(47, 24, 3, 12, hair);
                drawRect(53, 24, 3, 12, hair);
              }
            } else if (doubleStyle === "Roman roll") {
              if (doubleSide !== "Right") {
                drawRect(12, 24, 6, 6, hair);
                drawRect(14, 30, 4, 4, hairDark);
              }
              if (doubleSide !== "Left") {
                drawRect(46, 24, 6, 6, hair);
                drawRect(46, 30, 4, 4, hairDark);
              }
            } else {
              drawTwin(24, 4, "Short", doubleSide);
            }
          }
        }

        drawBackHairAndBraids();

        drawEllipse(32, 30, 15, 19, skin);
        drawRect(27, 47, 10, 7, skin);
        drawRect(28, 46, 8, 1, shade(skin, 8));

        drawRect(16, 30, 3, 7, shade(skin, -2));
        drawRect(45, 30, 3, 7, shade(skin, -2));

        const vibe = OPTIONS.genderStyle[parseInt(genderStyle.value, 10)] || "Neutral";
        if (vibe === "Masculine") {
          drawRect(24, 20, 5, 1, shade(skin, -30));
          drawRect(35, 20, 5, 1, shade(skin, -30));
        } else if (vibe === "Feminine") {

          drawRect(24, 30, 2, 2, shade(skin, 20));
          drawRect(38, 30, 2, 2, shade(skin, 20));
          drawRect(23, 27, 3, 1, shade(hair, -10));
          drawRect(38, 27, 3, 1, shade(hair, -10));
        } else {

          drawRect(27, 31, 1, 1, shade(skin, 12));
          drawRect(36, 31, 1, 1, shade(skin, 12));
        }

        drawEllipse(32, 14, 20, 10, hair);
        drawRect(12, 16, 40, 10, hair);

        drawRect(14, 10, 36, 3, hairLight);
        drawRect(14, 22, 36, 2, hairDark);

        const fringeHeightsByStyle = {
          "Blocky Bangs": [11, 11, 11, 11, 11, 11, 11],
          "Feathery Strands": [5, 8, 6, 9, 6, 8, 5],
          "Cat Ear Fringe": [12, 9, 7, 6, 7, 9, 12],
          "Zigzag Fringe": [5, 11, 6, 10, 6, 11, 5],
          "Asymmetrical Cat Bangs": [4, 6, 8, 10, 12, 12, 11],
          "Heart Peak Fringe": [10, 9, 8, 6, 8, 9, 10],
          "Thick Block Fringe": [13, 13, 13, 13, 13, 13, 13],
          "Single Cat Ear Fringe": [13, 11, 8, 7, 6, 6, 5],
          "Asymmetrical Block Fringe": [12, 12, 10, 10, 8, 8, 6],
          "Simplified Asymmetrical Fringe": [9, 9, 8, 8, 7, 7, 6],
          "One-Sided Swept Fringe": [4, 5, 6, 8, 11, 13, 12],
        };
        const sideAwareFronts = new Set([
          "Single Cat Ear Fringe",
          "Asymmetrical Block Fringe",
          "Simplified Asymmetrical Fringe",
          "One-Sided Swept Fringe",
        ]);
        const baseFringeHeights = fringeHeightsByStyle[front] || fringeHeightsByStyle["Blocky Bangs"];
        const fringeHeights = sideAwareFronts.has(front) && frontSide === "Right"
          ? baseFringeHeights.slice().reverse()
          : baseFringeHeights;
        let fx = 18;
        fringeHeights.forEach((h) => {
          drawRect(fx, 22, 2, h, hair);
          fx += 2;
        });
        if (temples === "Soft") {
          drawRect(14, 26, 4, 8, hair);
          drawRect(46, 26, 4, 8, hair);
        } else if (temples === "Sharp") {
          drawRect(14, 24, 3, 10, hairDark);
          drawRect(47, 24, 3, 10, hairDark);
        } else if (temples === "Long") {
          drawRect(12, 24, 4, 18, hair);
          drawRect(48, 24, 4, 18, hair);
        }

        if (highlight) {
          drawRect(22, 12, 3, 10, highlight);
          drawRect(39, 12, 3, 10, highlight);
          if (backType !== "Other" && backLength === "Medium") {
            drawRect(10, 26, 2, 12, highlight);
            drawRect(52, 26, 2, 12, highlight);
          }
          if (backType !== "Other" && backLength === "Long") {
            drawRect(8, 28, 2, 16, highlight);
            drawRect(54, 28, 2, 16, highlight);
          }
        } else {

          drawRect(23, 12, 2, 10, hairLight);
          drawRect(39, 12, 2, 10, hairLight);
        }

        const eyeForm = OPTIONS.eyeShape[parseInt(eyeShape.value, 10)] || "Normal";
        const winkSide = OPTIONS.eyeWinkSide[parseInt(eyeWinkSide?.value || "0", 10)] || "Both";
        const closedSide = OPTIONS.eyeClosedSide
          ? (OPTIONS.eyeClosedSide[parseInt(eyeClosedSide?.value || "0", 10)] || "Both")
          : "Both";
        const winkSecond = OPTIONS.eyeWinkSecond[parseInt(eyeWinkSecond?.value || "0", 10)] || "Normal";
        const activeSide = eyeForm === "Wink" ? winkSide : closedSide;
        let leftForm = eyeForm;
        let rightForm = eyeForm;
        if (eyeForm === "Wink" || eyeForm === "Closed") {
          if (activeSide === "Left") {
            leftForm = eyeForm;
            rightForm = winkSecond;
          } else if (activeSide === "Right") {
            leftForm = winkSecond;
            rightForm = eyeForm;
          } else {
            leftForm = eyeForm;
            rightForm = eyeForm;
          }
        }
        const drawEye = (x, form, top, bottom, lid) => {
          if (form === "None") return;
          if (form === "Wink") {
            drawRect(x, 29, 10, 1, lid);
            drawRect(x + 2, 30, 6, 1, lid);
            return;
          }
          if (form === "Closed") {
            drawRect(x, 29, 10, 1, lid);
            drawRect(x + 1, 30, 8, 1, lid);
            return;
          }
          if (form === "Normal") {
            drawRect(x, 27, 10, 7, "#ffffff");
            drawRect(x + 2, 28, 6, 3, top);
            drawRect(x + 2, 31, 6, 3, bottom);
            drawRect(x + 3, 30, 3, 3, shade(bottom, -30));
            drawRect(x + 3, 28, 2, 2, "#ffffff");
            drawRect(x, 26, 10, 1, lid);
          } else if (form === "Upturned") {
            drawRect(x, 27, 10, 7, "#ffffff");
            drawRect(x + 2, 28, 6, 3, top);
            drawRect(x + 2, 31, 6, 3, bottom);
            drawRect(x + 3, 30, 3, 3, shade(bottom, -30));
            drawRect(x + 5, 28, 2, 1, "#ffffff");
            drawRect(x + 7, 27, 2, 1, lid);
            drawRect(x, 26, 10, 1, lid);
          } else if (form === "Sleepy") {
            drawRect(x, 30, 10, 3, "#ffffff");
            drawRect(x + 3, 31, 4, 1, bottom);
            drawRect(x, 29, 10, 1, lid);
          }
        };
        const lid = shade(hair, -10);
        const brow = OPTIONS.browShape[parseInt(browShape.value, 10)] || "Normal";
        const browInk = shade(hair, -26);
        const drawBrowPair = (leftPts, rightPts) => {
          leftPts.forEach(([bx, by, bw = 2, bh = 1]) => drawRect(bx, by, bw, bh, browInk));
          rightPts.forEach(([bx, by, bw = 2, bh = 1]) => drawRect(bx, by, bw, bh, browInk));
        };
        if (brow === "Bean") {
          drawBrowPair(
            [[22, 24, 3, 1], [25, 23, 3, 1], [28, 24, 2, 1]],
            [[34, 24, 2, 1], [36, 23, 3, 1], [39, 24, 3, 1]]
          );
        } else if (brow === "Angry") {
          drawBrowPair(
            [[22, 26, 3, 1], [25, 25, 3, 1], [28, 24, 2, 1]],
            [[34, 24, 2, 1], [36, 25, 3, 1], [39, 26, 3, 1]]
          );
        } else if (brow === "Calm") {
          drawBrowPair(
            [[22, 24, 8, 1]],
            [[34, 24, 8, 1]]
          );
        } else if (brow === "Curious") {
          drawBrowPair(
            [[22, 23, 8, 1]],
            [[34, 25, 8, 1]]
          );
        } else {
          drawBrowPair(
            [[22, 24, 8, 1], [24, 23, 4, 1]],
            [[34, 24, 8, 1], [36, 23, 4, 1]]
          );
        }
        drawEye(21, leftForm, leftTop, leftBottom, lid);
        drawEye(33, rightForm, rightTop, rightBottom, lid);

        const nose = OPTIONS.noseShape[parseInt(noseShape.value, 10)];
        if (nose === "Dot") drawRect(31, 34, 2, 2, shade(skin, -25));
        if (nose === "Bridge") { drawRect(31, 33, 2, 3, shade(skin, -25)); }

        const mouth = OPTIONS.mouthShape[parseInt(mouthShape.value, 10)];
        const mouthSizeLabel = OPTIONS.mouthSize[parseInt(mouthSize.value, 10)] || "Small";
        const blazer = OPTIONS.blazerStyle[parseInt(blazerStyle?.value || "0", 10)] || "None";
        const mouthWidth = mouthSizeLabel === "Big" ? 14 : 8;
        const mouthX = 32 - Math.floor(mouthWidth / 2);
        if (mouth === "Normal") {
          drawRect(mouthX, 40, mouthWidth, 1, shade(skin, -35));
        } else if (mouth === "Smile") {
          drawRect(mouthX, 41, mouthWidth, 1, shade(skin, -35));
          drawRect(mouthX, 40, 2, 1, shade(skin, -35));
          drawRect(mouthX + mouthWidth - 2, 40, 2, 1, shade(skin, -35));
        } else if (mouth === "Happy") {
          const lip = shade(skin, -35);
          drawRect(mouthX, 40, 2, 1, lip);
          drawRect(mouthX + mouthWidth - 2, 40, 2, 1, lip);
          drawRect(mouthX + 1, 41, mouthWidth - 2, 1, lip);
          drawRect(mouthX + 2, 42, Math.max(2, mouthWidth - 4), 1, lip);
          if (mouthWidth >= 10) drawRect(mouthX + 3, 43, mouthWidth - 6, 1, lip);
        }

        const outfitType = OPTIONS.outfitStyle[parseInt(outfitStyle.value, 10)];
        if (outfitType === "Standard Collar Shirt") {
          drawRect(20, 52, 24, 8, outfit);
          drawRect(22, 50, 8, 4, outfitLight);
          drawRect(34, 50, 8, 4, outfitLight);
          drawRect(28, 52, 8, 3, outfitShade);
        } else if (outfitType === "Button-Down Collar Shirt") {
          drawRect(20, 52, 24, 10, outfit);
          drawRect(24, 50, 6, 4, outfitLight);
          drawRect(34, 50, 6, 4, outfitLight);
          drawRect(31, 52, 2, 10, outfitShade);
          drawRect(31, 54, 2, 1, "#ffffff");
          drawRect(31, 57, 2, 1, "#ffffff");
          drawRect(31, 60, 2, 1, "#ffffff");
        } else if (outfitType === "Mandarin Collar Shirt") {
          drawRect(20, 52, 24, 10, outfit);
          drawRect(28, 50, 8, 3, outfitLight);
          drawRect(31, 53, 2, 9, outfitShade);
        } else if (outfitType === "Crew Neck T-Shirt") {
          drawRect(18, 52, 28, 10, outfit);
          drawRect(26, 50, 12, 3, outfitShade);
          drawRect(22, 56, 20, 4, outfitLight);
        } else if (outfitType === "Turtleneck Top") {
          drawRect(20, 52, 24, 10, outfit);
          drawRect(27, 49, 10, 4, outfitShade);
          drawRect(24, 56, 16, 2, outfitLight);
        } else if (outfitType === "Turtleneck Sweater") {
          drawRect(18, 52, 28, 6, outfit);
          drawRect(16, 58, 32, 6, outfitLight);
          drawRect(27, 49, 10, 4, outfitShade);
          drawRect(18, 60, 28, 2, outfitShade);
        }

        if (blazer === "Notched Lapel Blazer") {
          const blazerDark = shade(outfit, -28);
          drawRect(18, 52, 28, 10, blazerDark);
          drawRect(22, 52, 8, 6, outfitShade);
          drawRect(34, 52, 8, 6, outfitShade);
          drawRect(30, 52, 4, 10, shade(blazerDark, 10));
          drawRect(30, 55, 4, 1, outfitLight);
          drawRect(30, 58, 4, 1, outfitLight);
        }

      }

      function setLayer(img, filename) {
        if (!img) return;
        const loadToken = String(Date.now() + Math.random());
        img.dataset.layerLoadToken = loadToken;
        img.onerror = null;
        const fileQueue = Array.isArray(filename) ? filename.filter(Boolean) : [filename].filter(Boolean);
        if (fileQueue.length > 0) {
          let idx = 0;
          const tryNext = () => {
            if (img.dataset.layerLoadToken !== loadToken) return;
            if (idx >= fileQueue.length) {
              img.onerror = null;
              img.src = "";
              img.style.display = "none";
              return;
            }
            const current = fileQueue[idx++];
            let triedUpper = false;
            img.onerror = () => {
              if (img.dataset.layerLoadToken !== loadToken) return;
              if (!triedUpper && current.endsWith(".png")) {
                triedUpper = true;
                img.src = `${ILLUSTRATED_BASE}${current.replace(/\.png$/i, ".PNG")}`;
                return;
              }
              tryNext();
            };
            img.src = `${ILLUSTRATED_BASE}${current}`;
            img.style.display = "block";
          };
          tryNext();
        } else {
          img.onerror = null;
          img.src = "";
          img.style.display = "none";
        }
      }

      function slugify(value) {
        return String(value || "")
          .toLowerCase()
          .replace(/\s+/g, "_")
          .replace(/[^a-z0-9_]/g, "");
      }

      function updateIllustrated() {
        if (!drawBody && !drawNose) return;
        const gender = OPTIONS.genderStyle[parseInt(genderStyle.value, 10)] || "Neutral";
        const genderSlug = slugify(gender);
        let bodyFile = "body_neutral.png";
        if (gender === "Masculine") bodyFile = "body_masculine.png";
        if (gender === "Feminine") bodyFile = "body_feminine.png";

        const nose = OPTIONS.noseShape[parseInt(noseShape.value, 10)] || "Dot";
        let noseFile = "nose_normal.png";
        if (nose === "Dot") noseFile = "nose_dot.png";
        if (nose === "Bridge") noseFile = "nose_bridge.png";

        const outfit = OPTIONS.outfitStyle[parseInt(outfitStyle.value, 10)] || "Standard Collar Shirt";
        const blazer = OPTIONS.blazerStyle[parseInt(blazerStyle?.value || "0", 10)] || "None";
        const outfitFile = `outfit_${slugify(outfit)}_${genderSlug}.png`;
        const blazerFile = blazer === "Notched Lapel Blazer"
          ? `blazer_notched_lapel_blazer_${genderSlug}.png`
          : "";
        const mouth = OPTIONS.mouthShape[parseInt(mouthShape.value, 10)] || "Normal";
        const mouthSz = OPTIONS.mouthSize[parseInt(mouthSize.value, 10)] || "Small";
        const mouthFile = `mouth_${slugify(mouth)}_${slugify(mouthSz)}.png`;
        const eye = OPTIONS.eyeShape[parseInt(eyeShape.value, 10)] || "Normal";
        const eyeGender = gender === "Feminine" ? "feminine" : "neutral";
        const winkSide = OPTIONS.eyeWinkSide[parseInt(eyeWinkSide?.value || "0", 10)] || "Both";
        const winkSecond = OPTIONS.eyeWinkSecond[parseInt(eyeWinkSecond?.value || "0", 10)] || "Normal";
        const closedSide = OPTIONS.eyeClosedSide
          ? (OPTIONS.eyeClosedSide[parseInt(eyeClosedSide?.value || "0", 10)] || "Both")
          : "Both";
        const singleEyeSide = eye === "Wink" ? winkSide : closedSide;
        const hasSingleSidedEye = (eye === "Wink" || eye === "Closed") && singleEyeSide !== "Both";
        const singleSideSlug = slugify(singleEyeSide);
        const openSideSlug = singleSideSlug === "left" ? "right" : "left";
        const otherEyeSlug = slugify(winkSecond);
        const eyeFile = hasSingleSidedEye
          ? [
              `eyes_single_${openSideSlug}_${otherEyeSlug}_${eyeGender}.png`,
              `eyes_single_${openSideSlug}_${otherEyeSlug}_neutral.png`,
            ]
          : eye === "Closed" || eye === "Wink"
            ? ""
            : `eyes_${slugify(eye)}_${eyeGender}.png`;
        const winkFile = eye === "Wink"
          ? hasSingleSidedEye
            ? `eyes_wink_${singleSideSlug}_${eyeGender}.png`
            : `eyes_wink_${slugify(winkSide)}_${eyeGender}.png`
          : "";
        const closedFile = eye === "Closed"
          ? hasSingleSidedEye
            ? [
                `eyes_closed_${singleSideSlug}_${eyeGender}.png`,
                `eyes_closed_${singleSideSlug}_neutral.png`,
                `eyes_closed_${singleSideSlug}.png`,
              ]
            : [
                `eyes_closed_${slugify(closedSide)}_${eyeGender}.png`,
                `eyes_closed_${slugify(closedSide)}_neutral.png`,
                `eyes_closed_${slugify(closedSide)}.png`,
              ]
          : "";
        const brow = OPTIONS.browShape[parseInt(browShape.value, 10)] || "Normal";
        const browFile = `brows_${slugify(brow)}.png`;
        const backType = OPTIONS.hairBack[parseInt(hairBack.value, 10)] || "Straight";
        const backLength = OPTIONS.hairBackLength[parseInt(hairBackLength.value, 10)] || "Short";
        const backOther = OPTIONS.hairBackOther[parseInt(hairBackOther.value, 10)] || "Shoulder-Length Layered";
        const front = OPTIONS.hairFront[parseInt(hairFront.value, 10)] || "Blocky Bangs";
        const frontSide = OPTIONS.hairFrontSide[parseInt(hairFrontSide?.value || "0", 10)] || "Left";
        const temples = OPTIONS.hairTemples[parseInt(hairTemples.value, 10)] || "None";
        const braids = OPTIONS.hairBraids[parseInt(hairBraids.value, 10)] || "None";
        const singlePos = OPTIONS.hairSingleBraidPos[parseInt(hairSingleBraidPos.value, 10)] || "High";
        const singleLen = OPTIONS.hairSingleBraidLen[parseInt(hairSingleBraidLen.value, 10)] || "Short";
        const doubleStyle = OPTIONS.hairDoubleBraidStyle[parseInt(hairDoubleBraidStyle.value, 10)] || "Twin ponytails";
        const doubleSide = OPTIONS.hairDoubleBraidSide[parseInt(hairDoubleBraidSide.value, 10)] || "Both";
        const doubleLen = OPTIONS.hairDoubleBraidLen[parseInt(hairDoubleBraidLen.value, 10)] || "Short";
        const lowTwinLen = OPTIONS.hairLowTwinLen[parseInt(hairLowTwinLen.value, 10)] || "Short";
        const backHairFile = backType === "Base Style"
          ? "hair_back_base_style.png"
          : backType === "Other"
            ? `hair_back_other_${slugify(backOther)}.png`
            : `hair_back_${slugify(backType)}_${slugify(backLength)}.png`;
        const frontHairNeedsSide = front === "Single Cat Ear Fringe"
          || front === "Asymmetrical Block Fringe"
          || front === "Simplified Asymmetrical Fringe"
          || front === "One-Sided Swept Fringe";
        const frontHairFile = frontHairNeedsSide
          ? `hair_front_${slugify(front)}_${slugify(frontSide)}.png`
          : `hair_front_${slugify(front)}.png`;
        const templesFile = temples === "None" ? "" : `hair_temples_${slugify(temples)}.png`;
        let braidsFile = "";
        if (braids === "Single") {
          braidsFile = singlePos === "Ponytail"
            ? `hair_braids_single_ponytail_${slugify(singleLen)}.png`
            : `hair_braids_single_${slugify(singlePos)}.png`;
        } else if (braids === "Double") {
          if (doubleStyle === "Twin ponytails") {
            braidsFile = `hair_braids_double_twin_ponytails_${slugify(doubleLen)}_${slugify(doubleSide)}.png`;
          } else if (doubleStyle === "Low twin ponytails") {
            braidsFile = `hair_braids_double_low_twin_ponytails_${slugify(lowTwinLen)}_${slugify(doubleSide)}.png`;
          } else {
            braidsFile = `hair_braids_double_${slugify(doubleStyle)}_${slugify(doubleSide)}.png`;
          }
        }
        let pupilFile = "pupil.png";
        let showPupil = (pupilToggle ? pupilToggle.checked : true) && eye !== "Wink" && eye !== "Closed";
        if (hasSingleSidedEye && (pupilToggle ? pupilToggle.checked : true)) {
          pupilFile = `pupil_single_${openSideSlug}.png`;
          showPupil = true;
        }

        setLayer(drawBackHair, backHairFile);
        setLayer(drawBody, bodyFile);
        setLayer(drawNose, noseFile);
        setLayer(drawEyes, eyeFile);
        setLayer(drawWink, winkFile);
        setLayer(drawClosed, closedFile);
        setLayer(drawPupil, showPupil ? pupilFile : "");
        setLayer(drawBrows, browFile);
        setLayer(drawMouth, mouthFile);
        setLayer(drawFrontHair, frontHairFile);
        setLayer(drawTemples, templesFile);
        setLayer(drawBraids, braidsFile);
        setLayer(drawOutfit, outfitFile);
        setLayer(drawAccessory, blazerFile);
        updateIllustratedEyeTint();
      }

      function hexToRgba(hex, alpha) {
        const raw = String(hex || "").replace("#", "");
        if (!/^[0-9a-fA-F]{6}$/.test(raw)) return `rgba(0,0,0,${alpha})`;
        const n = parseInt(raw, 16);
        const r = (n >> 16) & 0xff;
        const g = (n >> 8) & 0xff;
        const b = n & 0xff;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function updateIllustratedEyeTint() {
        if (!drawEyeTint) return;
        const w = 512;
        const h = 512;
        if (drawEyeTint.width !== w) drawEyeTint.width = w;
        if (drawEyeTint.height !== h) drawEyeTint.height = h;
        const tx = drawEyeTint.getContext("2d");
        if (!tx) return;
        tx.clearRect(0, 0, w, h);
        drawEyeTint.style.display = "none";
      }

      function randomizeAll() {
        skinColor.value = String(randIdx(COLORS.skin));
        hairColor.value = String(randIdx(COLORS.hair));
        hairHighlight.value = String(randIdx([0].concat(COLORS.hair.map((_, i) => i + 1))));
        leftEyeColor.value = String(randIdx(COLORS.eyes));
        rightEyeColor.value = String(randIdx(COLORS.eyes));
        leftEyeTop.value = String(randIdx(COLORS.eyes));
        leftEyeBottom.value = String(randIdx(COLORS.eyes));
        rightEyeTop.value = String(randIdx(COLORS.eyes));
        rightEyeBottom.value = String(randIdx(COLORS.eyes));
        if (eyeSpecialToggle) eyeSpecialToggle.checked = Math.random() < 0.35;
        if (pupilToggle) pupilToggle.checked = true;
        hairBack.value = String(randIdx(OPTIONS.hairBack));
        hairBackLength.value = String(randIdx(OPTIONS.hairBackLength));
        hairBackOther.value = String(randIdx(OPTIONS.hairBackOther));
        hairFront.value = String(randIdx(OPTIONS.hairFront));
        hairFrontSide.value = String(randIdx(OPTIONS.hairFrontSide));
        hairTemples.value = String(randIdx(OPTIONS.hairTemples));
        hairBraids.value = String(randIdx(OPTIONS.hairBraids));
        hairSingleBraidPos.value = String(randIdx(OPTIONS.hairSingleBraidPos));
        hairSingleBraidLen.value = String(randIdx(OPTIONS.hairSingleBraidLen));
        hairDoubleBraidStyle.value = String(randIdx(OPTIONS.hairDoubleBraidStyle));
        hairDoubleBraidSide.value = String(randIdx(OPTIONS.hairDoubleBraidSide));
        hairDoubleBraidLen.value = String(randIdx(OPTIONS.hairDoubleBraidLen));
        hairLowTwinLen.value = String(randIdx(OPTIONS.hairLowTwinLen));
        eyeShape.value = String(randIdx(OPTIONS.eyeShape));
        eyeWinkSide.value = String(randIdx(OPTIONS.eyeWinkSide));
        eyeWinkSecond.value = String(randIdx(OPTIONS.eyeWinkSecond));
        eyeClosedSide.value = String(randIdx(OPTIONS.eyeClosedSide));
        browShape.value = String(OPTIONS.browShape.indexOf("Normal"));
        noseShape.value = String(randIdx(OPTIONS.noseShape));
        mouthShape.value = String(randIdx(OPTIONS.mouthShape));
        mouthSize.value = String(randIdx(OPTIONS.mouthSize));
        outfitStyle.value = String(randIdx(OPTIONS.outfitStyle));
        blazerStyle.value = String(randIdx(OPTIONS.blazerStyle));
        outfitColor.value = String(randIdx(COLORS.outfit));
        bgStyle.value = String(randIdx(OPTIONS.bgStyle));
        bgColor.value = String(randIdx(COLORS.background));
        genderStyle.value = String(randIdx(OPTIONS.genderStyle));
        updateEyeVisibility();
        updateMouthSizeVisibility();
        updateBackHairLengthVisibility();
        updateFrontBangSideVisibility();
        updateBraidsAvailability();
        updateDoubleBraidVisibility();
        updateSingleBraidVisibility();
        updateWinkVisibility();
        drawPortrait();
        updateIllustrated();
      }

      function updateEyeVisibility() {
        const special = !!eyeSpecialToggle.checked;
        rightEyeColor.parentElement.style.display = special ? "" : "none";
        leftEyeTop.parentElement.style.display = special ? "" : "none";
        leftEyeBottom.parentElement.style.display = special ? "" : "none";
        rightEyeTop.parentElement.style.display = special ? "" : "none";
        rightEyeBottom.parentElement.style.display = special ? "" : "none";
      }

      function updateWinkVisibility() {
        const eyeForm = OPTIONS.eyeShape[parseInt(eyeShape.value, 10)] || "Normal";
        if (eyeWinkSide) {
          const showSide = eyeForm === "Wink";
          eyeWinkSide.parentElement.style.display = showSide ? "" : "none";
          if (!showSide) eyeWinkSide.value = "0";
        }
        if (eyeClosedSide) {
          const showClosedSide = eyeForm === "Closed";
          eyeClosedSide.parentElement.style.display = showClosedSide ? "" : "none";
          if (!showClosedSide) eyeClosedSide.value = "0";
        }
        if (eyeWinkSecond) {
          const activeSide = eyeForm === "Wink"
            ? (OPTIONS.eyeWinkSide[parseInt(eyeWinkSide?.value || "0", 10)] || "Both")
            : eyeForm === "Closed"
              ? (OPTIONS.eyeClosedSide[parseInt(eyeClosedSide?.value || "0", 10)] || "Both")
              : "Both";
          const showSecond = (eyeForm === "Wink" || eyeForm === "Closed") && activeSide !== "Both";
          eyeWinkSecond.parentElement.style.display = showSecond ? "" : "none";
          if (!showSecond) eyeWinkSecond.value = "0";
        }
      }

      function updateMouthSizeVisibility() {
        const gender = OPTIONS.genderStyle[parseInt(genderStyle.value, 10)] || "Neutral";
        if (!mouthSize) return;
        if (gender === "Neutral") {
          mouthSize.parentElement.style.display = "";
        } else {
          mouthSize.parentElement.style.display = "none";
          mouthSize.value = gender === "Masculine" ? "1" : "0";
        }
      }

      function updateFrontBangSideVisibility() {
        if (!hairFrontSide || !hairFront) return;
        const front = OPTIONS.hairFront[parseInt(hairFront.value, 10)] || "Blocky Bangs";
        const special = front === "Single Cat Ear Fringe"
          || front === "Asymmetrical Block Fringe"
          || front === "Simplified Asymmetrical Fringe"
          || front === "One-Sided Swept Fringe";
        hairFrontSide.parentElement.style.display = special ? "" : "none";
        if (!special) hairFrontSide.value = "0";
      }

      function updateDoubleBraidVisibility() {
        const braids = OPTIONS.hairBraids[parseInt(hairBraids.value, 10)] || "None";
        if (hairDoubleBraidStyle) {
          hairDoubleBraidStyle.parentElement.style.display = braids === "Double" ? "" : "none";
          if (braids !== "Double") hairDoubleBraidStyle.value = "0";
        }
        if (hairDoubleBraidSide) {
          hairDoubleBraidSide.parentElement.style.display = braids === "Double" ? "" : "none";
          if (braids !== "Double") hairDoubleBraidSide.value = "0";
        }
        const style = OPTIONS.hairDoubleBraidStyle[parseInt(hairDoubleBraidStyle?.value || "0", 10)] || "Twin ponytails";
        if (hairDoubleBraidLen) {
          const showTwin = braids === "Double" && style === "Twin ponytails";
          hairDoubleBraidLen.parentElement.style.display = showTwin ? "" : "none";
          if (!showTwin) hairDoubleBraidLen.value = "0";
        }
        if (hairLowTwinLen) {
          const showLowTwin = braids === "Double" && style === "Low twin ponytails";
          hairLowTwinLen.parentElement.style.display = showLowTwin ? "" : "none";
          if (!showLowTwin) hairLowTwinLen.value = "0";
        }
      }

      function updateSingleBraidVisibility() {
        const braids = OPTIONS.hairBraids[parseInt(hairBraids.value, 10)] || "None";
        if (hairSingleBraidPos) {
          hairSingleBraidPos.parentElement.style.display = braids === "Single" ? "" : "none";
          if (braids !== "Single") hairSingleBraidPos.value = "0";
        }
        if (hairSingleBraidLen) {
          const pos = OPTIONS.hairSingleBraidPos[parseInt(hairSingleBraidPos?.value || "0", 10)] || "High";
          if (braids === "Single" && pos === "Ponytail") {
            hairSingleBraidLen.parentElement.style.display = "";
          } else {
            hairSingleBraidLen.parentElement.style.display = "none";
            hairSingleBraidLen.value = "0";
          }
        }
      }

      function updateBraidsAvailability() {
        const backType = OPTIONS.hairBack[parseInt(hairBack.value, 10)] || "Base Style";
        const enabled = backType === "Base Style";
        if (hairBraids) {
          hairBraids.parentElement.style.display = enabled ? "" : "none";
          if (!enabled) hairBraids.value = "0";
        }
        if (!enabled) {
          if (hairSingleBraidPos) hairSingleBraidPos.value = "0";
          if (hairSingleBraidLen) hairSingleBraidLen.value = "0";
          if (hairDoubleBraidStyle) hairDoubleBraidStyle.value = "0";
          if (hairDoubleBraidSide) hairDoubleBraidSide.value = "0";
          if (hairDoubleBraidLen) hairDoubleBraidLen.value = "0";
          if (hairLowTwinLen) hairLowTwinLen.value = "0";
        }
      }

      function updateBackHairLengthVisibility() {
        const backType = OPTIONS.hairBack[parseInt(hairBack.value, 10)] || "Straight";
        if (!hairBackLength) return;
        if (backType === "Other") {
          hairBackLength.parentElement.style.display = "none";
          hairBackLength.value = "0";
          if (hairBackOther) {
            hairBackOther.parentElement.style.display = "";
          }
        } else if (backType === "Base Style") {
          hairBackLength.parentElement.style.display = "none";
          hairBackLength.value = "0";
          if (hairBackOther) {
            hairBackOther.parentElement.style.display = "none";
            hairBackOther.value = "0";
          }
        } else {
          hairBackLength.parentElement.style.display = "";
          if (hairBackOther) {
            hairBackOther.parentElement.style.display = "none";
            hairBackOther.value = "0";
          }
        }
      }

      [
        skinColor, hairColor, hairHighlight, leftEyeColor, rightEyeColor, leftEyeTop, leftEyeBottom, rightEyeTop, rightEyeBottom,
        hairBack, hairBackLength, hairBackOther, hairFront, hairFrontSide, hairTemples, hairBraids, hairSingleBraidPos, hairSingleBraidLen, hairDoubleBraidStyle, hairDoubleBraidSide, hairDoubleBraidLen, hairLowTwinLen, eyeShape, eyeWinkSide, eyeWinkSecond, eyeClosedSide,
        noseShape, mouthShape, mouthSize, browShape, outfitStyle, blazerStyle, outfitColor, bgStyle, bgColor, genderStyle
      ].forEach((el) => el.addEventListener("change", () => {
        updateEyeVisibility();
        updateMouthSizeVisibility();
        updateBackHairLengthVisibility();
        updateFrontBangSideVisibility();
        updateBraidsAvailability();
        updateDoubleBraidVisibility();
        updateSingleBraidVisibility();
        updateWinkVisibility();
        drawPortrait();
        updateIllustrated();
      }));

      eyeSpecialToggle.addEventListener("change", () => {
        updateEyeVisibility();
        drawPortrait();
        updateIllustrated();
      });

      if (pupilToggle) {
        pupilToggle.addEventListener("change", () => {
          drawPortrait();
          updateIllustrated();
        });
      }

      randomBtn.addEventListener("click", randomizeAll);

      function exportIllustratedCanvas() {
        if (!illustratedPortrait) return null;
        const out = document.createElement("canvas");
        const size = 512;
        out.width = size;
        out.height = size;
        const outCtx = out.getContext("2d");
        if (!outCtx) return null;

        const layerOrder = [
          "drawBackHair",
          "drawBody",
          "drawNose",
          "drawEyes",
          "drawEyeTint",
          "drawWink",
          "drawClosed",
          "drawPupil",
          "drawBrows",
          "drawMouth",
          "drawFrontHair",
          "drawTemples",
          "drawBraids",
          "drawOutfit",
          "drawAccessory",
        ];

        layerOrder.forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          if (getComputedStyle(el).display === "none") return;

          if (el.tagName === "IMG") {
            const img = el;
            if (!img.src || !img.complete || !img.naturalWidth) return;
            outCtx.drawImage(img, 0, 0, size, size);
            return;
          }
          if (el.tagName === "CANVAS") {
            const layerCanvas = el;
            outCtx.drawImage(layerCanvas, 0, 0, size, size);
          }
        });

        return out;
      }

      downloadBtn.addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "spertz-portrait.png";
        const isIllustrated = portraitViewIllustrated && portraitViewIllustrated.classList.contains("active");
        const exportCanvas = isIllustrated ? (exportIllustratedCanvas() || canvas) : canvas;
        link.href = exportCanvas.toDataURL("image/png");
        link.click();
      });

      function setPortraitView(view) {
        if (portraitViewPixel) {
          portraitViewPixel.classList.toggle("active", view === "pixel");
        }
        if (portraitViewIllustrated) {
          portraitViewIllustrated.classList.toggle("active", view === "illustrated");
        }
        portraitTabs.forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.portraitView === view);
        });
      }

      portraitTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          setPortraitView(tab.dataset.portraitView || "pixel");
        });
      });

      updateEyeVisibility();
      updateMouthSizeVisibility();
      updateBackHairLengthVisibility();
      updateFrontBangSideVisibility();
      updateBraidsAvailability();
      updateDoubleBraidVisibility();
      updateSingleBraidVisibility();
      updateWinkVisibility();
      randomizeAll();
      setPortraitView("illustrated");
    })();

    // ===== Share Your Character =====
    (function () {
      const shareCode = document.getElementById("shareCode");
      const shareGenerate = document.getElementById("shareGenerate");
      const shareApply = document.getElementById("shareApply");
      const shareStatus = document.getElementById("shareStatus");

      if (!shareCode || !shareGenerate || !shareApply || !shareStatus) return;

      const PREFIX = "SPERTZ1:";

      function encode(obj) {
        const json = JSON.stringify(obj);
        const b64 = btoa(unescape(encodeURIComponent(json)));
        return PREFIX + b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      }

      function decode(str) {
        if (!str.startsWith(PREFIX)) throw new Error("Invalid code (missing prefix).");
        let b64 = str.slice(PREFIX.length).replace(/-/g, "+").replace(/_/g, "/");
        while (b64.length % 4) b64 += "=";
        const json = decodeURIComponent(escape(atob(b64)));
        return JSON.parse(json);
      }

      function setValue(el, value, eventType) {
        if (!el) return;
        el.value = value;
        const evt = new Event(eventType || "change", { bubbles: true });
        el.dispatchEvent(evt);
      }

      function optionLabel(id, optionsKey) {
        const el = document.getElementById(id);
        const opts = window.PORTRAIT_OPTIONS && window.PORTRAIT_OPTIONS[optionsKey];
        if (!el || !opts) return "";
        return opts[parseInt(el.value || "0", 10)] || "";
      }

      function setByLabelOrValue(id, value, label, optionsKey) {
        const el = document.getElementById(id);
        if (!el) return;
        const opts = window.PORTRAIT_OPTIONS && window.PORTRAIT_OPTIONS[optionsKey];
        if (label && opts && Array.isArray(opts)) {
          const idx = opts.indexOf(label);
          if (idx >= 0) {
            setValue(el, String(idx));
            return;
          }
        }
        setValue(el, value || "0");
      }

      function buildPayload() {
        return {
          name: {
            firstMode: document.getElementById("firstMode")?.value || "random",
            firstSyl: document.getElementById("firstSyl")?.value || "2",
            customFirst: document.getElementById("customFirst")?.value || "",
            lastMode: document.getElementById("lastMode")?.value || "random",
            lastSyl: document.getElementById("lastSyl")?.value || "2",
            customLast: document.getElementById("customLast")?.value || "",
            middleMode: document.getElementById("middleMode")?.value || "none",
            middleSyl: document.getElementById("middleSyl")?.value || "2",
            customMiddle: document.getElementById("customMiddle")?.value || "",
            nameStyle: document.getElementById("nameStyle")?.value || "none",
            gender: document.getElementById("genderSelect")?.value || "unknown",
          },
          birthday: {
            year: document.getElementById("birthYear")?.value || "",
            month: document.getElementById("birthMonth")?.value || "0",
            day: document.getElementById("birthDay")?.value || "",
          },
          portrait: {
            skinColor: document.getElementById("skinColor")?.value || "0",
            hairColor: document.getElementById("hairColor")?.value || "0",
            hairHighlight: document.getElementById("hairHighlight")?.value || "0",
            leftEyeColor: document.getElementById("leftEyeColor")?.value || "0",
            rightEyeColor: document.getElementById("rightEyeColor")?.value || "0",
            leftEyeTop: document.getElementById("leftEyeTop")?.value || "0",
            leftEyeBottom: document.getElementById("leftEyeBottom")?.value || "0",
            rightEyeTop: document.getElementById("rightEyeTop")?.value || "0",
            rightEyeBottom: document.getElementById("rightEyeBottom")?.value || "0",
            eyeSpecial: document.getElementById("eyeSpecialToggle")?.checked ? "1" : "0",
            pupil: document.getElementById("pupilToggle")?.checked ? "1" : "0",
            eyeWinkSide: document.getElementById("eyeWinkSide")?.value || "0",
            eyeWinkSecond: document.getElementById("eyeWinkSecond")?.value || "0",
            eyeClosedSide: document.getElementById("eyeClosedSide")?.value || "0",
            eyeWinkSideLabel: optionLabel("eyeWinkSide", "eyeWinkSide"),
            eyeWinkSecondLabel: optionLabel("eyeWinkSecond", "eyeWinkSecond"),
            eyeClosedSideLabel: optionLabel("eyeClosedSide", "eyeClosedSide"),
            browShape: document.getElementById("browShape")?.value || "0",
            hairBack: document.getElementById("hairBack")?.value || "0",
            hairBackLength: document.getElementById("hairBackLength")?.value || "0",
            hairBackOther: document.getElementById("hairBackOther")?.value || "0",
            hairFront: document.getElementById("hairFront")?.value || "0",
            hairFrontSide: document.getElementById("hairFrontSide")?.value || "0",
            hairFrontLabel: optionLabel("hairFront", "hairFront"),
            hairFrontSideLabel: optionLabel("hairFrontSide", "hairFrontSide"),
            hairTemples: document.getElementById("hairTemples")?.value || "0",
            hairBraids: document.getElementById("hairBraids")?.value || "0",
            hairSingleBraidPos: document.getElementById("hairSingleBraidPos")?.value || "0",
            hairSingleBraidLen: document.getElementById("hairSingleBraidLen")?.value || "0",
            hairDoubleBraidStyle: document.getElementById("hairDoubleBraidStyle")?.value || "0",
            hairDoubleBraidSide: document.getElementById("hairDoubleBraidSide")?.value || "0",
            hairDoubleBraidLen: document.getElementById("hairDoubleBraidLen")?.value || "0",
            hairLowTwinLen: document.getElementById("hairLowTwinLen")?.value || "0",
            eyeShape: document.getElementById("eyeShape")?.value || "0",
            eyeShapeLabel: optionLabel("eyeShape", "eyeShape"),
            noseShape: document.getElementById("noseShape")?.value || "0",
            mouthShape: document.getElementById("mouthShape")?.value || "0",
            mouthSize: document.getElementById("mouthSize")?.value || "0",
            outfitStyle: document.getElementById("outfitStyle")?.value || "0",
            blazerStyle: document.getElementById("blazerStyle")?.value || "0",
            outfitStyleLabel: optionLabel("outfitStyle", "outfitStyle"),
            blazerStyleLabel: optionLabel("blazerStyle", "blazerStyle"),
            outfitColor: document.getElementById("outfitColor")?.value || "0",
            bgStyle: document.getElementById("bgStyle")?.value || "0",
            bgColor: document.getElementById("bgColor")?.value || "0",
            genderStyle: document.getElementById("genderStyle")?.value || "0",
          }
        };
      }

      function applyPayload(data) {
        const n = data.name || {};
        setValue(document.getElementById("firstMode"), n.firstMode || "random");
        setValue(document.getElementById("firstSyl"), n.firstSyl || "2");
        setValue(document.getElementById("customFirst"), n.customFirst || "", "input");

        setValue(document.getElementById("lastMode"), n.lastMode || "random");
        setValue(document.getElementById("lastSyl"), n.lastSyl || "2");
        setValue(document.getElementById("customLast"), n.customLast || "", "input");

        setValue(document.getElementById("middleMode"), n.middleMode || "none");
        setValue(document.getElementById("middleSyl"), n.middleSyl || "2");
        setValue(document.getElementById("customMiddle"), n.customMiddle || "", "input");

        setValue(document.getElementById("nameStyle"), n.nameStyle || "none");
        setValue(document.getElementById("genderSelect"), n.gender || "unknown");

        const b = data.birthday || {};
        setValue(document.getElementById("birthYear"), b.year || "", "input");
        setValue(document.getElementById("birthMonth"), b.month || "0");
        setValue(document.getElementById("birthDay"), b.day || "", "input");

        const p = data.portrait || {};
        setValue(document.getElementById("skinColor"), p.skinColor || "0");
        setValue(document.getElementById("hairColor"), p.hairColor || "0");
        setValue(document.getElementById("hairHighlight"), p.hairHighlight || "0");
        setValue(document.getElementById("leftEyeColor"), p.leftEyeColor || "0");
        const eyeSpecial = document.getElementById("eyeSpecialToggle");
        if (eyeSpecial) {
          eyeSpecial.checked = p.eyeSpecial === "1";
          eyeSpecial.dispatchEvent(new Event("change", { bubbles: true }));
        }
        setValue(document.getElementById("rightEyeColor"), p.rightEyeColor || "0");
        setValue(document.getElementById("leftEyeTop"), p.leftEyeTop || "0");
        setValue(document.getElementById("leftEyeBottom"), p.leftEyeBottom || "0");
        setValue(document.getElementById("rightEyeTop"), p.rightEyeTop || "0");
        setValue(document.getElementById("rightEyeBottom"), p.rightEyeBottom || "0");
        const pupilToggle = document.getElementById("pupilToggle");
        if (pupilToggle) {
          pupilToggle.checked = p.pupil !== "0";
          pupilToggle.dispatchEvent(new Event("change", { bubbles: true }));
        }
        setByLabelOrValue("eyeWinkSide", p.eyeWinkSide || "0", p.eyeWinkSideLabel, "eyeWinkSide");
        setByLabelOrValue("eyeWinkSecond", p.eyeWinkSecond || "0", p.eyeWinkSecondLabel, "eyeWinkSecond");
        setByLabelOrValue("eyeClosedSide", p.eyeClosedSide || "0", p.eyeClosedSideLabel, "eyeClosedSide");
        setValue(document.getElementById("browShape"), p.browShape || "0");
        setValue(document.getElementById("hairBack"), p.hairBack || "0");
        setValue(document.getElementById("hairBackLength"), p.hairBackLength || "0");
        setValue(document.getElementById("hairBackOther"), p.hairBackOther || "0");
        setByLabelOrValue("hairFront", p.hairFront || p.hairBangs || "0", p.hairFrontLabel, "hairFront");
        setByLabelOrValue("hairFrontSide", p.hairFrontSide || p.hairBangsSide || "0", p.hairFrontSideLabel || p.hairBangsSideLabel, "hairFrontSide");
        setValue(document.getElementById("hairTemples"), p.hairTemples || "0");
        setValue(document.getElementById("hairBraids"), p.hairBraids || "0");
        setValue(document.getElementById("hairSingleBraidPos"), p.hairSingleBraidPos || "0");
        setValue(document.getElementById("hairSingleBraidLen"), p.hairSingleBraidLen || "0");
        setValue(document.getElementById("hairDoubleBraidStyle"), p.hairDoubleBraidStyle || "0");
        setValue(document.getElementById("hairDoubleBraidSide"), p.hairDoubleBraidSide || "0");
        setValue(document.getElementById("hairDoubleBraidLen"), p.hairDoubleBraidLen || "0");
        setValue(document.getElementById("hairLowTwinLen"), p.hairLowTwinLen || "0");
        setByLabelOrValue("eyeShape", p.eyeShape || "0", p.eyeShapeLabel, "eyeShape");
        setValue(document.getElementById("noseShape"), p.noseShape || "0");
        setValue(document.getElementById("mouthShape"), p.mouthShape || "0");
        setValue(document.getElementById("mouthSize"), p.mouthSize || "0");
        setByLabelOrValue("outfitStyle", p.outfitStyle || "0", p.outfitStyleLabel, "outfitStyle");
        setByLabelOrValue("blazerStyle", p.blazerStyle || "0", p.blazerStyleLabel, "blazerStyle");
        setValue(document.getElementById("outfitColor"), p.outfitColor || "0");
        setValue(document.getElementById("bgStyle"), p.bgStyle || "0");
        setValue(document.getElementById("bgColor"), p.bgColor || "0");
        setValue(document.getElementById("genderStyle"), p.genderStyle || "0");
      }

      shareGenerate.addEventListener("click", () => {
        try {
          const payload = buildPayload();
          shareCode.value = encode(payload);
          shareStatus.textContent = "Code generated ✅";
        } catch (e) {
          shareStatus.textContent = `Error: ${e.message}`;
        }
      });

      shareApply.addEventListener("click", () => {
        try {
          const data = decode(shareCode.value.trim());
          applyPayload(data);
          shareStatus.textContent = "Code loaded ✅";
        } catch (e) {
          shareStatus.textContent = `Error: ${e.message}`;
        }
      });
    })();

    // ===== Resources: Spertz Lexicon (Verbs) =====
    (function () {
      const tbody = document.getElementById("lexiconBody");
      if (!tbody) return;

      const VERBS = [
        ["ampi","believe"],
        ["ampiria","hope"],
        ["aye","have"],
        ["beya","need, want"],
        ["dara","dance"],
        ["daresu","understand"],
        ["daro","suppose; assume"],
        ["davi","lose"],
        ["daze","close"],
        ["dezu","explain"],
        ["doye","cause; make"],
        ["dravo","arrive"],
        ["fane","end; finish"],
        ["fireno","request"],
        ["folo","forget"],
        ["fure","rest"],
        ["fureyi","continue"],
        ["gavu","eat"],
        ["golu","drink"],
        ["heta","speak; say"],
        ["heti","listen"],
        ["hodape","open"],
        ["jion","like"],
        ["kame","consider"],
        ["kampi","keep"],
        ["kamu","think"],
        ["korati","challenge"],
        ["krei","do; make"],
        ["krechei","decision"],
        ["lanko","belong to"],
        ["lavi","love"],
        ["laza","play"],
        ["liguria","shine; illuminate"],
        ["lika","read"],
        ["lume","research; study"],
        ["lure","talk; converse"],
        ["meli","remember"],
        ["melu","miss"],
        ["mezu","write"],
        ["mie","meet"],
        ["miori","participate"],
        ["mire","describe"],
        ["mura","marry"],
        ["namu","be called; be named"],
        ["nata","put; place"],
        ["navine","walk"],
        ["nelu","search; look for"],
        ["novi","follow"],
        ["oio","regard as; treat as"],
        ["paraya","leave"],
        ["petra","rise"],
        ["poso","occupy"],
        ["pozo","prove"],
        ["praisa","aim at"],
        ["praise","guide"],
        ["quino","ask"],
        ["quma","choose"],
        ["rake","get; obtain"],
        ["raku","prepare"],
        ["reni","answer"],
        ["revo","run"],
        ["revu","return"],
        ["sela","tell"],
        ["sire","paint"],
        ["sola","sleep"],
        ["solvia","sing"],
        ["soraye","study; learn"],
        ["sorae","teach"],
        ["sumi","count"],
        ["su","live; exist"],
        ["suri","live"],
        ["tamu","work"],
        ["tira","come"],
        ["tiru","bring"],
        ["tori","carry"],
        ["trake","begin; start"],
        ["tra","stand"],
        ["trepsa","oppose"],
        ["trive","share"],
        ["vayi","want"],
        ["veli","wait"],
        ["veska","travel"],
        ["veskari","please"],
        ["vese","see"],
        ["vire","receive"],
        ["vona","watch"],
        ["zanu","appreciate; admire"],
        ["zeyo","go"],
        ["zeyu","should"],
        ["zima","buy"],
      ];

      const sorted = VERBS.slice().sort((a, b) => {
        return a[0].localeCompare(b[0], "en", { sensitivity: "base" });
      });

      sorted.forEach(([sp, en], idx) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${idx + 1}</td><td><b>${sp}</b></td><td>${en}</td>`;
        tbody.appendChild(tr);
      });
    })();
  </script>

  <footer>
    &copy; 2026 Spertz.
  </footer>
</body>
</html>
